
!!  ---------------------------------------------------------------
!!  Xic/WRspice Help System Database
!!  $Id: spInput.hlp,v 1.47 2017/03/28 22:23:13 stevew Exp $
!!  Copyright (C) Whiteley Research Inc. 2003.  All Rights Reserved
!!  ---------------------------------------------------------------

!!TAG WRspice
!! This file in sync with manual.

!!KEYWORD
spInput.hlp
!!TITLE
spInput.hlp
!!HTML 

!!SUBTOPICS
spinput
titleinc
initialize
param
subckt
output
measure
execblock
verilog


!! format.tex 121011
!!KEYWORD
spinput
!!TITLE
<i>WRspice</i> Input Format
!!HTML 
    <table border=0>
    <tr><td valign=top><b>jump to</b></td> <td>
    <a href="spinput#case"><b>Case Sensitivity</b></a><br>
    <a href="spinput#number"><b>Numeric Values</b></a><br>
    <a href="spinput#varexp"><b>Variable Expansion in Input</b></a>
    </td></tr></table>

    <p>
    In this document, text which is provided in <tt>typewriter</tt>
    font represents verbatim input to or output from the program. 
    Text enclosed in square brackets ( [text] ) is optional in the
    given example, as in optional command arguments, whereas other
    text should be provided as indicated.  Text which is
    <i>italicized</i> should be replaced with the necessary input, as
    described in the accompanying text.

    <p>
    Input to <i>WRspice</i> consists of ASCII text, using either Unix
    or Microsoft Windows line termination methods.  Input is contained
    in one or more files.  If more than one file name is provided to
    the <a href="source"><b>source</b></a> command, the file contents
    will be concatenated in the order given, and/or split into
    multiple circuits if <a href=".newjob"><tt>.newjob</tt></a> lines
    are found.

    <p>
    There is provision in the syntax for file inclusions (referencing
    the content of another file) to arbitrary depth.  Once the input
    files are read, the lines are logically assembled into a "deck"
    for each circuit, and each line is sometimes referred to as a
    "card", terminology reflecting the punched-card heritage of the
    program.

    <p>
    The first line of a deck is taken as a title line for any circuit
    described in the deck.  If the deck does not define a circuit (it
    may consist of commands text only), the title line is not used,
    but with a few exceptions must be present in input.  The title
    line can contain 7-bit ASCII characters only.  If a character is
    found in the title line with the most-significant bit set, the
    read is aborted, as this is taken as binary input, and attempting
    to read a binary file would generate a cascade or errors or crash
    the program.  Binary characters can exist elsewhere in the file,
    if necessary for whatever reason.

    <p>
    One exception to the rule that the first line be a title line is
    if the first line of text in a file starts with the characters
    "<tt>#!</tt>", that line will be discarded when the file is read. 
    This enables <i>WRspice</i> input files to be self-executing using
    the mechanisms of the Unix shell.  For example, if the following
    line is prepended to an input file
    <blockquote>
    <tt>#! wrspice</tt>
    </blockquote>
    and the file is made executable, then typing the name of the file
    will initiate <i>WRspice</i> on the circuit contained in the file.
 
    <p>
    The remaining lines are either circuit element descriptions, or
    "dotcards", or blocks of text surrounded by dotcards.  The circuit
    element lines define the devices found in the circuit, providing
    connection points which define the circuit topology, and device
    parameter values.  The dotcards are lines whose initial token is a
    keyword starting with '.'.  These provide various control
    directives and data for use in simulating the circuit, including
    device models.  Some dotcards, such as <tt>.verilog</tt> and
    <tt>.control</tt> provide blocks of lines in some other format,
    which is different form the SPICE format and is described
    separately.

    <p>
    The order of the circuit definition and control lines is
    arbitrary, except that continuation lines must immediately follow
    the line being continued, and certain constructs contain blocks of
    lines, which may be command scripts which must be ordered.

    <p>
    Certain special input file formats are recognized, such as
    operating range analysis control files, and files generated by the
    <i>Xic</i> schematic capture front end.  Exceptions to the rule of
    arbitrary line placement will be described in the sections
    describing these files.

    <p>
    Fields on an element line and most dotcards are delimited by white
    space, a comma, an equal sign ('='), or left or right parentheses;
    extra white space is ignored.

    <p>
    A line may be continued to the following line(s) in two ways.  If
    the last character on a line is a backslash character
    (<tt>\</tt>), the "newline" is effectively hidden, and the text on
    the following line will be appended to the current line, however
    leading white space is stripped from the continuing line.  If
    there is more than one backslash at the end of the line, all will
    be stripped before the line is joined to the following line.  The
    traditional SPICE line continuation is also available, whereby a
    line may be continued by entering a <tt>+</tt> (plus) as the first
    non-white space character of the following line, <i>WRspice</i>
    will continue reading beginning with the character that follows.

    <p>
    Devices and device models are given names in input for reference. 
    These name fields must begin with a letter and cannot contain any
    delimiters.  Circuit connection points ("nodes") are also given
    arbitrary names, however these may start with or just be an
    integer.  The ground node must be named "<tt>0</tt>" (zero),
    however.  Note that "<tt>00</tt>" (for example) and "<tt>0</tt>"
    are distinct in <i>WRspice</i>, but not in SPICE2.  Non-ground
    node names may have trailing or embedded punctuation (but this is
    generally not recommended).

    <a name="case"></a>
    <h2>Case Sensitivity</h2>

    In <i>WRspice</i>, case sensitivity of various object names and
    strings is under program control.  Historically the following have
    all been case sensitive in WRspice:

    <blockquote>
    Function names.<br>
    User-defined function names.<br>
    Vector names.<br>
    .PARAM names.<br>
    Codeblock names.<br>
    Node and device names.<br>
    </blockquote>

    <p>
    By default, starting in release 3.2.4, function names and
    user-defined function names were made case-insensitive.  Starting
    in release 3.2.15, parameter names were made case-insensitive. 
    Finally, in 3.2.16, the remaining categories were made
    case-insensitive.  Thus, in present releases, all identifiers are
    case-insensitive.  This seems to be the common practice in
    commercial simulators. 

    <p>
    Case sensitivity must be established at program startup and can
    not be changed during operation.  There are two ways to accomplish
    this:
    <ol>
    <li>The "<tt>-c</tt>" command line <a href="arguments#-c">option</a>.
    <li>The <a href="setcase"><b>setcase</b></a> command called in
    a <a href="startup_files">startup</a> file.
    </ol>
 
    <a name="number"></a>
    <h2>Numeric Values</h2>

    A number field may be an integer field (12, -44), a floating point
    field (3.14159), either an integer or floating point number
    followed by an integer exponent (1E-14, 2.65e3), or either an
    integer or a floating point number followed by one of the
    following scale factors.  All of this is case-insensitive.

    <blockquote>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><td><tt>t</tt><td>1e12</tr>
    <tr><td><tt>g</tt><td>1e9</tr>
    <tr><td><tt>meg</tt><td>1e6</tr>
    <tr><td><tt>k</tt><td>1e3</tr>
    <tr><td><tt>mil</tt><td>25.4e-6</tr>
    <tr><td><tt>m</tt><td>1e-3</tr>
    <tr><td><tt>u</tt><td>1e-6</tr>
    <tr><td><tt>n</tt><td>1e-9</tr>
    <tr><td><tt>p</tt><td>1e-12</tr>
    <tr><td><tt>f</tt><td>1e-15</tr>
    </table>
    </blockquote>

    <p>
    Immediately following the number and multiplier is an optional
    units string.  The units string is composed of the separation
    character '<tt>#</tt>', unit specification abbreviations as listed
    with the <a href="settype"><b>settype</b></a> command, and digit
    exponents.  Giving the <b>settype</b> command without arguments
    will list the unit abbreviations known to <i>WRspice</i>.

    <p>
    The units string must start with a letter, or the separation
    character followed by a letter, or two separation characters
    followed by a letter.  The string consists of a sequence of
    abbreviations, each optionally followed by a digit exponent. 
    If the separation character appears within the string, the
    abbreviations that follow provide denominator units.  The
    separation character in this context is logically equivalent to
    '<tt>/</tt>'.

    <p>
    The initial separation character is almost always optional.  It is
    needed when there would be possible misinterpretation, for example
    <tt>1.0F</tt> is dimensionless 1e-15, whereas <tt>1.0#F</tt> is
    1.0 farads.  If the initial separation character is immediately
    followed by another separation character, then all dimensions that
    follow are denominator units.

    <p>
    Some Examples:
    <blockquote>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><td><tt>1.0#F#M2</tt></td> <td>1 farad per square meter</td></tr>
    <tr><td><tt>1.0##S</tt></td>   <td>1 Hz</td></tr>
    <tr><td><tt>1.2uA#S</tt></td>  <td>1.2 microamps per second</td></tr>
    <tr><td><tt>1.2uVS</tt></td>   <td>1.2 microvolt-seconds</td></tr>
    </table>
    </blockquote>

    <p>
    All multipliers and unit abbreviations are case-insensitive, but
    by convention we use lower case for the multiplier and upper case
    for the first letter of the unit abbreviation.

    <p>
    If the unit specifier contains an unrecognized character or
    abbreviation, it is ignored, and the number is dimensionless.

    <p>
    Internal representations of numbers carry along the unit
    specifier, which will appear in output, and will propagate through
    calculations.  Thus, for example, a number specified in volts,
    divided by a number specified in ohms, would yield a number whose
    specification is amps.

    <p>
    It is possible to use a different character as the separator.  If
    the variable <a href="units_catchar"><tt>units_catchar</tt></a> is
    set to a string consisting of a single punctuation character, then
    this character becomes the separation character.

    <a name="varexp"></a>
    <h2>Variable Expansion in Input</h2>

    <i>WRspice</i> provides a unique and very useful feature:  as the
    circuit description is being read, any <a href="spshell">shell</a>
    variable references found in the element lines or most dotcards
    are expanded.  The reader should be aware that just about any text
    within the circuit description can be specified through the shell
    substitution mechanism.

    <p>
    Shell variables are tokens which begin with "<tt>$</tt>", that
    have been previously defined within <i>WRspice</i>.  They most
    often appear for numeric values in the deck, and the actual value
    replaces the "<tt>$</tt>" token.  These variables are evaluated as
    the circuit is read in, or with the <a
    href="reset"><b>reset</b></a> command once the circuit is loaded. 
    The variables must be known to the shell before the circuit is
    parsed, so if they are defined in the input file, the definition
    must occur in <a href=".exec"><tt>.exec</tt></a> blocks or <a
    href=".options"><tt>.options</tt></a> lines, which are evaluated
    before the circuit is parsed, and not <tt>.control</tt> blocks,
    which are evaluated after the circuit is parsed.  If the
    '<tt>$</tt>' is preceded with a backslash ('\'), the shell
    substitution is suppressed, but the construct forms a comment
    delimiter so that the remainder of the line is ignored.

    <p>
    Another type of expansion, single-quote expansion, is also
    performed as input is read.  This is most often used in <a
    href=".param"><tt>.param</tt></a> lines, and is another means by
    which the circuit can be configured before simulating through
    prior <i>WRspice</i> operations.  Any text enclosed in single
    quotes (') will be evaluated as an <a
    href="expressions">expression</a> as the file is read (before
    shell substitution) and the string will be replaced by the result. 
    Since evaluation is performed before shell substitution, the
    expression can not contain shell variables or other '<tt>$</tt>'
    references, but it can contain vectors (which must be defined
    before the circuit is read).

!! not in manual
    <p>
    The circuit <a href="elements">elements description</a> contains full
    information about the various devices available.

    <p>
    The table below lists the "dotcards" accepted by <i>WRspice</i>.

    <blockquote>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><th><a href="titleinc">Title, Comments, Job Separation and
       Inclusions</a></th></tr>
     <tr><td align="left">&nbsp;<a href=".title"><tt>.title</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".end"><tt>.end</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".newjob"><tt>.newjob</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".include"><tt>.include</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".inc"><tt>.inc</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".spinclude"><tt>.spinclude</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".lib"><tt>.lib</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".splib"><tt>.splib</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".mosmap"><tt>.mosmap</tt></a></td></tr>
    <tr><th align="left"><a href="initialize">Initialization</a></th></tr>
     <tr><td align="left">&nbsp;<a href=".global"><tt>.global</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".ic"><tt>.ic</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".nodeset"><tt>.nodeset</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".options"><tt>.options</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".table"><tt>.table</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".temp"><tt>.temp</tt></a></td></tr>
    <tr><th align="left"><a href="param">Parameters and
      Expressions</a></th></tr>
     <tr><td align="left">&nbsp;<a href=".param"><tt>.param</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".if"><tt>.if</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".elif"><tt>.elif</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".else"><tt>.else</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".endif"><tt>.endif</tt></a></td></tr>
    <tr><th align="left"><a href=".model">Device Models</a></th></tr>
     <tr><td align="left">&nbsp;<a href=".model"><tt>.model</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".defmod"><tt>.defmod</tt></a></td></tr>
    <tr><th align="left"><a href="subckt">Subcircuits</a></th></tr>
     <tr><td align="left">&nbsp;<a href=".subckt"><tt>.subckt</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".subckt"><tt>.macro</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".ends"><tt>.ends</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".ends"><tt>.eom</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".cache"><tt>.cache</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".endcache"><tt>.endcache</tt></a></td></tr>
    <tr><th align="left"><a href="analyses">Analysis</a></th></tr>
     <tr><td align="left">&nbsp;<a href=".ac"><tt>.ac</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".dc"><tt>.dc</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".disto"><tt>.disto</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".noise"><tt>.noise</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".op"><tt>.op</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".pz"><tt>.pz</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".sens"><tt>.sens</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".tf"><tt>.tf</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".tran"><tt>.tran</tt></a></td></tr>
    <tr><th align="left"><a href="output">Output Generation</a></th></tr>
     <tr><td align="left">&nbsp;<a href=".save"><tt>.save</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".print"><tt>.print</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".plot"><tt>.plot</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".four"><tt>.four</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".width"><tt>.width</tt></a></td></tr>
    <tr><th align="left"><a href="measure">Parameter Measurement</a></th></tr>
     <tr><td align="left">&nbsp;<a href=".measure"><tt>.measure</tt></a></td></tr>
    <tr><th align="left"><a href="execblock">Control Script
      Execution</a></th></tr>
     <tr><td align="left">&nbsp;<a href=".exec"><tt>.exec</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".control"><tt>.control</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".postrun"><tt>.postrun</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".endc"><tt>.endc</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".check"><tt>.check</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".checkall"><tt>.checkall</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".monte"><tt>.monte</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".noexec"><tt>.noexec</tt></a></td></tr>
    <tr><th align="left"><a href="verilog">Verilog Interface</a></th></tr>
     <tr><td align="left">&nbsp;<a href=".verilog"><tt>.verilog</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".endv"><tt>.endv</tt></a></td></tr>
     <tr><td align="left">&nbsp;<a href=".adc"><tt>.adc</tt></a></td></tr>
    </table>
    </blockquote>

!!SUBTOPICS
titleinc
initialize
param
subckt
output
measure
execblock
verilog

!!REDIRECT titlecard    titleinc#titlecard
!!REDIRECT comment      titleinc#comment
!!REDIRECT .title       titleinc#.title
!!REDIRECT .end         titleinc#.end
!!REDIRECT .newjob      titleinc#.newjob
!!REDIRECT .include     titleinc#.include
!!REDIRECT .inc         titleinc#.include
!!REDIRECT .spinclude   titleinc#.include
!!REDIRECT .lib         titleinc#.lib
!!REDIRECT .splib       titleinc#.lib
!!REDIRECT .mosmap      titleinc#.mosmap

!! format.tex 121611
!!KEYWORD
titleinc
!!TITLE
Title, Comments, Job Separation, and Inclusions
!!HTML 
    <font size=+3><b>Title Line</b></font>
    <p>

    <a name="titlecard"></a>
    The first line of the circuit description is a title line.  Any
    text (including a blank line) can appear in the title line.  The
    line is printed as part of generated output, but is otherwise
    unused by <i>WRspice</i>.

    <p>
    In the title line, the character sequences "<tt>\n</tt>" and
    "<tt>\t</tt>" are replaced with newline and tab characters,
    respectively.  Thus, it is possible to have a title string that
    prints multiple lines.  The title line always counts as a single
    line for internal line numbering, however.

    <p>
    <a name="comment"></a>
    <font size=+3><b>Comments</b></font>
    <p>

    <p>
    General Form:
    <blockquote>
        <tt>* arbitrary text</tt><br>
        <i>any_spice_text</i> <tt>\$</tt> <i>this text is ignored</i><br>
    </blockquote>

    <p>
    Examples:
    <blockquote><tt>
        * rf=1k      gain should be 100<br>
        * may the force be with my circuit<br>
        r1 1 0 100 \$ this is a comment<br>
    </tt></blockquote>

    <p>
    In the circuit description, an asterisk ('<tt>*</tt>') as the
    first non-white space character indicates that this line is a
    comment line.  Comments may be placed anywhere in the circuit
    description.  Also, there is provision for adding comments to
    the end of a line.

    <p>
    Comment lines which begin with '<tt>*@</tt>' and '<tt>*#</tt>' are
    special:  they are taken as executable statements as if included
    in <a href=".exec"><tt>.exec</tt></a> or <a
    href=".control"><tt>.control</tt></a> blocks, respectively.

    <p>
    Comments at the end of a line may be added as follows:
    <ul>
    <li>If the sequence "<tt>\$</tt>" appears in a line of
      SPICE input and is preceded by white space or is at the beginning
      of the line, these and the characters that follow on the line
      are taken as a comment.
    <li>If an isolated '<tt>$</tt>' character is found, i.e., with
      white space or start of line preceding and white space
      following, The '<tt>$</tt>' and text that follows on the line
      will be taken as a comment.
    <li>If an isolated '<tt>;</tt>' character is found, i.e., with
      white space or start of line preceding and white space
      following, The '<tt>;</tt>' and text that follows on the line
      will be taken as a comment.
    </ul>

    <p>
    In addition, for compatibility with other simulators, the <a
    href="dollarcmt"><tt>dollarcmt</tt></a> variable can be set.  When
    set, any '<tt>$</tt>' or '<tt>;</tt>' character preceded by start
    of line, white space, or a comma, will be taken as the start of a
    comment.

    <p>
    In <tt>.exec</tt> and <tt>.control</tt> blocks, comments are
    indicated for lines with the first non-whitespace character being
    '<tt>#</tt>', for compatibility with the shell.  In <a
    href="verilog">Verilog</a> blocks, The C++ commenting style
    ("<tt>//</tt>" for single line comments and "<tt>/* ...  */</tt>"
    for multi-line comments) is recognized.

    <p>
    <a name=".title"></a>
    <font size=+3><b><tt>.title</tt></b> <b>Line</b></font>
    <p>

    General form
    <blockquote>
        <tt>.title</tt> <i>any text</i>
    </blockquote>

    <p>
    Example:
    <blockquote>
        <tt>.title This is an alternate title</tt>
    </blockquote>

    <p>
    This simply replaces the title line text in output.

    <p>
    <a name=".end"></a>
    <font size=+3><b><tt>.end</tt></b> <b>Line</b></font>
    <p>

    <p>
    General Form:
    <blockquote><tt>
        .end
    </tt></blockquote>

    <p>
    This line is optional, but if it appears it should be the last
    line in the circuit description part of the input file.  The
    <tt>.end</tt> line is ignored by <i>WRspice</i>.

    <p>
    <a name=".newjob"></a>
    <font size=+3><b><tt>.newjob</tt></b> <b>Line</b></font>
    <p>

    <p>
    General Form:
    <blockquote><tt>
        .newjob
    </tt></blockquote>

    <p>
    The <tt>.newjob</tt> line is recognized in files directly read by
    <i>WRspice</i>, and <b>not</b> in files read through
    <tt>.include</tt>/<tt>.lib</tt> directives (see below).  When
    encountered during a <a href="source"><b>source</b></a> command,
    file parsing for the present circuit terminates, and lines that
    follow are taken as belonging to a new circuit deck.  The script
    execution and other operations that usually occur at the end of a
    <b>source</b> operation are done before parsing (for a new
    circuit) resumes.

    <p>
    Thus, one can place multiple circuit descriptions in a single
    file, separated by <tt>.newjob</tt> lines.  Sourcing the file is
    equivalent to sourcing each circuit independently and
    sequentially.

    <p>
    With no <tt>.newjob</tt> lines, when multiple files are listed on
    the command line in batch mode, or given to the <b>source</b>
    command, they are simply concatenated.  With <tt>.newjob</tt>
    lines, it is possible to give multiple circuits within a single or
    several files.  <i>WRspice</i> will source the circuits as if they
    were given individually, in sequence.  The circuits may or may not
    coincide with the physical files - lines in the files between
    <tt>.newjob</tt> lines are concatenated.  After a <b>source</b> of
    multiple circuits, the current circuit will be the last circuit
    read.

    <p>
    <a href="batchmode">Batch mode</a> is similar.  A single batch job
    can run multiple circuits.  Logical circuits are read, run, and
    output generated, in sequence.  The individual circuits can be
    concatenated into a single file, separated with <tt>.newjob</tt>
    lines, or a <tt>.newjob</tt> line can be added to the top of the
    individual circuit files.  In the later case, "<tt>wrspice -b</tt>
    <i>file1</i> <i>file2</i> ..." would run each circuit in sequence. 
    If the <tt>.newjob</tt> lines weren't present, <i>WRspice</i>
    would attempt to run a concatenation of the files.  In batch mode,
    since it is possible to run multiple circuits, the <a
    href=".cache"><tt>.cache</tt></a>/<a
    href=".endcache"><tt>.endcache</tt></a> feature can be used to
    advantage, without using a command script.

    <p>
    The line that follows a <tt>.newjob</tt> line is interpreted in
    exactly the same way as the first line of an input file, i.e., it
    is interpreted as a circuit title line except in a few cases.  If
    the first line of an input file is a <tt>.newjob</tt> line, it
    will be ignored, except that when reading multiple files, it
    indicates that a new circuit should start, rather than
    concatenation of the file to previous input.

    <p>
    Although circuits run in this manner are independent, note that
    variables set by scripts associated with a circuit, for example,
    would remain set for the later circuits.  Thus, there are
    potential side effects which must be considered.

    <p>
    The <tt>.cache</tt>/<tt>.endcache</tt> blocks work as they would
    in separate files.  Only one cache block can appear in a circuit,
    but of course a file containing multiple circuits can contain
    multiple cache blocks.

    <p>
    The <tt>.newjob</tt> lines separate the input into separate groups
    of lines, so one must take care to ensure that all related
    <tt>.control</tt>, <tt>.verilog</tt>, etc., blocks and lines will
    appear in the correct group.  There are no "common" lines.
 
    <p>
    <a name=".include"></a>
    <font size=+3><b><tt>.include</tt></b> <b>Line</b></font><br>
    <font size=+3><b><tt>.inc</tt></b> <b>Line</b></font>
    <p>

    General form:
    <blockquote>
        <tt>.include</tt> [<tt>h</tt>] <i>filename</i><br>
        <tt>.inc</tt> [<tt>h</tt>] <i>filename</i>
    </blockquote>

    <p>
    Examples:
    <blockquote><tt>
        .include models.def<br>
        .inc /projects/data.inc<br>
        .inc h /models/hspice_models.inc
    </tt></blockquote>

    <p>
    The keywords "<tt>.include</tt>" and "<tt>.inc</tt>" are equivalent.
    The <tt>.include</tt> line specifies that the named file is to be
    read and added to the input at the location of the
    <tt>.include</tt> line.  Included files may be nested arbitrarily.

    <p>
    If the <tt>h</tt> option (case insensitive) is given, the <a
    href="dollarcmt"<tt>dollarcmt</tt></a> variable is effectively
    set while the file, and any recursive sub-files, are being read. 
    Thus, the <a href="hspicesim">HSPICE</a> '<tt>$</tt>' comment syntax
    will be recognized in the included files.  The <tt>dollarcmt</tt>
    variable is reset to its prior value after the read.

    <p>
    This avoids having to explicitly set the <tt>dollarcmt</tt>
    variable when reading files intended for HSPICE.  It allows the
    normal <i>WRspice</i> shell substitution to work with the file
    containing the include line, which would not be the case if the
    <tt>dollarcmt</tt> variable was set explicitly.

    <p>
    While the included file is being read, the current directory is
    pushed to the directory containing the file.  Thus,
    <tt>.include</tt> (and <tt>.lib</tt>) lines in the file will have
    paths resolved relative to that directory, and not the original
    current directory.

    <p>
    In <i>WRspice</i>, the keyword <tt>.spinclude</tt> is accepted as
    a synonym for <tt>.include</tt>.  This is for compatibility with
    <i>Xic</i>, which will replace <tt>.include</tt> lines with the
    file contents, but will pass <tt>.spinclude</tt> lines to SPICE,
    after converting "<tt>.spinclude</tt>" to "<tt>.include</tt>".

    <p>
    These lines are shell expanded when encountered, before the
    indicated file is accessed.  This allows the paths to include
    shell variables, which can be set interactively.  Normal shell
    expansion, which applies to all other lines, occurs after all
    includes are read, parameter expansion, etc., much later in the
    sourcing process.  Note that shell variables can't be used in
    files included with the '<tt>h</tt>' option, or when the
    <tt>dollarcmt</tt> variable is set, as the '<tt>$</tt>' will be
    taken as the start of a comment.

    <p>
    <a name=".lib"></a>
    <font size=+3><b><tt>.lib</tt></b> <b>Line</b></font>
    <p>

    General form:
    <blockquote>
        <tt>.lib</tt> [<tt>h</tt>] <i>path_to_file</i> <i>name</i>
    </blockquote>

    <p>
    Examples:
    <blockquote><tt>
        .lib /usr/local/parts/moslib  mos24<br>
        .lib h /usr/cad/hspice_models mymod
    </tt></blockquote>

    <p>
    This will look in <i>path_to_file</i> for lines enclosed as follows.
    <blockquote>
        <tt>.lib</tt> <i>name</i><br>
        ... lines of SPICE text<br>
        <tt>.endl</tt>
    </blockquote>
    The lines inside the block will be read into the input deck being
    parsed, similar to the <a href=".include"><tt>.include</tt></a>
    line.

    <p>
    If the <tt>h</tt> option (case insensitive) is given, the <a
    href="dollarcmt"<tt>dollarcmt</tt></a> variable is effectively set
    while the file, and any recursive sub-files, are being read. 
    Thus, the <a href="hspicesim">HSPICE</a> '<tt>$</tt>' comment syntax
    will be recognized in the text.  The <tt>dollarcmt</tt> variable
    is reset to its prior value after the read.

    <p>
    This avoids having to explicitly set the <tt>dollarcmt</tt>
    variable when reading files intended for HSPICE.  It allows the
    normal <i>WRspice</i> shell substitution to work with the file
    containing the <tt>.lib</tt> line, which would not be the case if
    the <tt>dollarcmt</tt> variable was set explicitly.

    <p>
    While the file is being read, the current directory is pushed to
    the directory containing the file.  Thus, <tt>.include</tt> and
    <tt>.lib</tt> lines in the file will have paths resolved relative
    to that directory, and not the original current directory.

    <p>
    These lines are shell expanded when encountered, before the
    indicated file is accessed.  This allows the paths or block names
    to include shell variables, which can be set interactively. 
    Normal shell expansion, which applies to all other lines, occurs
    after all includes are read, parameter expansion, etc., much later
    in the sourcing process.  Note that shell variables can't be used
    in files included with the '<tt>h</tt>' option, or when the
    <tt>dollarcmt</tt> variable is set, as the '<tt>$</tt>' will be
    taken as the start of a comment.

    <p>
    The library file can contain any number of <tt>.lib</tt> blocks. 
    The <tt>.lib</tt> block can itself contain <tt>.lib</tt>
    references.  The text can be any valid <i>WRspice</i> input.  The
    <i>name</i> is an arbitrary text token, which should be unique
    among the <tt>.lib</tt> blocks in a library file.

    Example:
    <blockquote>
        title line<br>
        <tt>.lib /usr/stevew/spice/stuff/mylibrary mosblock</tt><br>
        ... more lines
    </blockquote>

    In <tt>/usr/stevew/spice/stuff/mylibrary</tt>:
    <blockquote><tt>
        .lib mosblock<br>
        m0 4 9 12 PSUB p1pvt l=0.25u w=2.4u<br>
        .endl
    </tt></blockquote>

    is equivalent to:
    <blockquote><tt>
        title line<br>
        m0 4 9 12 PSUB p1pvt l=0.25u w=2.4u</tt><br>
        ... more lines
    </tt></blockquote>

    <p>
    In <i>WRspice</i>, the keyword <tt>.splib</tt> is accepted as a
    synonym for <tt>.lib</tt>.  This is for compatibility with
    <i>Xic</i>, which will replace <tt>.lib</tt> lines with the block
    of text from the library, but will pass <tt>.splib</tt> lines to
    SPICE, after converting "<tt>.splib</tt>" to "<tt>.lib</tt>".

    <p>
    <a name=".mosmap"></a>
    <font size=+3><b><tt>.mosmap</tt></b> <b>Line</b></font>
    <p>

    General form:
    <blockquote>
        <tt>.mosmap</tt> [<i>ext_level</i>] [<i>wrspice_level</i>]
    </blockquote>

    <p>
    Examples:
    <blockquote><tt>
        .mosmap 127 14<br>
        .mosmap
    </tt></blockquote>

    <p>
    This construct maps the level number found in MOS <a
    href=".model"><tt>.model</tt></a> lines to another number in
    <i>WRspice</i>.  Different SPICE simulators may provide similar
    internal MOS model support, although with different level numbers. 
    Although an attempt has been made in <i>WRspice</i> to be
    compatible with <a href="hspicesim">HSPICE</a> level numbers, there
    may be differences, and there is less commonality with other SPICE
    programs.  One can in principle simply copy the model files and
    edit the level numbers to those expected in <i>WRspice</i>, but
    this may be inconvenient.

    <p>
    Suppose that you have a set of model files provided by a foundry
    service, designed for another simulator.  These files provide
    parameters for the Berkeley BSIM-4.4 model, with level 99 (as an
    example).  In <i>WRspice</i>, the BSIM-4.4 model is assigned to
    level 14.  Rather than copying and editing the files, one can use
    to following construct in the <i>WRspice</i> input:

    <blockquote>
    <tt>.mosmap 99 14</tt><br>
    <tt>.include</tt> <i>path_to_model_file</i>
    </blockquote>

    <p>
    The level 99 as found in the model file will be interpreted as
    level 14 in <i>WRspice</i>.

    <p>
    This line must appear logically ahead of, i.e., read before, the
    corresponding <tt>.model</tt> lines.  Any number of
    <tt>.mosmap</tt> lines can be used in the input.  The mapping
    applies while the file is being read and is not persistent.

    <p>
    In the most common usage, <tt>.mosmap</tt> is followed by two
    integers, the first being the model level to map, and the second
    being a valid MOS level number in <i>WRspice</i>.  If only one
    number appears, any mapping associated with that number is removed
    for the remainder of the file read.  If no number appears, then
    all mappings are removed for the remainder of the read.  These
    latter cases are probably infrequently needed.

    <p>
    Note that the <a href="devmod"><b>devmod</b></a> command in
    <i>WRspice</i> can be used to change device model levels, which
    may be more convenient than using <tt>.mosmap</tt>, and applies to
    all device types.

!!SEEALSO
spinput

!!REDIRECT .global      initialize#.global
!!REDIRECT .ic          initialize#.ic
!!REDIRECT .nodeset     initialize#.nodeset
!!REDIRECT .options     initialize#.options
!!REDIRECT .table       initialize#.table
!!REDIRECT .temp        initialize#.temp

!! format.tex 060314
!!KEYWORD
initialize
!!TITLE
Initialization
!!HTML 
    <a name=".global"></a>
    <font size=+3><b><tt>.global</tt></b> <b>Line</b></font>
    <p>

    General form:
    <blockquote>
        <tt>.global</tt> <i>node1 node2</i> ...
    </blockquote>

    <p>
    The arguments are node names.  These declared node names remain
    unaltered when subcircuits are expanded, thus the indicated nodes
    become accessible throughout the circuit.

    <p>
    For example, the substrate node of all n-channel MOSFETS in the main
    circuit and subcircuits can be tied to a node listed in the
    <tt>.global</tt> line.  Then, substrate bias can be applied to all
    substrate nodes with a single source, conveniently located in the
    main circuit.

    <p>
    <a name=".ic"></a>
    <font size=+3><b><tt>.ic</tt></b> <b>Line</b></font>
    <p>

    General form:
    <blockquote>
        <tt>.ic</tt> <tt>v(</tt><i>nodname</i><tt>)=</tt><i>val</i> | <i>nodename</i>=</i>val</i> ...
    </blockquote>

    <p>
    Examples:
    <blockquote><tt>
        .ic v(11)=5 4=-5 v(2)=2.2
    </tt></blockquote>

    <p>
    This line is for setting transient initial node voltages.  Note
    that the "<tt>v( )</tt>" around the node name is optional.  It has
    two different interpretations, depending on whether the
    <tt>uic</tt> parameter is specified on the <a
    href=".tran"><tt>.tran</tt></a> line.  Also, one should not
    confuse this line with the <a
    href=".nodeset"><tt>.nodeset</tt></a> line.  The <tt>.nodeset</tt>
    line is only to help dc convergence, and does not affect final
    bias solution (except for multi-stable circuits).  The two
    interpretations of this line are as follows:

    <ol>
    <li>When the <tt>uic</tt> parameter is specified on the
        <tt>.tran</tt> line, then the node voltages specified on the
        <tt>.ic</tt> line are used to compute the capacitor, diode,
        BJT, JFET, and MOSFET initial conditions.  This is equivalent
        to specifying the <tt>ic=...</tt> parameter on each device
        line, but is much more convenient.  The <tt>ic=...</tt>
        parameter can still be specified and will take precedence over
        the <tt>.ic</tt> values.  Since no dc bias (initial transient)
        solution is computed before the transient analysis, one should
        take care to specify all dc source voltages on the
        <tt>.ic</tt> line if they are to be used to compute device
        initial conditions.

    <p>
    <li>When the <tt>uic</tt> parameter is not specified on the
        <tt>.tran</tt> line, the dc bias (initial transient) solution
        will be computed before the transient analysis.  In this case,
        the node voltages specified on the <tt>.ic</tt> line will be
        forced to the desired initial values during the bias solution. 
        During transient analysis, the constraint on these node
        voltages is removed.
    </ol>

    <p>
    <a name=".nodeset"></a>
    <font size=+3><b><tt>.nodeset</tt></b> <b>Line</b></font>
    <p>

    General form:
    <blockquote>
        <tt>.nodeset</tt> <tt>v(</tt><i>nodname</i><tt>)=</tt><i>val</i> | <i>nodename</i>=</i>val</i> ...
    </blockquote>

    <p>
    Examples:
    <blockquote><tt>
        .nodeset v(12)=4.5 4=2.23
    </tt></blockquote>

    <p>
    This line helps the program find the dc or initial transient
    solution by making a preliminary pass with the specified nodes
    held to the given voltages.  The restriction is then released and
    the iteration continues to the true solution.  A <tt>.nodeset</tt>
    line may be necessary for convergence of bistable or astable
    circuits.  In general, this line should not be necessary.  Note
    that the "<tt>v( )</tt>" around the node name is optional.

    <p>
    <a name=".options"></a>
    <font size=+3><b><tt>.options</tt></b> <b>Line</b></font>
    <p>
 
    General form:
    <blockquote>
        <tt>.options</tt> <i>opt1 opt2</i> ... (or <i>opt=optval</i> ...)
    </blockquote>
 
    <p>
    Examples:
    <blockquote><tt>
        .options reltol=.005 trtol=8
    </tt></blockquote>
 
    <p>
    Options which control the operation of the simulator can be
    entered in the <i>WRspice</i> input file following the
    <tt>.options</tt> keyword.  In <i>WRspice</i> there are a number
    of variables which control simulation, many familiar from
    traditional Berkeley SPICE.  Any variable can be set on the
    <tt>.options</tt> line, and this is similar to setting the
    variable from the shell with the <a href="set"><b>set</b></a>
    command, however the variables set from the <tt>.options</tt> line
    are active only when the circuit is the current circuit, and they
    can not be unset with the <a href="unset"><b>unset</b></a>
    command.

    <p>
    Multiple <tt>.options</tt> lines can appear in input.  The lines
    are shell-expanded and evaluated in top-to-bottom order, and
    left-to-right for each line.  The <tt>.options</tt> lines are
    expanded and evaluated after execution of the <a
    href=".exec"><tt>.exec</tt></a> lines.  The result of processing
    each option is immediately available, so that lines like
    <blockquote>
      <tt>.options aaa=1 bbb=$aaa</tt><br>
      <tt>.options random tmpval = $&(gauss(.2,1))</tt>
    </blockquote>
    will work.  In the second line, the variable <a
    href="random"><tt>random</tt></a> will be set when the <a
    href="gauss"><tt>gauss</tt></a> function is evaluated, so that it
    will return a random value, and not just the mean.

    <p>
    The variables set in the <tt>.options</tt> lines are set before
    variable expansion is performed on the rest of the circuit text,
    so that global shell variables may be set in the <tt>.options</tt>
    lines.

    <p>
    The options which control simulation can also be entered from the
    keyboard by using the <i>WRspice</i> <b>set</b> command, or
    equivalently from the graphical tools available from the
    <b>Tools</b> menu of the <a href="toolbar"><b>Tool
    Control</b></a> window, in particular the <b>Simulation
    Options</b> tool.

    <p>
    Before a simulation starts, variables set in the shell and
    variables set in <tt>.options</tt> lines are merged according to a
    rule as to how to resolve inconsistencies.  The details of the
    merging process are described in the section which lists the
    recognized <a href="options">circuit options</a>.  This section
    provides further information on the use of option variables in
    <i>WRspice</i>.

    <p>
    <a name=".table"></a>
    <font size=+3><b><tt>.table</tt></b> <b>Line</b></font>
    <p>

    General form:
    <blockquote>
        <tt>.table</tt> <i>table_name</i> [<tt>ac</tt>]
          <i>x</i><sub>0</sub> <i>v</i><sub>0</sub> <i>x</i><sub>1</sub>
          <i>v</i><sub>1</sub> ... <i>x</i><sub>N</sub> <i>v</i><sub>N</sub>
    </blockquote>

    <p>
    Example:
    <blockquote><tt>
        .table xgain 0 0 1 1 1 1.5 4 2<br>
        .table acvals ac 0 1.0 0, 1e3 .98 .03, ...<br>
        .table zz (0 table xgain 4 2)<br>
        .table tab1 0 1 .2 .5 .4 table txx .8 .5e-2
    </tt></blockquote>

    <p>
    The <tt>.table</tt> line defines a tabulation of data points which
    can be referenced from other lines in the SPICE file.  The data
    are listed in sequence with respect to the ordinate
    <i>x</i><sub>N</sub>.  The elements are separated by white space
    or commas, and may optionally be surrounded by parentheses. 
    Generally, the table construct consists of many lines, using the
    '+' or backslash line continuation mechanism.  When a table is
    referenced, the data value returned is interpolated from the
    values in the table.

    <p>
    The <i>x</i><sub>i</sub> in the <tt>.table</tt> line are values of
    the independent variable (i.e., the variable given as an argument
    to the referencing function).  The <i>v</i><sub>i</sub> entries
    can be numbers, or a reference to another table in the form
    <blockquote>
    <tt>table</tt> <i>subtab_name</i>
    </blockquote>
    in which case that table will be referenced to resolve the data
    point.

    <p>
    If the <tt>ac</tt> keyword is given, the data numbers
    <i>v</i><sub>i</sub> are expected to be complex values, which are
    expressed as two values; the real value followed by the imaginary
    value.  Any sub-tables referenced must also have the <tt>ac</tt>
    keyword given.  The <tt>ac</tt> tables provide data for
    frequency-domain analysis.  Without <tt>ac</tt>, all values are
    real, and the table is intended for use in dc or transient
    analysis.

    <p>
    A non-ac table is referenced through a <a href="tranfuncs">tran
    function</a>.  Tables with the <tt>ac</tt> keyword given are
    referenced through the <tt>ac</tt> keyword in <a
    href="depsource">dependent</a> and <a href="src">independent</a>
    sources.

    <p>
    Let <tt>x</tt> be the input variable associated with the device
    referencing a table.  The table is evaluated as follows:

    <blockquote>
    <dl>
    <dt><tt>x</tt> &#60 <i>x</i><sub>0</sub> :<dd>
      val = <i>v</i><sub>0</sub>(<i>x</i><sub>0</sub>)</dl>
    <dt><i>x</i><sub>0</sub> &#60= <tt>x</tt> &#60 <i>x</i><sub>1</sub> :<dd>
      val = <i>v</i><sub>0</sub>(<tt>x</tt>) (if <i>v</i><sub>0</sub> is a
      table)<br>
      val = interpolation of <i>v</i><sub>0</sub>(<i>x</i><sub>0</sub>),
     <i>v</i><sub>1</sub>(<i>x</i><sub>1</sub>) if <i>v</i><sub>0</sub> is
     a number<br></dl>
     ...<br></dl>

    <dt><tt>x</tt> > <i>x</i><sub>N</sub> :<dd>
      val = <i>v</i><sub>N</sub>(<tt>x</tt>) (if <i>v</i><sub>N</sub> is a
      table)<br>
      val = <i>v</i><sub>N</sub>  (if <i>v</i><sub>N</sub> is a number)<br>
      val = <i>v</i><sub>N-1</sub>(<i>x</i><sub>N</sub>) (if omitted)<br>
    </dl>
    </blockquote>

    <p>
    See the <a href="ex6">example</a> input file which illustrates the
    use of <tt>.table</tt> lines.

    <p>
    <a name=".temp"></a>
    <font size=+3><b><tt>.temp</tt></b> <b>Line</b></font>
    <p>

    General form:
    <blockquote>
        <tt>.temp</tt> <i>temperature</i> [<i>temperatures...</i>]
    </blockquote>

    <p>
    Example:
    <blockquote><tt>
        .temp 25<br>
        .temp 0 25 50 75 100
    </tt></blockquote>

    <p>
    In some versions of SPICE, this card provides a list of
    temperatures, and analysis will be performed at each temperature
    in the list.  The temperature values are Celsius.

    <p>
    In <i>WRspice</i>, the first temperature given will be used to
    construct a dummy <a href=".options"><tt>.options</tt></a> line
    in the form

    <blockquote>
    <tt>.options temp=</tt><i>value</i>
    </blockquote>

    This will appear before any other <tt>.options</tt> line, so the
    given temperature value will be overridden by a value provided by
    the user in a <tt>.options</tt> line.  The temperature can also be
    given with the <a href="temp"><tt>temp</tt></a> variable, set with
    the <a href="set"><b>set</b></a> command or otherwise.  Additional
    temperatures listed in the <tt>.temp</tt> line are ignored.

!!SEEALSO
spinput

!!REDIRECT squote       param#squote
!!REDIRECT .param       param#.param
!!REDIRECT .if          param#.if
!!REDIRECT .elif        param#.if
!!REDIRECT .else        param#.if
!!REDIRECT .endif       param#.if

!! format.tex 032817
!!KEYWORD
param
!!TITLE
Parameters and Expressions
!!HTML 
    <table border=0>
    <tr><td valign=top><b>jump to</b></td> <td>
    <a href="param#predef"><b>Pre-Defined Parameters</b></a><br><br>
    </td></tr></table>

    <a name="squote"></a>
    <font size=+3><b>Single-Quoted Expressions</b></font>

    <p>
    Text enclosed in single quotes (') will be evaluated as an <a
    href="expressions">expression</a> as the file is read and the
    string will be replaced by the result.  This will occur throughout
    the SPICE text, with the exception of <a
    href=".measure"><tt>.measure</tt></a> lines, where single-quotes
    are traditionally (i.e., in <a href="hspicesim">HSPICE</a>) used
    as expression delimiters. 

    <p>
    Single-quoted expressions outside of <a
    href=".subckt"><tt>.subckt</tt></a> blocks are expanded before
    variable substitution and subcircuit expansion.  In this case,
    since evaluation is performed before shell substitution, the
    expression can not contain shell variables or other `$'
    references.  Single-quoted expressions that appear within
    <tt>.subckt</tt> blocks are evaluated after variable substitution
    during subcircuit expansion.  Thus, these expressions can contain
    shell '$' constructs.

    <p>
    In general, single-quoted expressions can not contain vectors
    other than those defined in the <a href="constants">constants</a>
    plot and "<a href="temper"><tt>temper</tt></a>".  If a vector
    reference such as "<tt>v(1)</tt>" is found in a single-quoted
    expression being evaluated, the expression will be parameter
    expanded as much as possible, but left in the form of an
    expression.  Thus, the construct can appear only where an
    expression is expected by the circuit parser, such as for the
    definitions of resistance and capacitance for resistor and
    capacitor devices.

    <p>
    If the single-quoted expression appears to the left of an '='
    sign, as an assignment, no substitution is done.  In this case,
    the quotes are ignored.

    <p>
    <a name=".param"></a>
    <font size=+3><b><tt>.param</tt></b> <b>Line</b></font>
    <p>

    General form:
    <blockquote>
        <tt>.param</tt> <i>name = value</i> [<i>name = value</i>] ...<br>
        <tt>.param</tt> <i>func</i>(<i>arg1</i>, ...) = <i>expression</i>
    </blockquote>

    <p>
    Example:
    <blockquote>
        <tt>.param p1 = 1.23 p2 = '2.5*p1'</tt><br>
        <tt>.param myabs(a) = 'a &#60 0 ? -a : a'</tt>
    </blockquote>

    <p>
    This assigns the text <i>value</i> to the text token <i>name</i>. 
    The <i>name</i> must start with a letter or underscore, If the
    text string <i>name</i>, delimited by space or one of
    <tt>,)([]='"</tt> but not with '=' to the right is found in the
    text, it is replaced by its value.

    <p>
    In 4.1.12 and later, node names are not parameter expanded by
    default.  The boolean variable <a
    href="pexnodes"><tt><pexnodes</tt></a> if set will enable
    parameter expansion of node names, for backward compatibility with
    files that may have used this feature.  Also in 4.1.12, device and
    subcircuit instance names are not parameter expanded, nor or
    subcircuit and model names found in <tt>.subckt</tt> and
    <tt>.model</tt> lines.

    <p>
    The '%' concatenation character is recognized.  The concatenation
    character is used to separate the token from the other text:  for
    example RES%K allows RES to be identified as a token, and if RES
    is "1" the substitution would yield "1K".  The <i>name</i> token
    must be surrounded by non-alphanumeric characters.

    <p>
    The concatenation character can be set to a different character
    with the <a href="var_catchar"><tt>var_catchar</tt></a> variable. 
    If this variable is set to a string consisting of a single
    punctuation character, then that character becomes the
    concatenation character.

    <p>
    Substitutions occur on a second pass, so the order of definition
    and reference is not important (except when used in <tt>.if</tt>
    or <tt>.elif</tt>, described below).  Substitutions are not
    performed in Verilog blocks, but are performed everywhere else. 

    <p>
    Values can contain parameter references, i.e., nesting is accepted.

    <p>
    It is also possible to define "user defined" functions using the
    second form above.  This is similar to the <a
    href="define"><b>define</b></a> shell function, but functions
    defined in this manner exist only transiently, and will override a
    function of the same name and argument count defined with the
    <b>define</b> command.

    <h4>Subcircuit Parameters</h4>

    <p>
    Parameters can also be defined in <a href=".subckt">subcircuit
    invocation</a> (<tt>.subckt</tt>) and <a href="subcall">call</a>
    lines.  When given in a <tt>.subckt</tt> line, the definition
    applies within that subcircuit, unless overridden.  When given in
    a call line, the definition applies when expanding lines for that
    instance only.

    <p>
    The default scoping of parameter substitution when there is more
    than one definition for a name is global.  This means that the
    highest level definition has precedence in a subcircuit hierarchy. 
    The scoping rules are identical those of <a
    href="hspicesim">HSPICE</a>.

    <p>
    The scoping rule set can be changed with the <a
    href="parhier"><tt>parhier</tt></a> option.  This can be set in a
    <a href=".options"><tt>.options</tt></a> line to one of two
    literal keywords:  "<tt>global</tt>" or "<tt>local</tt>".  The
    global setting is the default.  When "<tt>local</tt>" is
    specified, the precedence order is bottom-up, with the lowest
    level definition having precedence.

    <p>
    A parameter defined in a subcircuit instantiation line will
    override a definition given in a <tt>.param</tt> line in the
    subcircuit body, which in turn will override a parameter
    definition provided in the <tt>.subckt</tt> line.  This
    sub-precedence is not affected by the <tt>parhier</tt> setting.

    <p>
    The scoping for function definitions follows that of normal
    parameters, taking into account the <tt>parhier</tt> setting.

    <p>
    In general, these function definitions disappear from memory after
    parameter expansion has been performed, however is some cases
    "promoted macros" will be created and saved with the current
    circuit.  This occurs when a single-quoted expression references a
    circuit variable, and also calls a function defined with the
    parameters.  The function cannot be evaluated and is retained for
    later evaluation (during analysis).  For this to succeed, the
    referenced macros must be available as well, so these are
    "promoted" to a persistent database within the circuit data
    structure.  It is not possible to undefine these functions, excapt
    by destroying or changing the current circuit.  In the listing of
    functions provided by the <b>define</b> command without arguments,
    functions from the current circuit are listed with an asterisk in
    the first column.

    <p>
    References to parameters outside of any <tt>.subckt</tt>
    definition are evaluated after variable expansion.  References
    within <tt>.subckt</tt> definitions are evaluated after variable
    substitution, during subcircuit expansion.

    <p>
    The <i>value</i> must be a single token, or be enclosed by single
    or double quotes.  If double quotes are used, they are stripped
    when the substitution is applied.  Single quotes are retained in
    the substitution, as single quotes have significance in <a
    href="squote">delimiting an expression</a>.  Parameter
    substitution is performed whether or not the substitution variable
    in part of a single or double quoted string.

    <p>
    Parameter expansion is applied to all lines of input, with an
    attempt made to be smart about what tokens are expanded and which
    are not.  For example:
    <blockquote><tt>
    .subckt tline 1 2 3 4<br>
    T1 1 2 3 4 l=l c=c len=len<br>
    .ends tline</tt><br><br>
    This can be called as<br>
    <tt>xt1 1 0 2 0 l=1.5nh c=12ff len=1e-6</tt><br>
    Which expands to<br>
    <tt>T1.xt1 1 0 2 0 l=1.5nh c=12ff len=1e-6</tt>
    </blockquote>

    <p>
    This illustrates that in <i>param</i>=<i>value</i> constructs, the
    <i>value</i> is parameter expanded, not the <i>param</i>.  Thus,
    a device parameter name keyword will not be expanded by a user-given
    parameter of the same name.

    <p>
    Parameters can be accessed as <a href="plotvec">vectors</a>
    through the syntax "<tt>@</tt><i>paramname</i>".  The value of the
    vector is the numerical value of the parameter-expanded
    <i>value</i> string.  These vectors are read-only, i.e.,
    parameters can not be set through vectors.

    <a name="predef"></a>
    <h4>Pre-Defined Parameters</h4>

    The following parameter definitions are always automatically
    defined, as if specified on a <tt>.param</tt> line.  However, they
    are read-only, and attempts to redefine them will silently fail.

    <dl>
    <dt><tt>WRSPICE_PROGRAM</tt><dd>
    The value of this parameter is set to 1.  This enables users to
    include <i>WRspice</i>-specific input in SPICE files, which will
    be ignored by other simulators (and vice-versa).  The following
    lines will accomplish this:

    <blockquote>
    <tt>.param WRSPICE_PROGRAM=0</tt><br>
    <tt>.if WRSPICE_PROGRAM=1</tt><br>
    (<i>input lines specific for WRspice</i>)<br>
    <tt>.else</tt><br>
    (<i>input lines specific to another simulator</i>)<br>
    <tt>.endif</tt>
    </blockquote>

    The first (<tt>.param</tt>) line would be silently ignored in
    <i>WRspice</i>, so that the "(<i>input lines specific for
    WRspice</i>)" will be read.  In another simulator, the parameter
    definition will set <tt>WRSPICE_PROGRAM</tt> to zero, so that the
    "(<i>input lines specific to another simulator</i>)" would be read
    instead.
    </dl>

    <dl>
    <dt><tt>WRSPICE_RELEASE</tt><dd>
    The parameter <tt>WRSPICE_RELEASE</tt> is predefined with the
    release code number.  The release code number is a five digit
    integer <i>xyzz</i>0, corresponding to release <i>x.y.z</i>.  The
    <i>x</i> and <i>y</i> fields are one digit, <i>z</i> is two
    digits, 0 padded.  The trailing 0 is a historical anachronism. 
    For example, release 3.2.15 has release code number 32150.  This
    parameter is read-only, and attempts to change its value in a
    <tt>.param</tt> line or otherwise are silently ignored.
    </dl>

    <p>
    <a name=".if"></a>
    <font size=+3><b><tt>.if</tt></b>, <b><tt>.elif</tt></b>,
      <b><tt>.else</tt></b>, <b><tt>.endif</tt></b> <b>Lines</b></font>
    <p>

    General form:
    <blockquote>
    <tt>.if</tt> <i>expression</i> [ = <i>expression</i> ]<br>
    ...<br>
    <tt>.elif</tt> <i>expression</i> [ = <i>expression</i> ]<br>
    ...<br>
    <tt>.else</tt><br>
    ...<br>
    <tt>.endif</tt>
    </blockquote>
 
    <p>
    Example:
    <blockquote>
    <tt>SPICE deck title line</tt><br>
    ...<br>
    <tt>.param use_new_mod = 8</tt><br>
    ...<br>
    <tt>.if use_new_mod=8</tt><br>
    <tt>.model m1 nmos(level=8 ...</tt><br>
    <tt>.elif use_new_mod=9</tt><br>
    <tt>.model m1 nmos(level=9 ...</tt><br>
    <tt>.elif use_new_mod</tt><br>
    <tt>.model m1 nmos(level=10 ...</tt><br>
    <tt>.else</tt><br>
    <tt>.model m1 nmos(level=3 ...</tt><br>
    <tt>.endif</tt><br>
    </blockquote>
    
    <p>
    For compatibility with other simulators, the keyword
    "<tt>.elseif</tt>" is accepted as an alias for "<tt>.elif</tt>".

    <p>
    The <i>WRspice</i> input file syntax supports conditional blocks,
    through use of these directives.  The <i>expression</i> can
    involve constants, parameter names from a <tt>.param</tt> line
    included in the file, or vectors and shell variables defined
    <i>before</i> the file is read.  It does not understand variables
    implicitly set by inclusion in the <tt>.options</tt> line, or
    parameters set in <tt>.subckt</tt> lines or references.  The scope
    for these constructs is always global, meaning that they apply to
    lines of text in the file without regard to <tt>.subckt</tt> block
    boundaries.

    <p>
    If the single <i>expression</i> is nonzero, or the two expressions
    yield the same result, the lines following <tt>.if</tt> up to the
    matching <tt>.elif</tt>, <tt>.else</tt> or <tt>.endif</tt> are
    read, and if an <tt>.else</tt> block follows, those lines to the
    matching <tt>.endif</tt> are discarded.  If the single
    <i>expression</i> if zero or the two expressions do not match, the
    lines following <tt>.if</tt> to the matching<tt>.elif</tt>,
    <tt>.else</tt> or <tt>.endif</tt> are discarded, and if a
    <tt>.else</tt> line follows, the lines following <tt>.else</tt> to
    <tt>.endif</tt> are retained.  These blocks can be nested.  The
    action is similar to the C preprocessor.

    <p>
    This filtering is performed early in the parsing of the file, so
    the <tt>.if</tt>, etc.  lines can enclose script lines, verilog
    blocks, etc., and not simply circuit lines.  The lines not in
    scope are never saved in memory.

    <p>
    The predefined read-only <tt>WRSPICE_RELEASE</tt> parameter can be
    used in conjunction with the <tt>.if</tt> conditionals to select
    <i>WRspice</i>-specific lines in input files.

    <p>
    For example:
    <blockquote>
    <tt>.param WRSPICE_RELEASE=0  $ ignored by WRspice</tt><br>
    <tt>.if WRSPICE_RELEASE</tt><br>
    (<i>WRspice-specific lines</i>)<br>
    <tt>.else</tt><br>
    (<i>lines for <a href="hspicesim">HSPICE</a> or whatever</i>)<br>
    <tt>.endif</tt>
    </blockquote>

!!SEEALSO
spinput

!!REDIRECT .subckt      subckt#.subckt
!!REDIRECT .macro       subckt#.subckt
!!REDIRECT .ends        subckt#.ends
!!REDIRECT subcall      subckt#subcall
!!REDIRECT .eom         subckt#.ends
!!REDIRECT .cache       subckt#.cache
!!REDIRECT .endcache    subckt#.cache

!! format.tex 110111
!!KEYWORD
subckt
!!TITLE
Subcircuits
!!HTML 
    <table border=0>
    <tr><td valign=top><b>jump to</b></td> <td>
    <a href="subckt#expand"><b>Subcircuit Expansion</b></a><br><br>
    </td></tr></table>

    <p>
    A subcircuit that consists of <i>WRspice</i> elements can be
    defined and referenced in a fashion similar to device models.  The
    subcircuit is defined in the input file by a grouping of element
    lines; the program then automatically inserts the group of
    elements wherever the subcircuit is referenced.  There is no limit
    on the size or complexity of subcircuits, and subcircuits may
    contain other subcircuits.
    <br clear=all>

    <p>
    <a name=".subckt"></a>
    <font size=+3><b><tt>.subckt</tt></b> <b>Line</b></font>
    <p>

    General form:
    <blockquote>
        <tt>.subckt</tt> <i>subnam n1</i> [<i>n2 n3</i>] ...
            [<i>param1=val1 param2=val2</i> ...]
    </blockquote>

    <p>
    Examples:
    <blockquote>
        <tt>.subckt opamp 1 2 3 4</tt><br>
        <tt>.subckt stage1 3 10 2 resis=2k cap=1nf</tt>
    </blockquote>

    <p>
    The keyword "<tt>.macro</tt>" is equivalent to "<tt>.subckt</tt>". 
    The "<tt>.subckt</tt>" keyword is actually a default, and this
    keyword can be reset through setting the <a
    href="substart"><tt>substart</tt></a> variable.  The <tt>.macro</tt>
    variable applies in any case.

    <p>
    A circuit definition begins with a <tt>.subckt</tt> line.  The
    <i>subnam</i> is the subcircuit name, and <i>n1</i>, <i>n2</i>,
    ...  are the external nodes, which cannot be zero.  The group of
    element lines which immediately follow the <tt>.subckt</tt> line
    define the subcircuit.  The last line in a subcircuit definition
    is the <tt>.ends</tt> line (see below).  Control lines may not
    appear within a subcircuit definition; however, subcircuit
    definitions may contain anything else, including other subcircuit
    definitions, device models, and subcircuit calls (see below). 
    Note that any device models or subcircuit definitions included as
    part of a subcircuit definition are strictly local (i.e., such
    models and definitions are not known outside the subcircuit
    definition).  Also, any element nodes not included on the
    <tt>.subckt</tt> line or in <a href=".global"><tt>.global</tt></a>
    lines are strictly local, with the exception of 0 (ground) which
    is always global.

    <p>
    The subcircuit declaration line can contain an optional list of
    <i>param</i>=<i>value</i> pairs.  The <i>params</i> are tokens
    which must start with a letter or underscore, which can appear in
    the subcircuit lines.  These are not shell variables, so there is
    no $ or other punctuation, but the '%' concatenation character is
    recognized.  The concatenation character is used to separate the
    token from the other text:  for example RES%K allows RES to be
    identified as a token, and if RES is "1" the substitution would
    yield "1K".  The <i>param</i> token must be surrounded by
    non-alphanumeric characters.

    <p>
    The concatenation character can be set to a different character
    with the <a href="var_catchar"><tt>var_catchar</tt></a> variable. 
    If this variable is set to a string consisting of a single
    punctuation character, then that character becomes the
    concatenation character.

    <p>
    <i>WRspice</i> can handle duplicate formal node args in
    <tt>.subckt</tt> lines.  It does so by assigning a new node to one
    of the duplicates, then inserting a voltage source between the two
    nodes, which is added to the subcircuit text.  This mainly solves
    a problem related to files generated by <i>Xic</i>.  If two or
    more subcircuit terminals are attached to the same wire net, the
    resulting <i>.subckt</i> line will have duplicate nodes.  In the
    limiting case where a subcircuit consists only of a wire with two
    connections, the subcircuit would in addition be empty.

    <p>
    For example, the definition
    <blockquote><tt>
        .subckt xxx 1 1<br>
        .ends
    </tt></blockquote>
    is converted to
    <blockquote><tt>
        .subckt xxx 1 _#0<br>
        v_xxx_0 1 _#0<br>
        .ends
    </tt></blockquote>
    during subcircuit expansion, which avoids an empty subcircuit and
    has the intended effect of instances shorting the two terminals
    together.

    <a name="expand"></a>
    <h2>Subcircuit Expansion</h2>

    When processing circuit input that contains subcircuits,
    <i>WRspice</i> will perform "subcircuit expansion" whereby <a
    href="subcall">subcircuit calls</a> are replaced recursively with
    the subcircuit body text, with the device and node names
    translated so as to make them unique in the overall circuit.  This
    "flat" representation, which can be seen with the <a
    href="listing"><b>listing e</b></a> command, is the form that is
    actually parsed to generate the internal circuit structure used in
    simulation.

    <p>
    Although this occurs "behind the scenes", if a user needs to
    reference nodes or devices within subcircuits, for example in a
    <b>print</b> or <b>plot</b> command after analysis, the user will
    need to know the details of the name mapping employed.  The same
    applies when the user is preparing SPICE input, if, for example,
    the user wishes to use the <a href=".save"><tt>.save</tt></a>
    keyword with a subcircuit node.  In this case, the SPICE deck will
    fail to work as intended unless the mapping algorithm assumed by
    the user is actually employed by the simulator.

    <p>
    <i>WRspice</i> releases prior to 3.2.15 used the SPICE3 algorithm
    for generating the new node and device names.  Subsequent releases
    have a new, simpler algorithm as the default, but support for the
    old algorithm is retained.  The field separation character, used
    when creating new names, has changed twice in <i>WRspice</i>
    evolution.  Thus, there is a potential compatibility issue with
    legacy <i>WRspice</i> input files that explicitly reference
    subcircuit nodes, and newer <i>WRspice</i> releases.

    <p>
    There are two variables which set the subcircuit mapping mode and
    concatenation character.

    <dl>
    <dt><a href="subc_catchar"><tt>subc_catchar</tt></a><dd>
    This can be set to a string consisting of a single punctuation
    character, which will be used as the field separation character in
    names generated in subcircuit expansion.  It should be a character
    that is not likely to confuse the expression parser.  This
    requirement is rather ambiguous, but basically means that math
    operators, comma, semicolon, and probably others should be
    avoided.

    <p>
    In release 3.2.15 and later the default is '<tt>.</tt>' (period),
    which is also used in <a href="hspicesim">HSPICE</a>, and provides
    nice-looking listings.

    <p>
    In releases 3.2.5 - 3.2.14, the default was '<tt>_</tt>'
    (underscore).

    <p>
    In release 3.2.4 and earlier, and in SPICE3, the concatenation
    character was '<tt>:</tt>' (colon).
    </dl>

    <dl>
    <dt><a href="subc_catmode"><tt>subc_catmode</tt></a><dd>
    This string variable can be set to one of the keywords
    "<tt>wrspice</tt>" or "<tt>spice3</tt>".  It sets the encoding
    mode for subcircuit node and device names.  In 3.2.15 and later,
    the "<tt>wrspice</tt>" mode is the default.  In earlier releases,
    only the "<tt>spice3</tt>" mode was available.
    </dl>

    <p>
    The format of the subcircuit node names depends on the algorithm,
    so SPICE input that explicitly references subcircuit node names
    implicitly assuming a certain mapping algorithm will require
    either changes to the node names, or specification of the matching
    algorithm and concatenation character.

    <p>
    These variables can be set from a <a
    href=".options"><tt>.options</tt></a> line in SPICE input, so that
    the easiest way to "fix" an old file is to add a <tt>.options</tt>
    line.

    <p>
    For example, suppose that you run an old deck, and get warnings
    like "<tt>no such vector 0:67</tt>".  From the descriptions below,
    one can recognize that 1) the SPICE3 mode is being used, which
    will always be true for old decks, and 2) the concatenation
    character is '<tt>:</tt>'.  Thus, adding the following line to the
    file will fix the problem.

    <blockquote>
    <tt>.options subc_catchar=: subc_catmode=spice3</tt>
    </blockquote>

    <p>
    When running from <i>Xic</i>, there should not be compatibility
    issues, as <i>Xic</i> will automatically recognize the
    capabilities of the connected <i>WRspice</i> and compensate
    accordingly - as long as the hypertext facility is used to define
    node names.  This is true when point-and-click is used to generate
    node names.  However, subcircuit node names that for some reason
    were entered by hand will need to be updated, or a
    <tt>.options</tt> line added as a spice-text label.

    <h5><tt>wrspice</tt> mode</h5>

    As an example, suppose we have a device line

    <blockquote>
      <tt>C126 2 4 50fF</tt>
    </blockquote>

    in a subcircuit which is instantiated as a subcircuit instance
    <tt>Xgate</tt>, which itself is instantiated at the top level in a
    subcircuit instance <tt>Xadder</tt>.  After applying the
    <tt>wrspice</tt> algorithm, this line becomes

    <blockquote>
      <tt>C126.Xgate.Xadder 2.Xgate.Xadder 4.Xgate.Xadder 50fF</tt>
    </blockquote>

    assuming the use of '<tt>.</tt>' as the concatenation character. 
    Note the straightforwardness of this approach:  one merely starts
    with the given name (device or node) and appends a concatenation
    character and subcircuit instance name, walking up the hierarchy. 
    The '<tt>x</tt>' or '<tt>X</tt>' characters of the instance names
    are retained.

    <p>
    In addition, if a device model is defined in a subcircuit, the model
    name is mapped as follows.  Suppose that the subcircuit instantiated
    as <tt>Xgate</tt> contained a <tt>.model</tt> line like

    <blockquote>
      <tt>.model foo nmos(...)</tt>
    </blockquote>

    <p>
    The model is only accessible in instances of this subcircuit (and any
    sub-subcircuits), with the name mapped to (for example)

    <blockquote>
      <tt>.model foo.Xgate.Xadder nmos(...)</tt>
    </blockquote>

    <p>
    Thus models use exactly the same naming convention.  Note that
    models are generated per-instance rather than per-subcircuit.  The
    reason is that if the subcircuit is parameterized, the model in
    each instance may be different, if different parameters are
    provided to the instances, and model text uses the parameters.

    <h5><tt>spice3</tt> mode</h5>

    The SPICE3 encoding is a bit more obscure.  Suppose that we have
     the same example hierarchy as above.  The line maps to

    <blockquote>
      <tt>C.adder.gate.126 adder.gate.2 adder.gate.4 50fF</tt>
    </blockquote>

    <p>
    Again, this assumes '<tt>.</tt>' as the concatenation character,
    which is a bad choice for this mapping mode as we shall see.  The
    <tt>spice3</tt> mode was historically used with '<tt>:</tt>' or
    '<tt>_</tt>' as the concatenation character.

    <p>
    For device names, we start with the first character, add a
    concatenation character, then the top instance name with the
    '<tt>X</tt>' stripped and continue down the hierarchy.  Finally,
    we add a concatenation character and the remainder of the original
    device name.

    <p>
    For nodes, we start with the top-level instance name with the
    '<tt>X</tt>' stripped, walk down the hierarchy adding concatenation
    characters and sub-instance names (also with the '<tt>X</tt>'
    stripped), and finally append a concatenation character and the
    original node name.

    <p>
    For models defined in subcircuits, in the example above, the mapping
    is

    <blockquote>
      <tt>.model adder.gate.foo nmos(...)</tt>
    </blockquote>

    <p>
    What if instead of <tt>Xgate</tt> and <tt>Xadder</tt>, the
    instance names were <tt>X0</tt> and <tt>X1</tt>?  The expansion
    becomes

    <blockquote>
      <tt>C.1.0.126 1.0.2 1.0.4 50fF</tt>
    </blockquote>

    <p>
    This is very cumbersome to keep straight.  Worse, if the hierarchy
    is only one-deep, we could get node names like "<tt>0.1</tt>",
    "<tt>1.2</tt>", etc.  which are in some cases impossible for the
    parser to distinguish from a floating point value.  Using a
    different concatenation character solves this problem, but the
    names are still rather opaque.

    <p>
    <a name=".ends"></a>
    <font size=+3><b><tt>.ends</tt></b> <b>Line</b></font>
    <p>

    General form:
    <blockquote>
        <tt>.ends</tt> [<i>subnam</i>]
    </blockquote>

    <p>
    Examples:
    <blockquote>
        <tt>.ends opamp</tt>
    </blockquote>

    <p>
    The keyword "<tt>.eom</tt>" is equivalent to "<tt>.ends</tt>". 
    The "<tt>.ends</tt>" is actually a default and the keyword can be
    changed by setting the <a href="subend"><tt>subend</tt></a> variable. 
    The <tt>.eom</tt> keyword applies in any case.

    <p>
    This line must be the last one for any subcircuit definition.  The
    subcircuit name, if included, indicates which subcircuit
    definition is being terminated; if omitted, all subcircuits being
    defined are terminated.  The name is needed only when nested
    subcircuit definitions are being made.

    <p>
    <a name="subcall"></a>
    <font size=+3><b>Subcircuit Calls</b></font>
    <p>

    General form:
    <blockquote>
        <tt>x</tt><i>name</i> <i>n1</i> [<i>n2 n3</i> ...] <i>subnam</i>
            [<i>param1=val1 param2=val2</i> ...]
    </blockquote>

    <p>
    Example:
    <blockquote>
        <tt>x1 2 4 17 3 1 multi</tt>
    </blockquote>

    <p>
    Subcircuits are used in <i>WRspice</i> by specifying
    pseudo-elements beginning with the letter `<tt>x</tt>' or
    '<tt>X</tt>', followed by the circuit nodes to be used in
    expanding the subcircuit.

    <p>
    When a circuit is parsed, all devices and local nodes in
    subcircuits are renamed as
    <i>devicetype</i>[sep]<i>subcktname</i>[sep]<i>devicename</i>,
    where "[sep]" is a separation character.  In SPICE3 and
    <i>WRspice</i> prior to release 3.2.4, this was the colon (':')
    character.  However, this choice can lead to conflicts and parser
    trouble due to the use of the colon in the ternary conditional
    operator <i>a</i><tt>?</tt><i>b</i><tt>:</tt><i>c</i>.  In release
    3.2.4, the separation character was changed to the underscore
    ('<tt>_</tt>').

    <p>
    The character employed can be set from the shell with the shell
    variable <a href="subc_catchar"><tt>subc_catchar</tt></a>.  If
    this variable is set to a string consisting of a single
    punctuation character, then this character becomes the "[sep]"
    character.

    <p>
    Nested subcircuit instances will have multiple "[sep]"-separated
    qualifiers.
 
    <p>
    The names and default values of the <i>params</i> are specified in
    the <tt>.subckt</tt> line.  During subcircuit expansion, the
    <i>param</i> tokens are replaced by their corresponding
    <i>value</i> tokens in the text.  If a list of <i>params</i> is
    given in the subcircuit instantiation line, those values will
    supersede the defaults in that subcircuit instance, and parameters
    set in <tt>.param</tt> lines.

    <p>
    Example
    <blockquote><tt>
        .subckt resistor 1 2 resis=1k<br>
        r1 1 2 resis<br>
        .ends<br>
        <br>
        x1 3 4 resistor resis = 500<br>
        x2 5 6 resistor<br>
        x3 7 8 resistor resis=2k<br>
    </tt></blockquote>

    <p>
    <a name=".cache"></a>
    <font size=+3><b>Subcircuit/Model Cache</b></font>

    <p>
    General form:
    <blockquote>
        <tt>.cache</tt> <i>name</i><br>
        <i>Lines of SPICE input...</i><br>
        <tt>.endcache</tt>
    </blockquote>

    <p>
    Example:
    <blockquote>
        <tt>.cache block1</tt><br>
        <tt>.include /users/models/some_big_library</tt><br>
        <tt>.endcache</tt>
    </blockquote>

    <p>
    The "models" provided with foundry design kits (for example) have
    become quite complex, to the point where loading these files into
    <i>WRspice</i> can take appreciable time.  These files often
    encapsulate device calls into subcircuits, and use large numbers of
    parameter definitions that must be processed into internal tables.

    <p>
    This overhead is annoying when simulating circuits, but can become
    a real problem when doing repetitive simulations such as for Monte
    Carlo analysis or when under control of a looping script.  The
    caching feature enables one to load these definitions once only,
    on the first pass.  Subsequent runs will reuse the internal
    representations, which can avoid most of the overhead.

    <p>
    The "<tt>.cache</tt>" and "<tt>.endcache</tt>" SPICE file keywords
    are used to identify lines of an input deck which will be cached. 
    This syntax is non-standard and available only in <i>WRspice</i>.

    <p>
    The <i>name</i> is any short alpha-numeric name token, used to
    identify the cache block created.  The cached representation of
    the enclosed lines is saved in <i>WRspice</i> memory under this
    name.

    <p>
    Presently, there can be only one <tt>.cache</tt> block per circuit
    deck.  The first time the <i>name</i> is seen, the enclosed lines
    are processed normally but internal representations are saved. 
    Subsequently, the enclosed lines are skipped.  The skipping occurs
    very early in the sourcing operation, before <tt>.include</tt> and
    similar lines are read.  So, for the example, the access to
    <tt>some_big_library</tt> is skipped entirely in subsequent runs.

    <p>
    If a different SPICE input file is sourced, and this has a
    <tt>.cache</tt> block with the same <i>name</i> as the first, the
    cached parameters from the first file will be used in the second
    file.  The internal representation of the cache block has no
    attachment to any particular input file.

    <p>
    The <i>Lines of SPICE input...</i> which can appear between
    <tt>.cache</tt> and <tt>.endcache</tt> can be, after
    <tt>.include</tt>/<tt>.lib</tt> expansion:

    <ul>
    <li>Subcircuit definitions, which must include all lines of the
        definition including the <tt>.subckt</tt> or <tt>.macro</tt>
        line and corresponding <tt>.ends</tt> or <tt>.eom</tt> line.
    <li>Model definitions, starting with <tt>.model</tt>.
    <li>Parameter definitions, starting with <tt>.param</tt>.
    <li>Comment lines.
    </ul>

    <p>
    The block can contain any of the <tt>.include</tt>/<tt>.lib</tt>
    family of lines, but after these lines are expanded, the resulting
    text should contain only the forms listed above.  Anything else that
    appears in the cache block will likely cause an error, as it will
    be "missing".

    <p>
    The parameters from <tt>.param</tt> lines saved in the cache will
    override parameters of the same name defined elsewhere in the
    circuit file.

    <p>
    The subcircuit/model cache can be manipulated with the <i>WRspice</i>
    <a href="cache"><b>cache</b></a> command.

!!SEEALSO
spinput

!!REDIRECT .save        output#.save
!!REDIRECT .probe       output#.save
!!REDIRECT .print       output#.print
!!REDIRECT .plot        output#.plot
!!REDIRECT .four        output#.four
!!REDIRECT .width       output#.width

!! format.tex 022111
!!KEYWORD
output
!!TITLE
Output Generation
!!HTML 
    In these lines, outputs can be specified using the SPICE2
    notation.  The form is
    <tt>v</tt><i>xx</i>(<i>node1</i>[<tt>,</tt><i>node2</i>]), or
    <tt>i</tt><i>xx</i>(<i>branch_device</i>).  The <i>xx</i> can be
    left out, indicating the basic voltage or current, or be one of
    the following.

    <blockquote>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><td><tt>m</tt></td> <td>Magnitude</td></tr>
    <tr><td><tt>p</tt></td> <td>Phase</td></tr>
    <tr><td><tt>r</tt></td> <td>Real part</td></tr>
    <tr><td><tt>i</tt></td> <td>Imaginary part</td></tr>
    <tr><td><tt>db</tt></td> <td>Decibel value (20*log10)</td></tr>
    </table>
    </blockquote>

    <p>
    These forms are not usually needed for other than ac analysis. 
    The (<i>node1</i>, <i>node2</i>) notation indicates a voltage
    difference between nodes <i>node1</i> and <i>node2</i>.  If
    <i>node2</i> and the associated comma are left out, the ground
    node is assumed.  Output variables for noise, distortion, and some
    other analyses have a different general form.  See the description
    of the analysis for the output variable names.

    <p>
    <a name=".save"></a>
    <font size=+3><b><tt>.save</tt></b> <b>Line</b></font>
    <p>

    General form:
    <blockquote>
        <tt>.save</tt> [<tt>output</tt>] <i>vector vector</i> ...
    </blockquote>

    <p>
    Example:
    <blockquote><tt>
        .save i(vin) v(3)<br>
        .save @m1[id] vm(3,2)
    </tt></blockquote>

    <p>
    When a rawfile is produced, the vectors listed in the
    <tt>.save</tt> line are recorded in the rawfile.  The standard
    vector names are accepted; for the form <tt>v</tt>(<i>a</i>,
    <i>b</i>), the vectors <tt>v</tt>(<i>a</i>) and
    <tt>v</tt>(<i>b</i>) are saved (<i>not</i> the difference vector). 
    The voltage vector(s) are saved for each of the forms
    <tt>vm</tt>, <tt>vp</tt>, <tt>vr</tt>, <tt>vi</tt>, and
    <tt>vdb</tt>.  Similarly, the branch current is saved on mention
    of any of the corresponding <tt>i</tt> forms.  A token without
    parenthesis is interpreted as a node name, e.g., "1" implies
    <tt>v(1)</tt> is saved.

    <p>
    If no <tt>.save</tt> line is given or no entries are found, then
    all vectors produced by the analysis are saved.  If <tt>.save</tt>
    lines are given, only those vectors specified are saved.  The
    keyword <tt>output</tt> specifies that the vector names found
    in all <tt>.print</tt>, <tt>.plot</tt>, and <tt>.four</tt> lines
    are to be saved, in addition to any vectors listed on the
    <tt>.save</tt> lines.

    <p>
    In <i>WRspice</i> release 3.2.11 and later, the keyword
    <tt>.probe</tt> is a synonym for <tt>.save</tt>.  This is for
    rough compatibility with other simulators.

    <p>
    There is an analogous <a href="save"><b>save</b></a> command
    available within <i>WRspice</i>.

    <p>
    <a name=".print"></a>
    <font size=+3><b><tt>.print</tt></b> <b>Line</b></font>
    <p>

    General form:
    <blockquote>
        <tt>.print</tt> <i>prtype</i> <i>ov1</i> [<i>ov2 ... ov8</i>]
    </blockquote>

    <p>
    Examples:
    <blockquote><tt>
        .print tran v(4) i(vin)<br>
        .print dc v(2) i(vsrc) v(23,17)<br>
        .print ac vm(4,2) vr(7) vp(8,3)
    </tt></blockquote>

    <p>
    The <tt>.print</tt> line defines the contents of a tabular listing
    of one to eight output variables.  The parameter <i>prtype</i> is
    the type of the analysis (dc, ac, tran, noise, etc.) for which the
    specified outputs are desired.  Variables can take the forms
    tabulated above.  The actual format recognized is that of the <a
    href="print"><b>print</b></a> command, which is far more general. 
    There is no limit on the number of <tt>.print</tt> lines for each
    type of analysis.

    <p>
    <a name=".plot"></a>
    <font size=+3><b><tt>.plot</tt></b> <b>Line</b></font>
    <p>

    General form:
    <blockquote>
        <tt>.plot</tt> <i>pltype</i> <i>ov1</i> [<i>ov2</i> ... ]
            [(<i>min,max</i>)]
    </blockquote>

    <p>
    Examples:
    <blockquote><tt>
        .plot dc v(4) v(5) v(1)<br>
        .plot tran v(17,5) (2,5) i(vin) v(17) (1,9)<br>
        .plot ac vm(5) vm(31,24) vdb(5) vp(5)<br>
        .plot disto hd2 hd3(R) sim2<br>
        .plot tran v(5,3) v(4) (0,5) v(7) (0,10)<br>
    </tt></blockquote>

    <p>
    The <tt>.plot</tt> line defines the contents of one plot from one
    or more output variables.  In SPICE2, the number of variables was
    limited to eight, but <i>WRspice</i> has no preset limit.  In
    SPICE2, each variable could be followed by a comma-separated pair
    of numbers in parentheses which indicated the plotting range. 
    <i>WRspice</i> supports this construct only as the last argument,
    and it applies to all variables.  The parameter <i>pltype</i> is
    the type of analysis (ac, dc, tran, etc.) for which the specified
    outputs are desired.  The syntax for the <i>ov</i>N is identical
    to that for the <a href=".print"><tt>.print</tt></a> line and for
    the <a href="plot"><b>plot</b></a> command in the interactive
    mode.

    <p>
    This line generates <a href="asciiplot">ASCII plots</a> in <a
    href="batchmode">batch mode</a>, for compatibility with SPICE2. 
    The overlap of two or more traces on any plot is indicated by the
    letter X.

    <p>
    When more than one output variable appears on the same plot, the
    first variable specified is printed as well as plotted.  If a
    printout of all variables is desired, then a companion
    <tt>.print</tt> line should be included.

    <p>
    There is no limit on the number of <tt>.plot</tt> lines specified
    for each type of analysis.

    <p>
    <a name=".four"></a>
    <font size=+3><b><tt>.four</tt></b> <b>Line</b></font>
    <p>

    General form:
    <blockquote>
        <tt>.four</tt> <i>freq ov1</i> [<i>ov2 ov3</i> ...]
    </blockquote>

    <p>
    Example:
    <blockquote>
        <tt>.four 100k v(5)</tt>
    </blockquote>

    <p>
    The <tt>.four</tt> line controls whether <i>WRspice</i> performs a
    Fourier analysis as a part of the transient analysis.  The
    parameter <i>freq</i> is the fundamental frequency, and
    <i>ov1,...</i>, are the output variables for which the analysis is
    desired.  The Fourier analysis is performed over the interval
    [<tt>tstop-period, tstop</tt>], where <tt>tstop</tt> is the final
    time specified in transient analysis, and <tt>period</tt> is one
    period of the fundamental frequency.  The dc component and the
    first nine harmonics are determined.  For maximum accuracy,
    <tt>tmax</tt> (see the <a href=".tran"><tt>.tran</tt></a> line)
    should be set to <i>period</i>/100 (or less for very high Q
    circuits).

    <p>
    <a name=".width"></a>
    <font size=+3><b><tt>.width</tt></b> <b>Line</b></font>
    <p>

    General form:
    <blockquote>
        <tt>.width out=</tt><i>wid</i>
    </blockquote>

    <p>
    This line is ignored, except in batch mode.  The <i>wid</i> is the
    number of columns to be used for printing output.  Internally,
    this effectively sets the <a href="width"><tt>width</tt></a>
    variable.

!!SEEALSO
spinput

!!REDIRECT .measure     measure#.measure

!! format.tex 092611
!!KEYWORD
measure
!!TITLE
Parameter Measurement
!!HTML 
    <table border=0>
    <tr><td valign=top><b>jump to</b></td> <td>
    <a href="measure#point"><b>Point and Interval Specification</b></a><br>
    <a href="measure#compat"><b>Syntax Compatibility</b></a><br>
    <a href="measure#measure"><b>Measurements</b></a><br>
    <a href="measure#addl"><b>Additional Capabilities</b></a><br>
    <a href="measure#ref"><b>Referencing Results in Sources</b></a><br>
    </td></tr></table>

    <p>
    <i>WRspice</i> input files may contain <tt>.measure</tt>
    statements.  These statements allow certain types of measurements
    to be performed during a simulation, either at a selected point or
    over a selected interval.  The syntax is similar to the
    <tt>.measure</tt> statement in <a href="hspicesim">HSPICE</a>.
    <br clear=all>

    <p>
    <a name=".measure"></a>
    <font size=+3><b><tt>.measure</tt></b> <b>Line</b></font>
    <p>

    <p>
    General form:
    <blockquote>
        <tt>.measure</tt> <i>analysis</i> <i>resultname</i>
         <i>point</i> | <i>interval</i> [<i>measurements</i>]<br>
        <tt>.measure</tt> <i>analysis</i> <i>resultname</i>
            <tt>param=</tt><i>expression</i>
    </blockquote>

    <dl>
    <dt><i>analysis</i><dd>
    This specifies the type of analysis during which the measurement will
    be active.  Exactly one of the following keywords should appear in
    this field:  <tt>tran</tt>, <tt>ac</tt>, <tt>dc</tt>.
    </dl>
    <p>

    <dl>
    <dt><i>resultname</i><dd>
    This field specifies a name for the measurement.  The name should
    be unique among the measurements in the circuit, and among vectors
    in scope during simulation.  The name should start with an
    alphabetic character and contain no white space or other special
    characters.
    </dl>

    <p>
    A vector with this name will be added to the current
    plot, if the measurement is successful.  Vector names found in
    <tt>.measure</tt> lines are added to the internal save list,
    guaranteeing that the necessary data will be available when
    needed, whether or not the vector has been mentioned in a <a
    href=".save"><tt>.save</tt></a> line.


    <a name="point"></a>
    <h2>Point and Interval Specification</h2>

    <p>
    The field that follows the <i>resultname</i> contains a
    description of the conditions which initiate a measurement.  There
    are three basic types:  a point specification, an interval
    specification, and a post-measurement specificantion.

    <p>
    The <i>interval</i> begins with the "trigger" and ends with the
    "target".  Measurement will apply during this interval.  If no
    target is given, the trigger sets the <i>point</i>, where
    measurement will be performed.  The trigger and target are
    independently specified as follows:

    <dl>
    <dt><i>point</i><dd>
    <blockquote>
    [<tt>trig</tt>] <i>pointlist</i>
    </blockquote>
    This consists of the keyword <tt>trig</tt> (which is optional)
    followed by a point specification list.  The keyword
    "<tt>from</tt>" is equivalent to "<tt>trig</tt>".
    </dl>

    <dl>
    <dt><i>interval</i><dd>
    <blockquote>
    [<tt>trig</tt>] <i>pointlist</i> <tt>targ</tt> <i>pointlist</i>
    </blockquote>
    An interval contains a second point specification initiated with
    the mandatory keyword <tt>targ</tt>.  The keyword "<tt>to</tt>" is
    equivalent to "<tt>targ</tt>".
    </dl>

    <dl>
    <dt>post-measurement<dd>
    <blockquote>
    <tt>param=</tt><i>expression</i>
    </blockquote>
    Measurements in this form will be performed when all <i>point</i>
    and <i>interval</i> measurements are complete.  After all
    <i>point</i> and <i>interval</i> measurements have been performed,
    the <i>expression</i> will be evaluated and the result saved in
    <i>resultname</i>.  The <i>expression</i> can reference other
    measurement results in addition to the usual vectors and functions
    provided by the system.  These measurement lines are evaluated in
    the order found in the input.
    </dl>

    <dl>
    <dt><i>pointlist</i><dd>
    <blockquote>
    <i>pointspec</i> [<i>pointspec</i>] ...
    </blockquote>
    The point is specified with a list of <i>pointspec</i> specifications,
    and the event is registered on the first occasion when all
    <i>pointspec</i> elements are true, i.e., the conjunction is true.
    </dl>

    <dl>
    <dt><i>pointspec</i><dd>
    <i>keyword</i> <i>expression1</i> [<tt>=</tt>][<tt>val=</tt>]
      [</i>expression2</i> [<tt>cross=</tt><i>N</i>]
      [<tt>rise=</tt><i>N</i>] [<tt>fall=</tt><i>N</i>]]
      [<tt>td=</tt><i>delay</i>]
    </dl>

    <p>
    The <i>pointspec</i> begins with one of the following kewords: 
    <tt>before</tt>, <tt>at</tt>, <tt>after</tt>, <tt>when</tt>.  Of
    these, <tt>at</tt>, <tt>after</tt>, and <tt>when</tt> are
    equivalent aliases, but varied use can give a natural language
    feel to the conjuction list.  The <tt>before</tt> keyword negates
    logic:  the <i>pointspec</i> is true before the specified event.  This
    can be useful as an element in the conjunction list.

    <p>
    Once a <i>pointspec</i> becomes triggered, it remains triggered
    for the remainder of the simulation run.  Once triggered, a
    <tt>before</tt> <i>pointspec</i> will evaluate false, preventing
    the overall list from triggering.  Otherwise, the overall list
    triggers when each <i>pointspec</i> is true.

    <p>
    Following the keyword are one or two general expressions.  There
    can be an optional equal sign ("<tt>=</tt>") or a
    "<tt>val</tt>" keyword "<tt>val=</tt>" between the expressions.

    <p>
    An <i>expression</i> in this context can be:
    <ul>
    <li>A number or constant expression.  This is taken as the
    triggering point, meaning that the event occurs during simulation
    when the scale variable is equal to or exceeds the value.

    <li>The <i>resultname</i> of another measure.  The event occurs
    when the referenced measurement is performed.

    <li>A general expression consisting of constants, vector names,
    and circuit variables.  Frequently this will be simply a vector
    name corresponding to a node voltage or branch current in the
    circuit.
    </ul>

    <p>
    In <i>WRspice</i>, an expression is the minimum text required for
    a syntactically complete expression, and may include white space. 
    Single quotes or parentheses can be used to delimit expressions,
    if desired or needed.  The normal <a href="squote">single-quote
    expression</a> expansion and substitution is suppressed in this
    context.

    <p>
    If only one <i>expression</i> is given, and it is not a constant
    expression or a measure name, the event is triggered at the first
    time the expression becomes logically true, meaning that the
    absolute value is one or larger.  This corresponds to logical true
    produced by comparison and other logical operations in
    <i>WRspice</i>.  For example, the expression "<tt>V(5) >
    0.25</tt>" returns 0 if false and 1 if true.

    <p>
    If two expressions are given, neither can be a measure result
    name.  We are implicitly comparing the values of the two
    expressions, finding points where the two expressions are equal. 
    By default, the first time the values of the two expressions cross
    will trigger the event.  The following keywords can be assigned an
    integer value to trigger at the indicated point.

    <dl>
    <dt><tt>cross=</tt><i>N</i><dd>
     <i>N</i> is the number of crossings.
    <dt><tt>rise=</tt><i>N</i><dd>
    <i>N</i> is the number of times that <i>expression1</i> rises
    above <i>expression2</i>.
    <dt><tt>fall=</tt><i>N</i><dd>
    <i>N</i> is the number of times that <i>expression1</i> falls
    below <i>expression2</i>.
    </dl>
    <p>
    
    <dl>
    <dt><tt>td=</tt><i>delay</i><dd>
    If two expressions are given, the <i>delay</i> is the amount of
    scale value (e.g., time in transient analysis) before starting to
    look for crossing events.

    <p>
    If one expression is given, and the expression is not constant or
    a measure result name, the <i>delay</i> is the amount of the scale
    value to wait before checking to see if the expression evaluates true.
    If the expression is a measurement name, than the delay is added to
    the measurement time of the referenced measurement.

    <p>
    There is a special case, where no expressions are given, only a
    <tt>td=</tt><i>delay</i> value.  This can be a second or
    subsequent <i>pointspec</i> in the <i>pointlist</i>.  This will
    trigger at the time of the previous <i>pointspec</i> in the list
    (to the left) delayed by <i>delay</i>.

    <p>
    Examples:<br>
    <tt>at v(2)=0.5 rise=3 td=0.2nS after td=0.1nS</tt><br>
    &nbsp;&nbsp;Trigger 0.1nS after the third rising edge of v(2)
    after 0.2nS crosses 0.5V.<br>
    <tt>when v(2)&#60;v(1) before v(2)&#60;v(3)</tt><br>
    &nbsp;&nbsp;Trigger the first time that <tt>v(2) &#60; v(3)</tt>
    if and only if <tt>v(2) &#60; v(3)</tt> has never been true.

    <a name="compat"></a>
    <h2>Syntax Compatibility</h2>

    <p>
    The present syntax supported by the <tt>.measure</tt> command in
    <i>WRspice</i> is a super set of the previous syntax cases, which
    are shown below.  These should all work in the present system.

    <p>
    Form 1:
    <blockquote>
    <tt>trig|targ at=</tt><i>value</i>
    </blockquote>

    Form 1 is straightforward; the interval starts (<tt>trig</tt>) or
    ends (<tt>targ</tt>) at <i>value</i>.  <i>Value</i> must be within
    the simulation range of the scale variable (e.g., time in
    transient analysis).

    <p>
    The same effect can be achieved with:
    <blockquote>
        <tt>from=</tt><i>value</i> <tt>to=</tt><i>value</i>
    </blockquote>

    <p>
    Form 2:
    <blockquote>
    <tt>trig|targ</tt> <i>variable</i> <tt>val=</tt><i>value</i>
            [<tt>td=</tt><i>delay</i>] [<tt>cross=</tt><i>crosses</i>]
            [<tt>rise=</tt><i>rises</i>] [<tt>fall=</tt><i>falls</i>]
    </blockquote>

    <p>
    Form 2 allows the interval boundaries to be referenced to times
    when a variable crosses a threshold.  The <i>variable</i> can be
    any vector whose value is available during simulation.  The
    <i>value</i> is a constant which is used to measure crossing
    events.  The <tt>val=</tt> which precedes the <i>value</i> is
    optional.  At least one of the <tt>rise/fall/cross</tt> fields
    should be set.  Their values are integers which represent the
    variable crossing the threshold a number of times.  The
    <tt>rise</tt> indicates the variable rising through the threshold,
    <tt>fall</tt> indicates the variable decreasing from above to
    below the threshold, and <tt>cross</tt> indicates <tt>rises +
    falls</tt>.  The interval boundary is set when the specified
    number of transitions is reached.

    <p>
    If the delay is specified, transition counting starts after the
    specified delay.

    <p>
    Example:
    <blockquote>
        <tt>trig v(2) 2.5 td=0.1ns rise=2</tt>
    </blockquote>

    This indicates that the interval begins at the second time v(2) rises
    above 2.5V after 0.1ns.

    <p>
    Form 3:
    <blockquote>
    <tt>trig|targ when</tt> <i>expr1</i>=<i>expr2</i>
            [<tt>td=</tt><i>delay</i>]
            [<tt>cross=</tt><i>crosses</i>] [<tt>rise=</tt><i>rises</i>]
            [<tt>fall=</tt><i>falls</i>]
    </blockquote>

    <p>
    The third form is similar to the second form, except that
    crossings are defined when <i>expr1 = expr2</i>.  A rise is
    defined as <i>expr1</i> going from less than to greater than
    <i>expr2</i>.


    <a name="measure"></a>
    <h2>Measurements</h2>

    The following measurements are available when an interval has been
    specified.

    <dl>
    <dt><tt>find</tt> <i>expr</i>
      <dd>evaluate the difference:  <i>expr</i> at target minus
      <i>expr</i> at trigger.</dl>
    <dt><tt>min</tt> <i>expr</i>
      <dd>find the minimum value of <i>expr</i></dl>
    <dl>
    <dt><tt>max</tt> <i>expr</i>
      <dd>find the maximum value of <i>expr</i></dl>
    <dl>
    <dt><tt>pp</tt> <i>expr</i>
      <dd>find the (maximum - minimum) value of <i>expr</i></dl>
    <dl>
    <dt><tt>avg</tt> <i>expr</i>
      <dd>compute the average of <i>expr</i></dl>
    <dl>
    <dt><tt>rms</tt> <i>expr</i>
      <dd>compute the rms value of <i>expr</i></dl>
    <dl>
    <dt><tt>pw</tt> <i>expr</i>
      <dd>This will measure the full-width half-maximum of a pulse
          from <i>expr</i> contained in the interval.  The baseline is
          taken as the initial or final value with the smallest
          difference from the peak value.  The algorithm will measure
          the larger of a negative going or positive going pulse.</dl>
    <dl>
    <dt><tt>rt</tt> <i>expr</i>
      <dd>This will measure the 10-90 percent rise or fall time of the
          edge from <i>expr</i> contained in the interval.  The
          reference start and final values are the values at the ends
          of the interval.</dl>

    When a point has been specified, the only measurement form
    available is

    <dl>
    <dt><tt>find</tt> <i>expr</i>
      <dd>evaluate <i>expr</i> at point</dl>

    <p>
    A <tt>.measure</tt> statement can contain any number of
    measurements, including no measurements.  If no measurement is
    specified, the vector produced contains only zeros, however the
    scale vector contains the start and stop values, which may be the
    only result needed.  The created vector, which is added to the
    current plot, will be of length equal to the number of
    measurements, with the results placed in the vector in order.

    <p>
    The measurement scale point(s) in <tt>.measure</tt> statements are
    saved in a vector, which is the scale for the result vector.  If
    the measurement name is "<tt>result</tt>", the scale vector is
    named "<tt>result_scale</tt>".  The scale contains one or two
    values, depending on whether it is a point or interval
    measurement.

    <a name="addl"></a>
    <h2>Additional Capabilities</h2>

    <dl>
    <dt><tt>print</tt>, <tt>print_terse</tt><dd>
    By default, nothing is printed on-screen for a <tt>.measure</tt>
    line during interactive simulation.  If the keywords
    "<tt>print</tt>" appears in the <tt>.measure</tt> line, the
    results will be printed on the standard output.  A more concise
    format can be obtained from the alternative keyword
    <tt>print_terse</tt>.  The result vectors are created in all
    cases.
    </dl>

    <dl>
    <dt><tt>stop</tt><dd>
    If the keyword "<tt>stop</tt>" appears in a <tt>.measure</tt>
    line, the analysis will be paused when <i>all</i> measurements are
    complete.  Thus if the deck contains several <tt>.measure</tt>
    lines and <tt>stop</tt> is given in at least one, the analysis
    will pause when all of the measurements are complete, not just the
    one containing <tt>stop</tt>.  The analysis can then be resumed
    with the <a href="resume"><b>resume</b></a> command, or reset with
    the <a href="reset"><b>reset</b></a> command.
    </dl>

    <dl>
    <dt><tt>call</tt> <i>script</i><dd>
    After the measurement is performed, the named script will be
    called.  The script can be a normal script file or <a
    href="codeblock">codeblock</a>.  The script can be used for
    additional processing or testing of whatever sort.  If the script
    returns 1, the current simulation will pause immediately (no waiting
    for other measures) however a calling analysis, such as Monto
    Carlo, will continue.  If 2 is returned, this indicates a fatal
    global error and any calling analysis will be stopped too.  Any
    other return value allows the run to continue normally.
    </dl>

    <p>
    When a <tt>.measure</tt> is included in an iterative analysis
    (Monte Carlo, loop, etc.), data are saved as follows.  Before each
    iteration, the previous result vector and its scale are saved to
    the end of a "history" vector and scale, and are then deleted. 
    The result vector and scale are recreated when the measurement is
    completed during the iteration.  Thus, at the end of the analysis,
    for a measurement named "example", one would have the following
    vectors:

    <blockquote>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><th align="left"><tt>example</tt></th>
       <td>the result from the final trial</td></tr>
    <tr><th align="left"><tt>example_scale</tt></th>
      <td>the measurement interval or point in the last trial</td></tr>
    <tr><th align="left"><tt>example_hist</tt></th>
      <td>results from the prior trials</td></tr>
    <tr><th align="left"><tt>example_hist_scale</tt></th>
      <td>intervals from the prior trials</td></tr>
    </table><br>
    </blockquote>

    <p>
    Thus, during each trial, the result vector will have the same
    properties as in a standard run.  It can be used in the <a
    href="oprngfile">.control block</a> of a <a href="monte">Monte
    Carlo</a> or <a href="oprng_analysis">operating range</a> file
    (recall that <tt>$?</tt><i>vector</i> can be used to query
    existence, and that if there is no <tt>checkPNTS</tt> vector
    defined, the <tt>.control</tt> block is called once at the end of
    each trial).

    <p>
    Multiple <tt>.measure</tt> lines can be "chained" in the following
    manner.  The vector name following the <tt>from</tt>, <tt>to</tt>,
    <tt>trig</tt>, or <tt>targ</tt> keywords can be the name of
    another measure.  In this case, the effective start time is the
    measure time of the referenced measure.  The measure time is the
    end of the interval or the measure point.  The <tt>td</tt>,
    <tt>rise</tt>, etc.  keywords can be used in the referencing
    measure.  The <tt>td</tt> will be added to the imported time, and
    the other keywords operate in the normal way.  If there are no
    keywords other than <tt>td</tt> specified, the time is the delay
    time plus the imported time.
 
    <p>
    Example:
    <blockquote><tt>
    .measure tran t1 trig v(5) val=.4m rise=3<br>
    .measure tran t2 trig v(5) val=.4m rise=4<br>
    .measure tran pw trig t1 td=20p targ t2 td=20p pw v(5) max v(5)
    </tt></blockquote>
 
    <p>
    In this case, the measures t1 and t2 "frame" a period of an
    (assumed) repeating signal v(5).  Note that no actual measurement
    is performed for these lines.  Their purpose is to be referenced
    in the third line, which takes as its interval the t1-t2 interval
    delayed by 20 pS, and measures the pulse width and peak value.

    <a name="ref"></a>
    <h2>Referencing Results in Sources</h2>

    <p>
    It is possible to reference <tt>.measure</tt> results in sources. 
    The referencing token has the same form as a circuit variable,
    with an optional index, i.e.
    <blockquote>
    <tt>@</tt><i>result</i>[<i>index</i>]
    </blockquote>
    where the <i>index</i>, if used, is an integer that references a
    specific component of the <i>result</i> (0-based).  The value is
    always zero for timepoints before the measurement has been
    performed, and a constant value afterward.

    <p>
    Example:
    <blockquote><tt>
    .measure tran peak from=50n to=150n max v(5)<br>
    .measure tran stuff trig v(4) val=4.5 rise=1 targ v(4) val=4.5<br>
    + fall=2 min v(4) max v(4) pp v(4) avg v(4) rms v(4) print<br>
    vxx 1 0 @peak<br>
    vyy 2 0 @stuff[2]<br>
    </tt></blockquote>

    <p>
    In this example, during transient analysis, <tt>vxx</tt> is zero
    until 150 nS, where the measurement takes place, at which point it
    jumps to the value measured.  Likewise, <tt>vyy</tt> is zero until
    the measurement, at which point it jumps to the third component
    ("<tt>pp v(4)</tt>") result.  The resulting voltages can be used
    elsewhere in the circuit.  Note that we have two implementations
    of a behavioral peak detector.

!!SEEALSO
spinput

!!REDIRECT .exec        execblock#exec
!!REDIRECT .control     execblock#exec
!!REDIRECT .postrun     execblock#exec
!!REDIRECT .endc        execblock#exec
!!REDIRECT .check       execblock#check
!!REDIRECT .checkall    execblock#check
!!REDIRECT .monte       execblock#check
!!REDIRECT .noexec      execblock#check

!! format.tex 072716
!!KEYWORD
execblock
!!TITLE
Control Script Execution
!!HTML 
    <i>WRspice</i> includes a script parsing and execution facility,
    which uses a syntax similar to that of the Unix C-shell. 
    Statements which are interpreted and executed by this facility can
    be included in circuit files through use of the <tt>.exec</tt>,
    <tt>.control</tt>, and <tt>.postrun</tt> tokens.  These statements
    are enclosed in a block beginning with <tt>.exec</tt>,
    <tt>.control</tt>, or <tt>.postrun</tt> and ending with
    <tt>.endc</tt>.  The <tt>.exec</tt>, <tt>.control</tt>,
    <tt>.postrun</tt>, and <tt>.endc</tt> lines contain only the
    keyword.

    <p>
    <a name="exec"></a>
    <font size=+3><b><tt>.exec</tt></b>, <b><tt>.control</tt></b>,
      <b><tt>.postrun</tt></b>, and <b><tt>.endc</tt></b> <b>Lines</b></font>

    <p>
    General form:
    <blockquote>
        <tt>.exec</tt><br>
        shell commands ...<br>
        .<tt>.endc</tt><br>
        <br>
        <tt>.control</tt><br>
        shell commands ...<br>
        <tt>.endc</tt><br>
        <br>
        <tt>.postrun</tt><br>
        shell commands ...<br>
        <tt>.endc</tt><br>
    </blockquote>
 
    <p>
    Examples:
    <blockquote><tt> 
        <tt>.exec</tt><br>
        set vmin = 2.5<br>
        <tt>.endc</tt><br>
        <br>
        <tt>.control</tt><br>
        let maxv = v(2)*v(19)<br>
        <tt>.endc</tt><br>
    </tt></blockquote>
 
    <p>
    The <i>shell commands</i> are any commands which can be
    interpreted by the <i>WRspice</i> <a href="spshell">shell</a>. 
    The difference between <tt>.exec</tt> and <tt>.control</tt> is
    that for <tt>.exec</tt>, the commands are executed before the
    circuit is parsed, and for .control, the commands are executed
    after the circuit is parsed.

    <p>
    Commands in a <tt>.postrun</tt> block are executed after every
    simulation that completes normally (i.e., without errors or
    interrupts).  This can be used to dump circuit data to a file, for
    example, without having to explicitly give commands or write a
    script.

    <p>
    When the circuit is parsed, shell <a href="variablesub">variable
    substitution</a> is performed.  Shell variable references begin
    with '<tt>$</tt>', and are replaced with the text to which the
    shell variable has been set, unless the character before the
    '<tt>$</tt>' is a backslash ('\') which prevents substitution and
    is usually taken as a comment start.  The variable can be set from
    the shell with the <a href="set"><b>set</b></a> command, and a
    variable is also set if it is given in a <a
    href=".options"><tt>.options</tt></a> line.  Any text in a circuit
    description can reference a shell variable, and this offers a
    powerful capability for manipulating the circuit under the control
    of the shell.  As the variables must be set before the circuit is
    parsed, the <b>set</b> commands which perform this action can be
    included in the <tt>.exec</tt> block of the circuit file itself,
    or in the <tt>.options</tt> line.  For example, suppose one has a
    circuit with a large number of resistors, each the same value, but
    it is desired to run the circuit for several different values. 
    The resistor lines could be specified as

    <blockquote><tt>
      r31 11 36 $rvalue<br>
      r32 12 35 $rvalue</tt><br>
      etc.
    </blockquote>
    and elsewhere in the file one would have
    <blockquote><tt>
      .exec<br>
      set rvalue = 50<br>
      .endc<br>
    </tt></blockquote>
    The 50 can be changed to any value, avoiding the need to change
    the many resistor lines between simulation runs.  Note that the
    <tt>.exec</tt> block must be used, if <tt>.control</tt> was used
    instead, the variables would not be set until after the circuit is
    read, which means that they will not be properly defined when the
    expansion is performed.  The <tt>.control</tt> block is useful for
    initiating analysis and post-processing.

    <p>
    Note that there is an alternative method of parameterization using
    the <a href=".param"><tt>.param</tt></a> line.

    <p>
    The same effect could have been obtained from the use of the
    <tt>.options</tt> line as
    <blockquote><tt>
      .options rvalue=50
    </tt></blockquote>
    and, as the <tt>.options</tt> lines are expanded after the
    <tt>.exec</tt> lines are executed, one could have the following
    contrived example:
    <blockquote><tt>
      .exec<br>
      set rtmp=50<br>
      .endc<br>
      .options rvalue = $rtmp<br>
    </tt></blockquote>
    The shell variables set in <tt>.exec</tt> and <tt>.control</tt>
    blocks remain set until explicitly unset, however variables set in
    <tt>.options</tt> lines are active only when the circuit is the
    current circuit, and cannot be unset (with the <a
    href="unset"><b>unset</b></a> command) from the shell.  A variable
    set in the <tt>.options</tt> line will be superseded by the same
    variable set from the shell, <tt>.exec</tt> or <tt>.control</tt>
    lines.

    <p>
    Commands can also be included using a different mechanism, which
    might be useful if the circuit file is to be used with other
    simulators.  This mechanism uses comment lines to include shell
    commands.  If a comment begins with the characters '<tt>*@</tt>',
    the remainder of the line is taken as a shell command just as if
    it had been enclosed in <tt>.exec</tt> and <tt>.endc</tt>.  If a
    comment line begins with the characters '<tt>*#</tt>', the
    remainder of the line is treated as if it had been enclosed in
    <tt>.control</tt> and <tt>.endc</tt>.  Thus, in the example above,
    the <tt>.exec</tt> block could be replaced with the line
    <blockquote>
      <tt>*@ set rvalue = 50</tt>
    </blockquote>
    Obviously, this facility allows the possibility that a real
    comment can be misconstrued as a shell command.  The user is
    suggested to leave space after the * in intended comments, as a
    general rule.

    <p>
    If a circuit contains an <tt>.exec</tt> block, a plot structure is
    created to hold any vectors defined in the <tt>.exec</tt> block
    while the circuit is parsed.  Thus, if the circuit references
    vectors defined in the <tt>.exec</tt> block, the reference will be
    satisfied, and the variables will have initial values as defined
    in the <tt>.exec</tt> block.  Similar to variables, vectors can be
    used to pass values to the curcuit, through use of the <a
    href="variablesub">substitution</a> form "<tt>$&vecname</tt>".

    <p>
    In releases 4.2.4 and earlier, this plot was temporary, and was
    destroyed once the circuit lines were processed.  In present
    releases, this plot is retained, if it contains any vectors.

    <p>
    <a name=check"></a>
    <font size=+3><b><tt>.check</tt></b>, <b><tt>.checkall</tt></b>,
      <b><tt>.monte</tt></b>,
      <b><tt>.noexec</tt></b> <b>Lines</b></font>
    <p>

    General form:
    <blockquote><tt>
        .check<br>
        .checkall<br>
        .monte<br>
        .noexec
    </tt></blockquote>

    <p>
    <i>WRspice</i> provides a built-in two-dimensional operating range
    analysis as well as Monte Carlo analysis.  The analysis is
    initiated with the <a href="check"><b>check</b></a> command, or is
    performed immediately if in <a href="batchmode">batch mode</a>. 
    Files intended for operating range or Monte Carlo analysis may
    contain the keywords <tt>.check</tt>, <tt>.checkall</tt>, or
    <tt>.monte</tt>.  In each case, the execution of the
    <tt>.control</tt> block is suppressed when the circuit is read,
    however the <tt>.exec</tt> block is executed normally.  The
    <tt>.noexec</tt> keyword also suppresses execution of the
    <tt>.control</tt> block, but does not predispose the circuit to
    any particular type of analysis.

    <p>
    The <tt>.check</tt> line specifies operating range analysis, where
    the contour of operation is to be determined.  In the
    two-dimensional space of the variables being varied, the rows are
    evaluated from the left until a "pass" condition is found.  The
    analysis then resumes at the far right, working left until a
    "pass" point is found.  The area between the pass points is never
    evaluated.  If there are islands of fail points within the pass
    region, they will not be found with this algorithm.  The
    <tt>.checkall</tt> line, if used instead, will evaluate all of the
    points.  This slows evaluation, but is more thorough.

    <p>
    The <tt>.monte</tt> line specifies Monte Carlo analysis.  The
    <tt>.noexec</tt> line simply bypasses the execution of the
    <tt>.control</tt> lines when the file is read.  It is not an error
    to have more than one of these lines present in the file (but this
    is poor practice).  The <tt>.monte</tt> line has precedence, and
    <tt>.checkall</tt> has precedence over <tt>.check</tt>.  The
    <tt>.noexec</tt> is assumed if any of the other lines are given.

!!SEEALSO
spinput

!!REDIRECT .verilog     verilog#.verilog
!!REDIRECT .endv        verilog#.verilog
!!REDIRECT .adc         verilog#.adc

!! format.tex 012509
!!KEYWORD
verilog
!!TITLE
Verilog Interface
!!HTML 
    <i>WRspice</i> contains a built-in Verilog parser/simulator. 
    Verilog is a popular hardware description language for digital
    logic circuits.  The integration of Verilog with SPICE provides a
    wealth of new capability:
    <ul>
    <li>Direct support for analog/digital mixed-mode simulations.</ul>
    <ul>
    <li>The ability to create simulation control automation in a
        Verilog block.</ul>
    <ul>
    <li>The ability to create measurement automation in a Verilog
        block.</ul>
    <ul>
    <li>The ability to create pulse sources that have complex output
        and are independent of the transient time scale.</ul>

    <p>
    <a name=".verilog"></a>
    <font size=+3><b><tt>.verilog</tt></b>, <b><tt>.endv</tt></b>
      <b>Lines</b></font>
    <p>

    <p>
    In <i>WRspice</i>, all Verilog code is placed into a block of
    statements starting with a <tt>.verilog</tt> line and ending with
    a <tt>.endv</tt> line.  The Verilog block defines the modules of a
    hierarchy, including a top-level "stimulus" module.  The Verilog
    simulation is run in parallel with transient analysis, where each
    user time increment corresponds to one unit of Verilog time.  The
    simulation is performed as if <a
    href="steptype"><tt>steptype</tt></a> is set to
    <tt>hitusertp</tt>, i.e., simulation is performed at each user
    time point.  The verilog simulation occurs before the SPICE
    iterations at the time point.  Signals are passed to the Verilog
    block with <a href=".adc"><tt>.adc</tt></a> statements, and
    signals from the Verilog block are accessed through referencing
    voltage or current sources.

    <p>
    Output signals from the verilog block are obtained through voltage
    or current sources in the circuit.  The voltage/current source
    must refer by name to a Verilog variable in the scope of the top
    module, or use the Verilog "dot" path notation.  The
    voltage/current source is set to the binary value of the variable,
    and has a built-in rise/fall time of one time increment.  The
    variable reference can contain a bit or part select field.

    <p>
    A good primer on Verilog is:  Samir Palnitkar, "Verilog HDL, A
    Guide to Digital Design and Synthesis", SunSoft Press (Prentice Hall)
    ISBN 0-13-451675-3.  The full story is in IEEE Standard 1364-1995.

    <p>
    An example of a Verilog circuit is provided <a href="ex8">here</a>.

    <p>
    <a name=".adc"></a>
    <font size=+3><b><tt>.adc</tt></b> <b>Line</b></font>

    <p>
    General format:
    <blockquote>
        <tt>.adc</tt> <i>digital_var node_name</i> [<i>offset</i>]
            [<i>delta</i>]
    </blockquote>

    <p>
    This line of <i>WRspice</i> input converts a SPICE signal into a
    digital signal for the <a href=".verilog">Verilog</a> block.  Such
    lines are used only as an adjunct to Verilog.

    <p>
    The parameters have the following interpretation:

    <dl>
    <dt><i>digital_var</i><dd>
      A Qualified name of a variable in the Verilog block,
      which can include a range specification.
    </dl><dl>
    <dt><i>node_name</i><dd>
      The node of the circuit to convert, not including any "<tt>v()</tt>". 
      Current branches can be accessed as "<i>name</i><tt>#branch</tt>".
    </dl><dl>
    <dt><i>offset</i><dd>
      An optional real number subtracted from value before
      conversion (default 0).
    </dl><dl>
    <dt><i>delta</i><dd>
      The size of an lsb for conversion.  This is optional, defaulting to 1.
    </dl>

    <p>
     The transfer function is:
    <blockquote>
    <i>value</i> <tt>=</tt> <i>value</i> <tt>-</tt> <i>offset</i><br>
    <tt>if (</tt><i>value</i><tt> > 0)</tt><br>
    &nbsp;&nbsp;
      <i>value</i> <tt>=</tt> <i>value</i> <tt>+ 0.5*</tt><i>delta</i><br>
    <tt>else</tt><br>
    &nbsp;&nbsp;
      <i>value</i> <tt>=</tt> <i>value</i> <tt>- 0.5*</tt><i>delta</i><br>
    <i>conversion</i> <tt>= (integer) (</tt><i>value</i>/<i>delta</i><tt>)</tt>
    </blockquote>

    <p>
    The <i>offset</i> and <i>delta</i> arguments to the <tt>.adc</tt>
    line can be <a href="expressions">expressions</a>.  These will be
    evaluated once only, as the circuit is read in.

!!SEEALSO
spinput

