
!!  ---------------------------------------------------------------
!!  Xic/WRspice Help System Database
!!  $Id: spMain.hlp,v 1.44 2016/10/16 19:25:43 stevew Exp $
!!  Copyright (C) Whiteley Research Inc. 2003.  All Rights Reserved
!!  ---------------------------------------------------------------

!!HEADER
    <table border=1 width=100% cellpadding=0 cellspacing=0>
    <tr><td bgcolor=white><img src=wrbannermain.gif width=300 align=left>
!!IFDEF Windows
    <font face=sans color=royalblue size=4>
!!ELSE
    <font face=sans color=royalblue size=5>
!!ENDIF
    <br>&nbsp;&nbsp;<i>WRspice</i> Help</font></td></tr>
    <tr><td bgcolor=white height=40>
    <font face=sans color="#dd0000" size=5>&nbsp;&nbsp;%TITLE%</font></td></tr>
    </table><p>

!!FOOTER
    <p><hr><font size=3 face=sans color=darkblue>
    &#169; Whiteley Research Inc. 2016, All Rights Reserved.</font>

!!MAINTAG WRspice
!! This file in sync with manual.

!!KEYWORD
spMain.hlp
!!TITLE
spMain.hlp
!!HTML 

!!SUBTOPICS
wrspice
wrs:manual
sphistory
spice
spanalysis
spthreads
convergence
memory
spcontrol
sppost
spintr
batchmode
loadable
veriloga
refs
rawfilefmt
utilities
mmjco
multidec
printtoraw
proc2mod
wrspiced


!!KEYWORD
wrspice wrspice_top_topic
!!TITLE
Help
!!HTML 
    <table border=0 width=100%>
    <tr><td align=center>
    <font face=helvetica color="#000090">
    <b>Sunnyvale California</b>
    </font>
    <table border=0 width=80%>
     <tr><td align=left>
     </td><td align=right>
     </td></tr>
     <tr><td align=left>
     <font face=helvetica>
     <a href="http://wrcad.com">wrcad.com</a>
     </font>
     </td><td align=right>
     <font face=helvetica>
     <a href="mailto:support@wrcad.com">support@wrcad.com</a></tr>
     </font>
     </td></tr>
     </table>
    </td></tr>
    </table>

    <p>
    <center>
    <h3><font color=red>Welcome to the <i>WRspice</i><font>
         <a href="helpsys">help system</a></h3>
    </center>

    <h4>Introduction and <i>WRspice</i> Overview</h4>
    <a href="sphistory">SPICE History</a><br>
    <a href="spice"><i>WRspice</i> Overview</a><br>
    <a href="sparse">Sparse Matrix Package</a><br>
    <a href="spthreads">Multi-Threading</a><br>
    <a href="memory">Virtual Memory Usage</a><br>

    <h4><i>WRspice</i> Setup and Configuration</h4>
    <a href="setup">Installation and Setup</a><br>
    <a href="environment">Environment Variables</a><br>
    <a href="arguments">Command Line Arguments</a><br>
    <a href="startup_files">Initialization Files</a><br>

    <h4>Using <i>WRspice</i></h4>
    <a href="toolbar">Tool Control Window</a><br>
    <a href="spshell">Shell Features</a><br>
    <a href="commands">Builtt-in Commands</a><br>
    <a href="plotvec">Plots and Vectors</a><br>
    <a href="expressions">Vector Expressions</a><br>
    <a href="batchmode">Scripts and Batch Mode</a><br>
    <a href="options">SPICE Options</a><br>
    <a href="variables">Variables</a><br>
    <a href="convergence">Convergence</a><br>

    <h4><i>WRspice</i> Input Format</h4>
    <a href="spinput">Circuit Input Format</a><br>
    <a href="analyses">Analysis Types</a><br>

    <h4>Reference</h4>
    <a href="examples">Circuit Examples</a><br>
    <a href="rawfilefmt">Rawfile Format</a><br>
    <a href="refs">References</a><br>
    <a href="utilities">Utility Programs</a><br>
    <a href="http://wrcad.com/wrs_docs">
      <i>WRspice</i> Release Notes Archive</a><br>
    <a href="http://wrcad.com/manual/wrsmanual4">
      <i>WRspice</i> Reference Manual</a><br>

!!REDIRECT      hspicesim       sphistory#hspice

!! intro.tex 051522
!!KEYWORD
sphistory
!!TITLE
SPICE history
!!HTML 
    In the early days of radio, before the term "electronics" came
    into use, experimenters and scientists (engineers designed bridges
    then) built circuits on whatever could be found that was
    appropriate.  One popular substrate was the wooden breadboard as
    found in most kitchens.  The breadboard could be used to secure
    the tube sockets and other appendages through use of screws. 
    Thus, the term "breadboard" as a substrate for the building of
    electronic circuits was born.

    <p>
    Breadboards, in one form or another, were used for the
    construction of all electronic prototype circuits until the
    integrated circuit was invented in 1957.  Even well afterward, the
    integrated circuit was only another component on the breadboard. 
    A new circuit could be easily (well, in principle) debugged,
    modified, enhanced, or otherwise engineered toward perfection, as
    all points of the circuit were accessible for testing and
    measurement.

    <p>
    After it became possible to put more than a small number of
    devices on an integrated circuit chip, design of such chips became
    quite challenging.  Obviously there was no opportunity to solder
    in new components, or even probe the internal connections.  The
    circuit had to be perfect as designed, or it wouldn't work
    properly.  This is almost never the case for any but the simplest
    design for any but those engineers with godlike intelligence (or
    luck).  Clearly new tools and methods were needed.

    <p>
    The rescue came in the early 1970's with the distribution of a
    computer program called SPICE (Simulation Program for Integrated
    Circuit Engineering), developed at the University of California,
    Berkeley.  SPICE was a big (for its day) Fortran computer program,
    requiring the power of a mainframe computer.  A circuit was
    described in a certain syntax, which was punched into IBM computer
    cards.  The terminology this inspired persists to this day, as a
    line of SPICE input is often referred to as a "card", and a
    complete circuit description as a "deck".  In the bad old days,
    the engineer would laboriously punch the cards, deliver them to
    the Computer Center, and receive the line printer output a few
    hours later.  It would generally take several iterations before
    the first page of output would not say "Run Aborted...".  Old-time
    engineers abhorred this activity, which seemed suitable for office
    wimps and students only.  After a few years, and the advent of
    Tektronix direct view storage terminals, SPICE became the
    preeminent means of designing not just integrated circuits, but
    the old-fashioned kind as well.

    <p>
    SPICE is the progenitor of most circuit simulators currently in
    use.  As the source code was available for next to nothing, major
    organizations customized it for their own needs, and smoothed over
    some of the rougher edges.  It remains a numerically intensive
    program which can tax even the largest of today's computers.

    <p>
    Looking back, one can identify several important milestones in the
    accessibility of computer power to the technically inclined
    masses.  The first example was the ability to run the BASIC
    programming language on a desktop computer, introduced in the late
    1970's with the Tektronix 4051.  This 8-bit machine with a
    built-in direct view storage tube for the first time allowed
    engineers and scientists to have directly applicable computer
    power at their desk or laboratory bench.  Also at about this time,
    the UNIX operating system running on a VAX minicomputer became
    popular, largely supplanting the ahead-of-their-time desktop
    computers.  The VAX, although it was a mainframe, was very cost
    effective as compared to the competition, and UNIX was a much more
    desirable operating system for scientific and engineering purposes
    than others available.  As with the 4051, it allowed computer
    accessibility at the point of need, through use of a terminal. 
    Although one could compile and run SPICE on a VAX, it would tend
    to radically hog the VAX's resources, bringing the system to an
    annoying unresponsive state.  As a consequence, many system
    managers forbade the use of SPICE on their machines, thus SPICE
    users were still faced with interfacing to the company CDC or IBM
    or Cray, and the attendant CPU time charges and batch mode
    operation.  This situation persisted until the advent of the UNIX
    workstation in the early 1980's.

    <p>
    The original workstations were able to run SPICE, however the
    execution speed was quite slow by modern standards.  Still, they
    were often faster than a heavily loaded central mainframe, and
    although expensive, were cost effective over time as compared to
    CPU charges for a mainframe.  Many more engineers were able to
    take advantage of the convenience of running their simulations on
    local workstations, but due to the expense of the early
    workstations, the vast majority still had to slug it out with the
    mainframe.

    <p>
    In the early 1980's, the IBM personal computer came on the scene,
    and the real computer revolution was at hand.  However, these
    micros had severe limitations which prevented them from even
    loading a program as large as SPICE, thus they offered no solution
    to engineers and scientists needing major number crunching
    ability.  They did, however, provide the ability to run BASIC
    (thanks to Bill Gates), thus the personal computer began to
    displace the VAX in many instances, which had in turn displaced
    the earliest desktop BASIC machines.  As the number of machines
    grew, and thanks to the ingenuity and manufacturing skills
    resident in the Far East, the cost of these desktop computers
    dropped rapidly.  Intel, designer and purveyor of the
    microprocessor which was at the heart of the IBM compatible PC,
    made tons of money, which it wisely reinvested in newer and more
    capable models.  However, the original operating system, DOS,
    which ran universally on PC's, was designed for and significantly
    incorporated the limitations of the earliest microprocessors used
    in PC's.  These limitations have echos even today in certain
    Microsoft products.

    <p>
    Thus, it was not with a bang but with a whimper that the first
    inexpensive desktop computers which were capable of running SPICE
    and similar applications appeared.  The Intel 386 microprocessor
    made this possible.  Unlike its predecessors, the 386 was a true
    32 bit architecture, more powerful than a room full of VAX
    hardware.  It could easily sit on a desk, and cost, even in the
    early days, less than ten thousand dollars for a fully equipped
    system.  Alas, however, the 386 PC was like a Ferrari which was
    deliberately equipped to emulate a Volkswagen.  In order for the
    386 to be compatible with its relatively brain-dead predecessors,
    Intel included an emulation mode in the instruction set.  In this
    mode, called "real mode" by Intel, the 386 would behave as a
    somewhat faster version of earlier microprocessors, and thus be
    compatible with DOS, and all of the software written for DOS.  So
    thorough was the emulation that even though the 386 could access 4
    gigabits of memory directly, it was prevented from doing so under
    DOS, so that games and other archaic programs which could possibly
    make use of the memory address wrap around at 1 megabyte would
    perform as on earlier chips.  To this day under DOS, the 386 and
    its descendants operate in this emulation mode, leaving the
    high-power native mode unused.

    <p>
    Intel assumed that a software vendor, meaning Microsoft, would
    soon produce a successor to DOS that would unleash the full power
    of its new chips.  Alas, Microsoft responded by ignoring this
    potential in its own products, and appeared unsupportive of the
    exploitation of this power by other software vendors.  The size of
    the DOS market evidently influenced this business decision. 
    However, thankfully, a few small companies saw the potential.  The
    first was Phar Lap, which by working directly with Intel delivered
    a product known as a DOS extender.  Intel and Phar Lap, and
    others, created a specification under which extended DOS
    applications could coexist with regular DOS programs to a large
    extent.  The DOS extender allowed programs of arbitrary size to be
    compiled and executed in the 32-bit native mode, which Intel
    termed "protected mode".  The term derives from the memory mapping
    which allows all applications to have their own address space, and
    not clobber one another as they can under DOS.  At last, with this
    product and the right compiler, it was possible to run SPICE on a
    desktop PC, without worrying about the memory limitations of DOS.

    <p>
    Microsoft eventually began to exploit some aspects of protected
    mode in the Windows product, however, Windows was completely
    incompatible with extended DOS software at the time.  Microsoft's
    objective was to influence developers of large applications to
    port to Windows, for which they made available a $500.00 software
    development kit.  Unfortunately Windows at that time had a memory
    management system which most judged inadequate for applications
    such as SPICE, plus the support for earlier versions of the Intel
    microprocessors in Windows added rather severe performance
    penalties.  Thus, in spite of the lack of Windows compatibility,
    the DOS extender market greatly expanded, and several large
    commercial applications made use of this technology.  DOS
    extenders were eventually being included with many advanced
    compilers for "free".

    <p>
    The DOS extenders extended the life span of DOS, however many
    limitations remained.  One such limitation was the lack of
    multi-tasking.  Although some products such as Quarterdeck's
    DesqView provided some crude multitasking, clearly the time had
    arrived that a completely new operating system was in order. 
    These new operating systems began arriving in 1992.  Vendors of
    advanced workstations, such as Sun and Next, released versions of
    their UNIX-derived operating systems for Intel machines.  IBM
    introduced OS2 2.0, which was a 32-bit version of the OS2
    operating system.  Microsoft released the NT operating system,
    the first version of Windows that "really" used protected
    mode.

    <p>
    The contender that will probably most interest engineers and
    scientists is UNIX.  This operating system has a multi-decade
    history of use and improvement, with features and performance
    other operating systems are striving to emulate.  Proprietary
    operating systems based on UNIX are available from several
    vendors, unfortunately, the cost, still quite high due to the
    licensing fee extracted by the copyright holder, is a deterrent. 
    However, UNIX clones, which operate the same but use
    non-copyrighted software, are now widely available.  The most
    popular of these are Linux and FreeBSD, both of which are
    available on the Internet, and on CD for a small fee.  Both
    provide the advanced user with a state-of-the-art operating
    system, capable of running the plethora of applications available
    on the Internet.  Linux has become quite popular with the general
    technically-inclined public, while FreeBSD has found a large niche
    as an Internet server, due to its reliability and speed.  The
    running of massive applications on a desktop computer (or even a
    laptop) is now a reality.  A properly equipped Intel-compatible
    computer running FreeBSD can be considered in every respect a
    "Unix workstation".

    <p>
    The original Fortran version of SPICE became widespread in the
    industry, and the creators of SPICE dispersed and went on to new
    projects.  As SPICE became more widely used on modern hardware,
    its age began to show.  Thus, the Berkeley groups set about to
    rewrite SPICE in a modern programming language (C), and added new
    features and functionality.  The result was SPICE3.  Unlike the
    previous versions of SPICE, SPICE3 was designed for interactive
    use.  Furthermore, there were built-in features for plotting
    output on-screen, as well as enhanced control over the run in
    progress.  SPICE3 has to date not received the widespread
    acceptance of its predecessor, mainly because is lacks the long
    history of use.  Early releases did have bugs, and certain
    features were lacking.  The new code, being written in a
    structured form, is relatively easy to modify, thus SPICE3 should
    become a standard in time, however it is also competing with
    commercial versions of SPICE with many of the same features.  The
    original SPICE is still being shipped "as is", and although it is
    robust and stable, there are parts of the code that seemingly
    nobody understands.

    <p>
    In the early 1980's, IBM had a large project to introduce a
    computer based on Josephson junction logic.  IBM used internal
    software to model these circuits, as SPICE was not designed to
    support Josephson junctions.  To provide a generally available
    software simulation tool for the analysis of Josephson circuits,
    the Cryoelectronics group at Berkeley modified SPICE to include
    Josephson junctions.  This version of SPICE, JSPICE, was
    distributed by the Cryoelectronics group to the handful of
    interested researchers.  It quickly became the dominant tool for
    the simulation of these circuits (outside of IBM).

    <p>
    However, being based in SPICE, there were many aspects of the
    program which could stand improvement.  Making these improvements
    would entail a complete rewriting of the SPICE code, a rather
    formidable task with the Fortran source.  Nevertheless, this was
    done in large measure for internal use at Hypres, a small company
    engaged in superconductive electronics.  The Hyspice program
    contained a numerical core written in C, which was supported by
    much of the original SPICE Fortran.  The algorithms were modified
    to increase execution speed, while providing full support (rather
    than a tacked on appendage) for Josephson junctions.  The
    execution speed for Josephson circuits increased by about a factor
    of 3-5 over the older JSPICE.  Hyspice, however, was basically a
    batch mode program similar to JSPICE, although it was designed to
    work with a graphics post-processor, which was a separate
    application.

    <p>
    While entering a consulting and contract design practice, the
    author of Hyspice required a simulation tool in order to pursue
    design activities.  Hyspice was proprietary to a former employer,
    and was obsolete anyway.  JSPICE was even more obsolete.  Thus,
    the author decided to modify SPICE3 to incorporate a Josephson
    model.  Further modifications were anticipated so as to provide
    uncompromising capability and flexibility in the simulation of
    circuits using Josephson devices (without affecting the ability to
    simulate conventional circuits).  The resulting program, named
    JSPICE3, also had to be compatible with the author's 386 computer,
    yet be portable to other computers and operating systems should
    the need arise.  JSPICE3 evolved for several years.  Along the
    way, new features were added, including a schematic capture
    front-end.  The program, still available from Whiteley Research
    Inc., currently runs on most UNIX platforms, and is still being
    used in several industrial and educational facilities.

    <p>
    The author, once again getting restless, founded Whiteley Research
    Inc., in Sunnyvale, CA in 1996.  The company was to develop a new
    successor to JSPICE3, and other tools for schematic capture and
    mask layout editing.  After about one solid year of development,
    the <i>XicTools</i> toolset was announced.  The electrical circuit
    simulator, part of the core of the <i>XicTools</i> and known as
    <i>WRspice</i>, is a descendent of the JSPICE3 program, and
    maintains full compatibility.  The new program was migrated to the
    C++ programming language, for improved maintainability. 
    Compatibility with the older SPICE program was improved, as
    support for certain capabilities in SPICE, such as the POLY
    directive, that were missing from SPICE3 were incorporated in
    <i>WRspice</i>.  <i>WRspice</i> is more network-aware than its
    predecessors, and in fact can control the dispatching of jobs to
    remote machines, so that repetitive operations, such as Monte
    Carlo analysis, can exploit all of the machines in the user's
    workgroup in parallel.  Incidently, Monte Carlo analysis is a new
    feature, too.  Most of <i>WRspice</i> can be controlled
    graphically using point-and-click, yet is prompt-line compatible
    with its predecessors.

    <a name="hspice"></a>
    <h4>HSPICE</h4>

    Probably the most popular industrial-strength SPICE simulator is
    HSPICE &#174; from Synopsys, Inc.  Although "next generation"
    simulators from several vendors offer greater simulation speed and
    support larger circuits, the variety and completeness of HSPICE
    device models, algorithm flexibility, and usage history have made
    HSPICE a target simulator for most if not all process design kits
    provided by foundry services.  <i>WRspice</i> has evolved to
    incorporate some of the features of HSPICE, such as support for
    parameters and single-quoted expressions, and device model
    extensions, to enable compatibility with these design kits. 
    Further, when there is a conflict between HSPICE and Berkeley
    SPICE defaults, such as in the assumed temperature, <i>WRspice</i>
    has adopted the HSPICE conventions.  This is to conform to
    industry standards and current user expectations.  Though derived
    from Berkeley Spice3, <i>WRspice</i> seeks to emulate HSPICE
    behavior as much as possible.

    <p>
    However, there are some rather fundamental differences, for example:
    <ol>
    <li><i>WRspice</i> is designed for interactive use and contains an
    integrated graphical package, HSPICE is batch-mode only and a
    separate plotting program is required.
    <li>Not being interactive, HSPICE has no notion of a shell, or
    shell expansion.  The default treatment of the dollar-sign
    character is therefor very different.
    </ol>

!!SEEALSO
spice

!! intro.tex 012609
!!KEYWORD
spice
!!TITLE
<i>WRspice</i> Overview
!!HTML 
    <i>WRspice</i> is a general-purpose circuit simulation program
    based on the venerable Berkeley SPICE (Simulation Program for
    Integrated Circuit Engineering).  Although completely compatible
    with modern implementations of Berkeley SPICE, and partially
    compatible with many commercial extensions, <i>WRspice</i> is an
    entirely new simulator written in the C++ programming language for
    ease of development and maintenance with high performance. 
    <i>WRspice</i> includes a built-in Verilog parser/simulator for
    mixed analog/digital simulations.  Verilog is a popular IEEE
    standard hardware description language used to model digital logic
    circuits.

    <p>
    The overall structure of {\WRspice} is shown below.  The core of
    the program is the numerical analysis kernel, which actually
    solves the nonlinear circuit equations.  This engine is controlled
    by a large block of logic, which in turn is controlled through
    interaction with the keyboard and mouse, or under control of a
    script file, or even under the control of another program. 
    Repeated analyses, or analyses dependent upon the outcome of
    simulating variables, can be set up through use of control
    language scripts.  Input can be entered as description files, or
    graphically from a schematic representation.  Output can be
    plotted on the screen, with powerful ability to manipulate and
    transform the data.  The basic user interface is very similar to a
    UNIX shell, with automatic command completion, a history
    mechanism, and other features known to UNIX users.

    <p>
    <img src="blockdiag.gif">

    <p>
    <i>WRspice</i> uses the same basic algorithm to solve the
    nonlinear circuit equations as the original version of SPICE. 
    This is a modified nodal analysis, where a matrix <b>A</b> is
    determined, and a solution vector <b>X</b> is obtained from an
    excitation vector <b>B</b> by inverting the expression <b>AX</b> =
    <b>B</b>.  In <i>WRspice</i>, the coefficients of <b>X</b> are
    node voltages, and branch currents of voltage sources and
    inductors.  The coefficients of <b>B</b> are independent source
    currents, plus terms which are added during the linearization
    process.  The coefficients of <b>A</b> are the small-signal
    admittance parameters of each device, plus factors which relate
    branch currents to other circuit currents.

    <p>
    When the input description is submitted, <i>WRspice</i> sets the
    coefficients of the <b>A</b> matrix corresponding to each device
    in the circuit.  The <b>B</b> vector is also defined from
    knowledge of the source values.  The solution vector <b>X</b> is
    then obtained through an in-place LU decomposition of <b>A</b>. 
    If all circuit elements are linear, then <b>X</b> represents the
    output vector at the initial time point.  However, in general, the
    circuits contain nonlinear elements, and <b>X</b> at this point
    can be considered only an approximation to the correct solution. 
    This is because the <b>A</b> matrix contains only first order
    terms, and approximations of the contributions of higher order
    terms have been added to the <b>B</b> vector.  Initially, these
    "predictor" terms represent an educated guess, however after
    solving for <b>X</b>, one can obtain more accurate estimates. 
    These better estimates are then incorporated into a new <b>B</b>
    vector, a new <b>A</b> matrix is obtained, and the LU solution
    repeated.  This iterative process continues until the predictor
    terms converge to a stable value within an error tolerance.  This
    process is known as Newton's method.

    <p>
    A transient analysis solves the equation set at increments of time
    over the range specified by the user.  The time increment is
    determined by an algorithm which predicts the maximum allowable
    time step given past behavior.  Clearly, to simulate as rapidly as
    possible, the number of time steps and iterations should be
    minimized.  There are a number of variables which can be set in
    <i>WRspice</i> which affect this behavior, and it is difficult to
    generalize from one circuit to another which are the best
    conditions.  For example, one can lengthen the average time step,
    however this will generally require more iterations at each time
    step, which may lead to slower execution time.  Also, one can
    reduce the number of iterations by increasing the error tolerance,
    however this may result in excessive errors in the output.

    <p>
    The figure below shows a flow diagram of the solution algorithm
    for transient analysis.<br>

    <p>
    <img src="flow.gif">

    <p>
    Some distributions of <i>WRspice</i> separate the device models
    from the program, placing them into a dynamically linked library,
    which is loaded at run-time.  In some cases, the user has control
    of this library and can add or delete devices at will.  All
    device-related information in this manual pertains to the library
    supplied by Whiteley Research Inc.  with the <i>WRspice</i>
    product.  Local system administrators should be consulted for
    information on locally-added devices.

    <p>
    The default device library contains the devices familiar from
    SPICE2 and SPICE3, including resistors, capacitors, inductors,
    mutual inductors, independent and dependent voltage and current
    sources, lossy and lossless transmission lines, switches, and the
    five most common semiconductor devices:  diodes, BJTs, JFETs,
    MESFETs, and MOSFETs, plus Josephson junctions, similar to the RSJ
    model first included in SPICE2 by Jewett.  The original device
    models from SPICE3 are provided, along with a number of
    third-party models, particularly for MOS transistors.

    <p>
    <i>WRspice</i> is based on JSPICE3, which in turn was derived from
    SPICE3F4, which developed from SPICE2G.6.  While <i>WRspice</i> is
    being developed to include new features, it will continue to
    support those capabilities and models which remain in extensive
    use in the SPICE community.

    <p>
    <i>WRspice</i> is part of the <i>XicTools</i> design system from
    Whiteley Research, Inc.  These tools are designed to be modular,
    yet interactive.  In particular, <i>WRspice</i> will work
    seamlessly with the <i>Xic</i> graphical front-end for schematic
    capture, if the <i>Xic</i> program is present.  Otherwise
    <i>WRspice</i> can be utilized in a stand-alone mode.  From the
    <i>Xic</i> graphical editor, <i>WRspice</i> can be called upon to
    perform simulations, if <i>WRspice</i> is present.  In this case,
    since it is used in a background mode, the <i>WRspice</i> binary
    can exist on a remote machine.

    <p>
    <img src="powerlogo.gif" align="left">
    The <i>XicTools</i> package has been developed primarily under
    BSD-4.4 Unix (FreeBSD, <a
    href="http://www.freebsd.org"><tt>www.freebsd.org</tt></a>), which
    is the reference operating system.  The tools have been ported to
    many other UNIX-type operating systems, including Linux, Sun
    Solaris and SunOS 4.1.x, HPUX, and DEC Alpha-OSF.  The tools are
    also now available for Microsoft Windows.

    <p>
    Unix/Linux releases of <i>WRspice</i> use the <a
    href="http://www.gtk.org">GTK</a> toolkit running on the X window
    system for the graphical user interface.  If X is not available,
    or if the user so chooses, <i>WRspice</i> will run without
    graphics (other than crude ASCII-mode plots).

!!SUBTOPICS
spanalysis
spthreads
sparse
spcontrol
sppost
spinput
spintr

!!HTML 
!! useriface.tex 062515
!!KEYWORD
sparse klu
!!TITLE
Sparse Matrix Package
!!HTML 
    The core of a SPICE simulator is the set of functions that set up,
    factor, and solve the circuit equations.  The circuit equations
    form a matrix, whose elements, for most circuits, are mostly zero. 
    This type of matrix is deemed "sparse".  The speed with which the
    matrix can be filled, factored, and solved has a major impact on
    simulation speed.

    <p>
    Historically, <i>WRspice</i> has used a derivative of the
    venerable Sparse package written by Ken Kundert at Berkeley for
    sparse matrix processing.  The package has been modified for
    improved performance, specifically by sorting the matrix elements
    into an order which maximizes memory locality and minimizes
    page-swapping and cache misses.  The original C-language package
    was also translated into a set of C++ classes, improving
    maintainability and easing the integration of enhancements.

    <p>
    Although the Sparse package provides solid performance, newer
    algorithms have become available in recent years which, in some or
    most cases, provide better performance.  The KLU package, written
    by Tim Davis at the University of Florida, is one such example. 
    This package is distributed under a GNU license, which prevents
    direct incorporation into a proprietary commercial application
    such as <i>WRspice</i>, however commercial applications may use
    the package as a shared library.

    <p>
    <i>WRspice</i> distributions provide KLU in the form of a
    "plug-in".  A plug-in is a shared library that is loaded directly
    by the application at run-time, rather than relying on the system
    loader.  By using the plug-in, the application can still run
    properly whether or not the plug-in is available.  If loading was
    performed by the system as for a normal shared library,
    <i>WRspice</i> would not run unless the plug-in is accessible.

    <p>
    The KLU plug-in is installed in the <tt>startup</tt> directory in
    the <i>WRspice</i> installation area.  Thus, for normal
    installations, it should always be accessible.  By default,
    <i>WRspice</i> will load and use KLU for spares matrix processing,
    overriding the Sparse package.  However, it is possible to direct
    <i>WRspice</i> to use Sparse rather than KLU if desired.

    <p>
    For large post-extraction mixed-mode CMOS circuits used for
    benchmarking, the KLU package provides a 2-3 times improvement in
    simulation speed over Sparse.  These circuits contain hundreds of
    transistors, and thousands of resistors and capacitors.  For less
    complex circuits, the speed advantage may be smaller, and in some
    cases KLU may actually be slower.  KLU was observed to be slower
    in rather simple circuits containing Josephson junctions.  Users
    are encouraged to use the <a href="rusage"><b>rusage</b></a>
    command and determine which package provides the best performance
    on their circuits.

    <p>
    The following option variables control the sparse matrix handling. 
    The first two can be set from the <b>General</b> page of the
    <b>Simulation Options</b> tool.  The <tt>useadjoint</tt> variable
    can be set from the <b>Devices</b> page of the <b>Simulation
    Options</b> tool.  The <b>Simulation Options</b> tool is obtained
    from the <b>Sim Opts</b> button in the <b>Tools</b> menu of the
    <i>WRspice</i> <a href="toolbar"><b>Tool Control</b></a> window. 
    The variables can also be set with the <a
    href="set"><b>set</b></a> command, or in a <a
    href=".options"><tt>.options</tt></a> line in SPICE input.

    <dl>
    <dt><tt>noklu</tt><dd>
      When this boolean variable is set, KLU will not be used for
      sparse matrix calculations.  Otherwise, if the KLU plug-in is
      available, KLU will be used by default.  The KLU plug-in is
      provided with all <i>WRspice</i> distributions, and is installed
      in the startup directory.
    </dl>

    <dl>
    <dt><tt>nomatsort</tt><dd>
      When using Sparse (i.e., KLU is unavailable or disabled), this
      boolean variable when set will prevent using element sorting to
      improve speed.  This corresponds to the legacy <i>WRspice</i>
      sparse code.  It may be interesting for comparison purposes, but
      setting this variable will slow simulation of most circuits. 
      This variable has no effect if KLU is being used.
    </dl>

    <dl>
    <dt><tt>useadjoint</tt><dd>
      Most of the BSIM device models in <i>WRspice</i> have added code
      that builds an adjoint matrix which is used to accurately
      compute device currents.  The computed currents are not used in
      the device models, but are available as simulation outputs. 
      This has a small performance overhead so is not enabled by
      default, but will be enabled by setting this variable.  Without
      this, it may not be possible to obtain device currents during
      the simulation, using the <tt>@</tt><i>device</i>[<i>param</i>]
      "pseudo-vector".  This applies whether KLU or Sparse is used for
      matrix operations.
    </dl>

!! intro.tex 012609
!!KEYWORD
spanalysis
!!TITLE
Types of Analysis
!!HTML 
    Like its predecessors, <i>WRspice</i> supports various forms of
    nonlinear dc, nonlinear transient, and linear ac <a
    href="analyses">analyses</a>.

    <dl>
    <dt><a href=".dc">DC Analysis</a><dd>
    The dc analysis portion of <i>WRspice</i> determines the dc
    operating point of the circuit with inductors shorted and
    capacitors opened.  A dc analysis is automatically performed prior
    to a transient analysis to determine the transient initial
    conditions, and prior to an ac small-signal analysis to determine
    the linearized, small-signal models for nonlinear devices.  The dc
    analysis can also be used to generate dc transfer curves:  a
    specified independent voltage or current source is stepped over a
    user-specified range and the dc output variables are stored for
    each sequential source value.  In <i>WRspice</i>, dc analysis can
    be combined with other analysis types to generate a family of
    analysis results representing data from each point of the dc
    analysis.  The dc analysis is not available if Josephson junctions
    are present in the circuit.
    </dl>

    <dl>
    <dt><a href=".ac">AC Analysis</a><dd>
    The ac small-signal portion of <i>WRspice</i> computes the ac
    output variables as a function of frequency.  The program first
    computes the dc operating point of the circuit and determines
    linearized, small-signal models for all of the nonlinear devices
    in the circuit.  The resultant linear circuit is then analyzed
    over a user-specified range of frequencies.  The desired output of
    an ac small-signal analysis is usually a transfer function
    (voltage gain, transimpedance, etc).  If the circuit has only one
    ac input, it is convenient to set that input to unity and zero
    phase, so that output variables have the same value as the
    transfer function of the output variable with respect to the
    input.  The ac analysis can be combined with a dc sweep so that ac
    analysis is performed at each point over a range of bias
    conditions.  The ac analysis is not available on circuits
    containing Josephson junctions.
    </dl>

    <dl>
    <dt><a href=".tran">Transient Analysis</a><dd>
    The transient analysis portion of <i>WRspice</i> computes the
    transient output variables as a function of time over a
    user-specified time interval.  The initial conditions can be
    automatically determined by a dc analysis.  All sources which are
    not time dependent (for example, power supplies) are set to their
    dc value.  If Josephson junctions are present, or if the
    <tt>uic</tt> option is given, initial conditions are assumed at
    the start of analysis rather than the result of the dc operating
    point analysis.  With Josephson junctions, all sources should
    start with zero output.  Transient analysis can be combined with a
    dc sweep so that the transient simulation is performed at each
    point over a range of bias conditions.
    </dl>

    <dl>
    <dt><a href=".tf">Transfer Function Analysis</a><dd>
    The transfer analysis portion of <i>WRspice</i> computes the dc or
    ac small signal transfer function, input impedance, and output
    impedance of a network.  For ac analysis, the dc operating point
    is automatically determined through an operating point analysis. 
    The transfer analysis can be combined with a dc sweep so that the
    transfer function is computed at each point over a range of bias
    conditions.
    </dl>

    <dl>
    <dt><a href=".pz">Pole-Zero Analysis</a><dd>
    The pole-zero analysis portion of <i>WRspice</i> computes the
    poles and/or zeros in the small-signal ac transfer function.  The
    program first computes the dc operating point and then determines
    the linearized, small-signal models for all the nonlinear devices
    in the circuit.  This circuit is then used to find the poles and
    zeros.  Two types of transfer functions are allowed:  one of the
    form
    <blockquote>
    (<i>output_voltage</i>)/(<i>input_voltage</i>)
    </blockquote>
    and the other of the form
    <blockquote>
    (<i>output_voltage</i>)/(<i>input_current</i>)
    </blockquote>
    These two types of transfer functions cover all the cases and one
    can find the poles/zeros of functions like input/output impedance
    and voltage gain.  The pole-zero analysis works with resistors,
    capacitors, inductors, linear-controlled sources, independent
    sources, BJTs, MOSFETs, JFETs and diodes.  Transmission lines and
    Josephson junctions are not supported.
    </dl>

    <dl>
    <dt><a href=".disto">Distortion Analysis</a><dd>
    The distortion analysis portion of <i>WRspice</i> computes
    steady-state harmonic and intermodulation products for small input
    signal magnitudes.  If signals of a single frequency are specified
    as the input to the circuit, the complex values of the second and
    third harmonics are determined at every point in the circuit.  If
    there are signals of two frequencies input to the circuit, the
    analysis finds the complex values of the circuit variables at the
    sum and difference of the input frequencies, and at the difference
    of the smaller frequency from the second harmonic of the larger
    frequency.  Distortion analysis can be combined with a dc sweep so
    that distortion is analyzed at each point over a range of bias
    conditions.

    <p>
    Distortion analysis is supported for the following nonlinear
    devices:  diodes, bipolar transistors, JFETs, MOS1-4, MESFETs. 
    All linear devices are automatically supported by distortion
    analysis.  If there are switches present in the circuit, the
    analysis continues to be accurate provided the switches do not
    change state under the small excitations used for distortion
    analysis.
    </dl>

    <dl>
    <dt><a href=".sens">Sensitivity Analysis</a><dd>
    <i>WRspice</i> will calculate either the DC operating-point
    sensitivity or the AC small-signal sensitivity of an output
    variable with respect to all circuit variables, including model
    parameters.  <i>WRspice</i> calculates the difference in an output
    variable (either a node voltage or a branch current) by perturbing
    each parameter of each device independently.  Since the method is
    a numerical approximation, the results may demonstrate
    second-order effects in highly sensitive parameters, or may fail
    to show very low but non-zero sensitivity.  Further, since each
    variable is perturbed by a small fraction of its value,
    zero-valued parameters are not analyzed (this has the benefit of
    reducing what is usually a very large amount of data). 
    Sensitivity analysis can be combined with a dc sweep so that
    sensitivity can be analyzed at each point over a range of bias
    conditions.
    </dl>

    <dl>
    <dt><a href=".noise">Noise Analysis</a><dd>
    The noise analysis portion of <i>WRspice</i> performs analysis of
    device-generated noise for the given circuit.  When provided with
    an input source and an output node, the analysis calculates the
    noise contributions of each device (and each noise generator
    within the device) to the output node voltage.  It also calculates
    the level of input noise from the specified input source to
    generate the equivalent output noise.  This is done for every
    frequency point in a specified range --- the calculated value of
    the noise corresponds to the spectral density of the circuit
    variable viewed as a stationary Gaussian stochastic process. 
    Noise analysis can be combined with a dc sweep so that noise can
    be computed at each point over a range of bias conditions.

    <p>
    After calculating the spectral densities, noise analysis
    integrates these values over the specified frequency range to
    arrive at the total noise voltage/current (over this frequency
    range).  This calculated value corresponds to the variance of the
    circuit variable viewed as a stationary Gaussian process.
    </dl>

    <dl>
    <dt><a href="oprng_analysis">Operating Range Analysis</a><dd>
    <i>WRspice</i> has an integrated two-dimensional operating range
    analysis capability.  The operating range analysis mode is used in
    conjunction with the other analysis types, such as transient or
    ac.  A suitably configured source file and circuit description is
    evaluated over a one or two dimensional area of parameter space,
    producing (optionally) an output file describing the results at
    each evaluated point, or vectors giving the minimum and maximum
    values of the varying parameters for operation.  Results can be
    viewed graphically during or after simulation.
    </dl>

    <dl>
    <dt><a href="monte">Monte Carlo Analysis</a><dd>
    <i>WRspice</i> has a built-in facility for performing Monte Carlo
    analysis, where one or more circuit variables are set according to
    a random distribution, and the circuit analyzed for functionality. 
    The file format and operation is very similar to operating range
    analysis.
    </dl>

    <dl>
    <dt><a href="loop">Automated Looping</a><dd>
    In <i>WRspice</i>, any analysis can be automatically repeated
    while stepping over a one or two dimensional area of parameter
    space.  Any circuit parameter may be varied.
    </dl>

!!SUBTOPICS
convergence
memory
!!SEEALSO
spice
spthreads

!! intro.tex 051016
!!KEYWORD
spthreads
!!TITLE
Multi-threading
!!HTML 
    <i>WRspice</i> can use multi-threading to accelerate certain types
    of analyses.  This capability is not present in the original
    Berkeley SPICE and most derivatives, and allows <i>WRspice</i> to
    take advantage of the presence of multiple processor cores
    provided in modern microprocessor chips.  Multi-threading allows
    different cores to work on the same simulation job in parallel.

    <p>
    Multi-threading in <i>WRspice</i> is a new feature currently being
    incorporated.  It should be considered somewhat experimental at
    this point.  Users are encouraged to try it and share their
    observations (and report bugs!).  Multi-threading does <b>not</b>
    guarantee a faster run, as it has its own overhead that must be
    overcome to reduce overall run time.  Experience will provide
    insight into which types of circuits and analyses benefit from
    multi-threading and which do not, and what related threading
    parmeter values, such of the number of threads to reserve, give
    the best results on a given machine.

    <p>
    All supported operating systems provide multi-threading, however
    parallel runs require multiple cores or CPUs.  Many Intel
    processors provide two instruction queues (threads) per core, so
    that the number of available hardware threads is twice the number
    of cores.

    <h2>Multi-threaded loading</h2>

    Transient analysis has been cited as an algorithm not suitable for
    parallelization.  This is due to the analysis being inherently
    sequential; previous results are required before a new calculation
    can be performed.  However, there is one point where
    parallelization can logically be employed; the load operation.

    <p>
    In dc and transient analysis, the load operation is performed
    before each iteration.  During the load operation, the
    device-specific code is run using the previous iteration results,
    and the circuit matrix and right-hand side (rhs) vectors are
    loaded with the computed values.  As the ordering of devices is
    unimportant, different threads can be called upon to perform the
    load operation for different devices, in parallel.  The matrix and
    rhs loading operations are engineered to be atomic, so that
    different threads do not interfere with one another while
    accessing these common resources.

    <p>
    The loading operation dominates the simulation time in many
    circuits, particularly when complex device models such as BSIM are
    used.  These circuits benefit most from multi-threaded loading. 

    <p>
    When enabled, multi-threaded loading is used in dc analysis,
    including operating point analysis and when finding the operating
    point ahead of ac small-signal analysis, and transient analysis. 
    By default, multi-threaded loading is disabled.  It is enabled by
    setting the <a href="loadthrds"><tt>loadthrds</tt></a> variable to
    an integer value 1 or larger.  This can be done in a <a
    href=".options"><tt>.options</tt></a> line in the SPICE deck, or
    interactively from the command line using the <a
    href="set"><b>set</b></a> command, or graphically from the
    <b>General</b> page of the <a href="simopts"><b>Simulation
    Options</b></a> panel from the <b>Tools</b> menu.

    <p>
    The <tt>loadthrds</tt> variable sets the number of helper threads
    that will be created to assist the main thread in evaluating
    device code.  If 0 or not set, no helper threads are used.

    <p>
    Multiple threads will not necessarily make simulations run faster
    and in fact can have the opposite effect.  The latter is sadly
    true in Josephson circuits tested thus far.  The problem is that
    multi-threading adds a small amount of overhead, and the load
    function may be called hundreds of thousands of times in these
    simulations.  The model calculation for JJs runs very quickly, and
    the overhead becomes significant.  The same is true for other
    simple devices.  Work to improve this situation is ongoing.

    <p>
    On the other hand, if there is a lot of computation in the device
    model, this will dominate the overhead and we see shorter load
    times.  This is true for BSIM MOS models, in circuits with more
    than about 20 transistors.  Such simulations can run 2-3 times
    faster than a single thread.  One should experiment with the value
    of the <tt>loadthrds</tt> variable.  Most likely for best
    performance, the value plus the main thread should equal the
    number of available hardware threads, which is usually twice the
    number of available CPU cores.

    <h2>Multi-threaded looping</h2>

    A second potentially profitable use of multiple threads is when
    performing parameter sweeps, i.e. performing repeated simulations
    of a circuit while varying one or more parameters.  These
    simulations can be done in any order, as long as the computed
    results are saved in a well-defined sequence.  Thus, multiple
    threads can be called upon to run the simulations concurrently.

    <p>
    In <i>WRspice</i> there are several ways to initiate this type of
    repeated analysis.

    <dl>
    <dt><a href="multidc">chained dc analysis</a><dd>
    Most analysis specifications in <i>WRspice</i> can be followed by
    a dc sweep specification.  In <i>WRspice</i>, a <a href=".dc">dc
    sweep</a> is a one or two-dimensional sweep of <b>any</b> ciruit
    paramter, which is far more powerful than the original SPICE dc
    sweep which allowed only source outputs to be varied.  In this
    "chained dc" analysis, the basic analysis is performed at each
    point in parameter space of the sweep.  The result will be a
    family of multi-dimensional vectors, one dimension per parameter
    set.  Multi-threading is supported in this type of analysis.
    </dl>

    <dl>
    <dt>the <a href="sweep"><b>sweep</b></a> command<dd>
    The <b>loop</b> command is an interactive command that
    automatically sets one or two shell variables to points in a
    range, and initiates an arbitrary analysis at each point.  At each
    point, a circuit object is created from the shell-expanded SPICE
    input, which will reflect the state of the shell variables.  The
    specified analysis is then performed.

    <p>
    Unlike the chained dc analysis, the sweep can be run over any
    command, in particular a user's script.  However, internally the
    command runs at the shell level and has a lot of overhead, so the
    chained dc analysis would be preferable for speed when possible.
    At present, the <b>sweep</b> command is not multi-threaded.
    </dl>

    <dl>
    <dt><a href="monte">Monte-Carlo</a> analysis<dd>
    In Monte-Carlo analysis, repeated simulations are performed using
    a circuit object generated for each trial, where parameter values
    have been randomly generated according to a probability
    distribution.  The simulation run is analyzed by pass/fail logic,
    and only this result is typically saved.
    At present, Monte Carlo analysis is not multi-threaded.
    </dl>

    <p>
    As mentioned, at present only the chained-dc analysis can be
    multi-threaded.  This is accomplished by setting the <a
    href="loopthrds"><tt>loopthrds</b></a> variable to a positive
    integer.  This can be done in a <a
    href=".options"><tt>.options</tt></a> line in the SPICE deck, or
    interactively from the command line using the <a
    href="set"><b>set</b></a> command, or graphically from the
    <b>General</b> page of the <a href="simopts"><b>Simulation
    Options</b></a> panel from the <b>Tools</b> menu.

    <p>
    Multiple threads will be used automatically in a chained dc
    analysis if:

    <ol>
    <li>The <tt>loopthrds</tt> variable is set to an integer 1 or larger.
    This option variable indicates the number of "helper" threads to
    use.  It can be set to an integer in the range 0 through 31, with
    0 being the same as not set (single threading).  The "best" value
    can be found experimentally, but the value plus the main thread
    probably equals twice the number of available CPU cores.

    <p>
    <li>The analysis specification supports multi-threading.  Presently
    the following analyses can be multi-threaded:
    <blockquote>
    <a href=".tran"><b>tran</b></a>, without scrolling, segmenting, and
    with the <a href="steptype"><tt>nousertp</tt></a> mode not set.<br>
    <a href=".ac"><b>ac</b></a><br>
    <a href=".tf"><b>tf</b></a>
    </blockquote>
    </ol>

    <p>
    Multi-threading in the <b>sweep</b> command and Monte Carlo
    analysis is not yet available, but will be provided (it is hoped)
    in a future release.  These analyses require a rebuild of the
    circuit object for each trial, requiring that the entire input
    parser be thread safe.  This is because shell variables are used
    to pass parameters, requiring a re-parse of the circuit deck to
    create a modified internal circuit representation.  In chained dc
    analysis, the same circuit object is re-used multiple times.

    <p>
    The <tt>loopthrds</tt> and <tt>loadthrds</tt> can be used together.
    One should experiment to find the fastest settings.

!!SEEALSO
spice
spanalysis

!! intro.tex 021212
!!KEYWORD
convergence
!!TITLE
Convergence
!!HTML 
    Both dc and transient solutions are obtained by an iterative
    process which is terminated when both of the following conditions
    hold:

    <ol>
    <li>The nonlinear branch currents converge to within a tolerance of
        0.1 percent or 1 picoamp (1.0E-12 Amp), whichever is larger.

    <p>
    <li>The node voltages converge to within a tolerance of 0.1 percent
        or 1 microvolt (1.0E-6 Volt), whichever is larger.
    </ol>

    <p>
    Although the algorithm used in <i>WRspice</i> has been found to be
    very reliable, in some cases it will fail to converge to a
    solution.  When this failure occurs, the program will terminate
    the job.

    <p>
    Failure to converge in dc analysis is usually due to an error in
    specifying circuit connections, element values, or model parameter
    values.  Regenerative switching circuits or circuits with positive
    feedback probably will not converge in the <a href=".dc">dc
    analysis</a> unless the OFF option is used for some of the devices
    in the feedback path, or the <a
    href=".nodeset"><tt>.nodeset</tt></a> line is used to force the
    circuit to converge to the desired state.

    <p>
    See the section describing <a href=".op">operating point
    analysis</a> for a detailed description of the algorithms
    and information on convergence issues.

!!SEEALSO
spanalysis
reltol
abstol
vntol
 
!! intro.tex 012609
!!KEYWORD
memory
!!TITLE
Virtual Memory Usage
!!HTML 
    <i>WRspice</i> runs can consume quite a bit of virtual memory, and
    it is possible to exceed machine limits on many systems.  The main
    consumer of memory is the data arrays from simulation runs.  Each
    point is a double precision number requiring 8 bytes.  Typically,
    all nodes and branch currents are saved, though this can be
    changed with the <a href="save"><b>save</b></a> command.  One set
    of values is retained for each output increment.  For example, a
    circuit with 100 saved vectors running <tt>tran 1p 1n</tt>
    requires roughly 8 X 100 X 1000 bytes per run.  This is allocated
    to the plot structure.  By default, all plots are saved, so memory
    usage increases with each run.

    <p>
    The maximum memory that can be used for plot data storage for a
    single run is set by the <a href="maxdata"><tt>maxdata</tt></a>
    variable.  The <b>Tool Control</b> window displays memory
    statistics, and can be used to keep track of memory in use.

    <p>
    The vectors are copied when a plot is produced (including <a
    href="iplot">iplots</a>), thus this additional memory must be
    available for plots to be displayed.  In addition, iplots with a
    large number of data points (more than about 10000) can noticeably
    slow the simulation run. 

    <p>
    The <a href="free"><b>free</b></a> and <a
    href="destroy"><b>destroy</b></a> commands can be used to delete
    existing plots, making the memory available for other purposes. 
    The <a href="rusage"><b>rusage</b></a> command displays memory
    usage and memory limits.  Note that once <i>WRspice</i> obtains
    memory from the operating system, on many systems this memory is
    never returned.  Thus, the <b>free</b> command can make more
    memory available for <i>WRspice</i>, but not for other programs
    which may also be running.

    <p>
    Exceeding virtual memory limits is not in general a fatal error,
    depending on when the error occurs.  Plots and iplots allocate all
    memory needed at the beginning of the operation, so an out of
    memory condition will usually abort the operation and return the
    command prompt.  It is possible, though, for further errors to be
    generated by a memory failure which may cause a segmentation
    fault.

!!SEEALSO
spanalysis

!! intro.tex 012609
!!KEYWORD
spcontrol
!!TITLE
Program Control
!!HTML 
    <i>WRspice</i> is intended for use as an interactive tool, though
    various batch-mode features are supported.  Circuit input is
    provided in the form of files which are loaded into
    <i>WRspice</i>.  These files can be generated by the user with a
    text editor, or be generated by a graphical editor program such as
    <i>Xic</i>.  Once loaded into <i>WRspice</i>, a circuit is subject
    to the many types of analysis and post-processing operations
    available through <i>WRspice</i> commands.  These commands can be
    given interactively through the text-mode interface provided by
    <i>WRspice</i>, or in many cases through graphical operations.

    <p>
    The most common way directives are provided to <i>WRspice</i> is
    through the text-mode command line interface.  The command line
    interface behaves very much like a UNIX shell, through which
    commands are entered, variables set, and output is printed.  The
    shell provides most of the mechanisms familiar from UNIX shells,
    including aliasing, history substitution, and command completion.

    <p>
    The <a href="spshell">command shell</a> is normally established on
    the input terminal or terminal emulation window from which
    <i>WRspice</i> was executed.  <i>WRspice</i> takes control of this
    terminal, that is, all input typed will be directed to
    <i>WRspice</i>, however the operating system job control commands
    can be used to place <i>WRspice</i> in the background.

    <p>
    The <i>WRspice</i> shell provides a command language, which
    enables scripts containing commands to be executed.  Writing
    scripts enables automation of repetitive or complicated tasks. 
    Control commands can be added to circuit files, and in fact a
    unified input processing system handles both type of input.  Input
    files are loaded into <i>WRspice</i> with the <a
    href="source"><b>source</b></a> command.  The "<tt>source</tt>" is
    in fact optional.  If the file name does not conflict with the
    name of a <i>WRspice</i> command, simply typing the name of the
    file will perform the <b>source</b> operation.

    <p>
    When graphics is available, <i>WRspice</i> provides a small <a
    href="toolbar"><b>Tool Control</b></a> window which contains
    menus.  The menus contain buttons which in turn bring up graphical
    tools which control most of <i>WRspice</i>.  All of the operations
    of these tools have analogous command line commands, though many
    users find the graphical interface preferable.

    <p>
    <i>WRspice</i> contains a complete HTML-based <a
    href="helpsys">help system</a>, available with the <b>help</b>
    command.  The help windows provide an extensively cross-linked
    reference on the various commands and features.  In addition, the
    help windows can be used to view arbitrary HTML content on the
    Internet or on the user's local machine.

!!SEEALSO
spice

!! intro.tex 012609
!!KEYWORD
sppost
!!TITLE
Post-Processing and Run Control
!!HTML 
    <i>WRspice</i> in interactive mode provides a powerful <a
    href="plot">plotting capability</a> for simulation output.  Plots
    can be generated <a href="iplot">on the fly</a> while simulating,
    or after simulation is complete.  The command language provides
    interactive data manipulation and generation capability on output
    prior to plotting.  Any number of plots can be shown on-screen at
    a given time, and traces can be copied between plot windows via
    mouse operations for easy comparison.

    <p>
    A <a href="trace"><b>trace</b></a> command allows the value of
    expressions involving circuit variables to be printed as
    simulation progresses.  Simulation can be paused by typing the
    interrupt character (<b>Ctrl-C</b>), and can be resumed later. 
    Simulation can also be paused after a certain number of data
    points, or when a logical expression involving circuit variables
    becomes true.

    <p>
    The <a href="verilog">Verilog</a> capability can be used to
    provide automata for control and monitoring of a circuit during
    simulation.  Verilog modules are defined within the circuit
    description, and are evaluated as simulation (transient analysis
    only) progresses.  This is clearly useful for mixed analog/digital
    systems, but has additional utility for implementing event or
    error counters, etc., for output statistical analysis.

    <p>
    <i>WRspice</i> provides a <a href=".measure">measurement</a>
    capability for providing timing or other information from a
    circuit simulation.  Any number of measurements can be included in
    a circuit description.  This can be particularly useful in
    optimization scripts.

    <p>
    All of this capability is tied together in the <i>WRspice</i> <a
    href="spshell">shell</a>, which provides command processing in
    interactive mode, but also provides a scripting capability. 
    Scripts can be written to automate complicated analyses and data
    manipulation.  All circuit output data, device and circuit
    parameters, and shell variables and vectors are available in a
    rich programming environment.

!!SEEALSO
spice

!! intro.tex 012609
!!KEYWORD
spintr
!!TITLE
Introduction to Interactive Simulation
!!HTML 
    <i>WRspice</i> is an interactive circuit simulation program.  One
    can find details about preparing <i>WRspice</i> input files <a
    href="spinput">elsewhere</a>, this section assumes some
    familiarity with this syntax, which is basically that of SPICE2. 
    This section is intended to be a quick introduction to the use of
    <i>WRspice</i>, and its capabilities.
 
    <p>
    If <i>Xic</i> is being run, circuits can be entered graphically,
    making the command line interface described here somewhat
    unnecessary (there are users, however, who prefer the command line
    interface).  However, in order to use the full spectrum of
    capabilities, the command line interface is required.

    <p>
    To start <i>WRspice</i>, one can type
    <blockquote>
    <tt>wrspice</tt> <i>input_file</i>
    </blockquote>
    where <i>input_file</i> is the name of the <i>WRspice</i> circuit
    description file to run.  Alternately, one can simply type
    <blockquote>
    <tt>wrspice</tt>
    </blockquote>
    in which case <i>WRspice</i> will start up without loading a
    circuit.  A new circuit description file can be loaded into
    <i>WRspice</i> by typing the command
    <blockquote>
    <tt>source</tt> <i>input_file</i>
    </blockquote>
    If the name <i>input_file</i> is different from any internal or
    external <i>WRspice</i> commands, the <a
    href="source"><b>source</b></a> command can be eliminated, and the
    <i>WRspice</i> input file is loaded simply by typing the file name
    at the command prompt.  The file is parsed into an internal
    circuit representation, which is held in memory until explicitly
    deleted.  The list of circuits is shown in the panel brought up by
    the <b>Circuits</b> button in the <b>Tools</b> menu of the <a
    href="toolbar"><b>Tool Control</b></a> window.  One can switch
    the ``current circuit'' with the <a
    href="setcirc"><b>setcirc</b></a> command.

    <p>
    When <i>WRspice</i> starts, it normally displays a <b>Tool
    Control</b> window containing command menus.  The menu buttons
    bring up panels which control and display information.  Most of
    the typed commands have analogues within the display panels. 
    These panels can be arranged on the screen, and the configuration
    saved, so that when <i>WRspice</i> is started subsequently, the
    user's screen arrangement will be presented.

    <p>
    In addition, <i>WRspice</i> "takes over" the text window from
    which it was launched.  The command interface is very much like a
    <a href="spshell">shell</a>, and in fact it can be configured to
    run <a href="unixcom">operating system commands</a> in a manner
    very similar to the C-shell.

    <p>
    If there are any analysis lines in the input file and the user
    wishes to run the analyses as given there, one simply enters
    <blockquote>
    <tt>run</tt>
    </blockquote>
    <i>WRspice</i> will run the requested analyses and will prompt the
    user again when finished and the output data are available.  If
    the user wishes to perform an analysis that is not specified by a
    line in the input file, one can type the analysis line just as it
    would appear in the input file, without the dot.  For example, the
    command
    <blockquote>
    <tt>ac lin 20 0.99 1.01</tt>
    </blockquote>
    will initiate an ac analysis with 20 frequency values between 0.99
    and 1.01.

    <p>
    After the analysis is complete and the <i>WRspice</i> prompt is
    displayed, the values of the nodes are available.  Similarly, one
    can load the results from previous <i>WRspice</i> sessions using
    the <a href="load"><b>load</b></a> command.  In either case, to
    plot the voltage on nodes 4 and 5, for example, one could then
    issue the command
    <blockquote>
    <tt>plot v(4) v(5)</tt>
    </blockquote>
    To display a list of the circuit variables available for plotting,
    type <a href="display"><b>display</b></a> at the command prompt. 
    The output data items displayed are <a
    href="plotvec">vectors</a>, with a length generally equal to
    the number of analysis or output points in the simulation.

    <p>
    To plot vectors with the <a href="plot"><b>plot</b></a> package,
    one types
    <blockquote>
    <tt>plot</tt> <i>varlist</i>
    </blockquote>
    where <i>varlist</i> is a list of outputs (such as <tt>v(3)</tt>)
    or expressions (such as <tt>v(3)*time</tt>).  <i>WRspice</i> will
    plot a graph of the outputs on the screen.  When finished
    plotting, <i>WRspice</i> will issue a prompt.  Under windowing
    systems such as X, the plot will be drawn in a newly created
    window somewhere on the screen.  This window will remain open
    until explicitly dismissed by the user, however the execution
    returns to <i>WRspice</i> immediately, so that any number of plots
    can be on-screen simultaneously.

    <p>
    One can also specify combinations of outputs and functions of them, as in
    <blockquote>
    <tt>plot v(1) + 2 * v(2)</tt>
    </blockquote>
    or
    <blockquote>
    <tt>plot log(v(1)) sin(cos(v(2)))</tt>
    </blockquote>
    Notice that the vector name <tt>v(1)</tt> is not a function, but
    rather denotes the voltage at the node named 1.  One can use most
    algebraic functions, including trig functions, <tt>log</tt> -
    (base 10), <tt>ln</tt> - (base e), and functions such as
    <tt>mag</tt>, the magnitude of the complex number,
    <tt>phase</tt>, the phase, <tt>real</tt>, the real part, and
    <tt>imag</tt>, the imaginary part.  These all operate on real or
    complex values.  A complete list of functions and operations
    available can be found <a href="mathfuncs">here</a>.  Generally,
    any command which expects a vector as an argument will accept an
    expression.

    <p>
    The notation
    <blockquote>
    <tt>plot</tt> <i>something</i> <tt>vs</tt> <i>something_else</i>
    </blockquote>
    means to plot <i>something</i> with <i>something_else</i> on the
    X-axis.

    <p>
    The plot style can be modified through buttons and features found
    on the <a href="plotpanel">plot window</a>.  These and other
    features can have default behavior changed through setting of <a
    href="spshell">shell</a> variables.  Shell variables are set with
    the <a href="set"><b>set</b></a> command from the command line,
    and any alphanumeric variable can be set to a value or a string. 
    There are a number of such variables that are predefined to affect
    plotting.  These can also be altered graphically from the panel
    brought up by the <b>Plot Opts</b> button in the <b>Tools</b>
    menu.  The panel brought up by the <b>Variables</b> button in the
    <b>Tools</b> menu shows a listing of the shell variables currently
    set.

    <p>
    For example, one can modify the <b>plot</b> command to plot a
    subset of the data available.  The command
    <blockquote>
    <tt>set ylimit = "1 2"<br>
    plot v(1) v(2)</tt>
    </blockquote>
    will plot the two vectors when the values are between 1 and 2, and
    <blockquote>
    <tt>set xlimit = "1 2"<br>
    plot v(1) v(2)</tt>
    </blockquote>
    will plot them when the scale (time or frequency) is between 1 and 2.
    The variables will remain set until they are unset, using
    <blockquote>
    <tt>unset xlimit ylimit</tt>
    </blockquote>
    or the corresponding buttons in the <b>Plot Options</b> panel are
    made inactive.

    <p>
    The command
    <blockquote>
    <tt>set xcompress 5<br>
    plot v(1) v(2)</tt>
    </blockquote>
    plots only every fifth point, and
    <blockquote>
    <tt>unset xcompress<br>
    set xindices 20 30<br>
    plot v(1) v(2)</tt>
    </blockquote>
    plots the values between the 20th time point and the 30th.  Any of
    these variables may be used together, and they are also available
    in the <b>asciiplot</b> command (which produces an ASCII
    representation for use with text-only printers).

    <p>
    Typing <a href="let"><b>let</b></a> without arguments is
    synonymous with the <b>display</b> command.  The <b>let</b>
    command is different from the <b>set</b> command, which sets
    non-vector shell variables, which may control various aspects of
    <i>WRspice</i> operation.  The <b>let</b> command is used to
    assign a new vector, for example
    <blockquote>
    <tt>let aa = v(1)</tt>
    </blockquote>
    will assign a new vector <tt>aa</tt> with all components equal to
    <tt>v(1)</tt>.  If no arguments are given, a listing of output
    vectors from the most recent simulation is shown.  This listing is
    also shown in the panel brought up by the <b>Vectors</b> button in
    the <b>Tools</b> menu.

    <p>
    One can print the values of vectors with the <a
    href="print"><b>print</b></a> command:
    <blockquote>
    <tt>print time</tt>
    </blockquote>
    The command
    <blockquote>
    <tt>print all</tt>
    </blockquote>
    will print the values of all the data available.  Incidentally,
    one can also use the keyword <tt>all</tt> with any of the other
    commands that take vector names, like <b>plot</b>.  There are also
    alias and history mechanisms available, and a <b>shell</b>
    command, which passes its arguments to the operating system shell,
    or starts a subshell.

    <p>
    If the user wishes to <a href="write">save the output</a> values
    in a data file known as a rawfile, one can then type
    <blockquote>
    <tt>write</tt> <i>filename</i> v(4) v(5)</tt>
    </blockquote>
    to put the values of <tt>v(4)</tt>, and <tt>v(5)</tt> into
    <i>filename</i>.  If the user wishes to save everything, one can
    type
    <blockquote>
    <tt>write</tt> <i>filename</i>
    </blockquote>

    <p>
    There are also many commands for tracing the analysis - one can
    print the values at a node for each time point or cause
    <i>WRspice</i> to stop whenever a value gets to a certain point. 
    Relevant commands include <a href="stop"><b>stop</b></a>, <a
    href="trace"><b>trace</b></a>, and <a href="step"><b>step</b></a>. 
    A listing of these commands that are currently in force is
    available in the panel brought up with the <b>Trace</b> button in
    the <b>Tools</b> menu.

    <p>
    After the user is done with the values obtained from the
    simulation run, one can change the circuit and re-run the
    analysis.  If it is desired to edit the circuit itself, one can
    use the command <a href="edit"><b>edit</b></a> - it will bring up
    an internal <a href="xeditor">text editor</a> (or a favorite
    external editor) and allow changes to the circuit in whatever way
    is necessary, and then when the editor is exited, <i>WRspice</i>
    can re-load the circuit and be ready to run it again.  Under UNIX
    with X windows, a default internal editor is provided.  This
    editor is also available as the <b>xeditor</b> command from the
    UNIX shell.  Also, one can give another analysis (<b>ac</b>,
    <b>dc</b>, <b>tran</b>, ...) command after the first one
    completes.  If the analysis is not finished, i.e.  the user typed
    an interrupt (<b>Ctrl-C</b>), or the run stopped under the
    <b>stop</b> command, then one must type <a
    href="reset"><b>reset</b></a> in order to re-run an analysis from
    the beginning.

    <p>
    Each separate analysis that is performed will create one or more
    sets of values.  Such a set of values is called a plot - if
    several analyses have been performed, and the user wishes to
    switch from the results of one to the results of another, the <a
    href="setplot"><b>setplot</b></a> command will inform the user as
    to which analysis results are available and let the user choose
    one.  The plots are displayed in the panel brought up by the
    <b>Plots</b> button in the <b>Tools</b> menu.

    <p>
    To see what other commands are available type <b>Ctrl-D</b> in
    <i>WRspice</i>.  For information about a particular command, type
    <tt>help</tt> <i>command</i>, where <i>command</i> is one of those
    listed by <b>Ctrl-D</b>.  This introduction should be enough to
    get started.

    <p>
    Here is a sample <i>WRspice</i> run:
    <blockquote>
    <tt>csh% wrspice</tt><br>
    <tt>wrspice 10 -> source xtal.in</tt><br>
    <tt>Circuit: crystal filter</tt><br>
    <br>
    <tt>wrspice 11 -> listing</tt><br>
    <blockquote>
    (listing of the circuit is printed)
    </blockquote>
    <br>
    <tt>wrspice 12 -> run</tt><br>
    <tt>wrspice 15 -> display</tt><br>
    <tt>Here are the vectors currently active:</tt><br>
    <pre>
    Title: crystal filter
    Plotname: AC analysis curves.
    Date: Thu Sep 26 12:16:34 PDT 1985

    &#32;FREQ    : frequency (complex, 20 long) [scale]
    &#32;V(4)    : voltage (complex, 20 long)
    &#32;V(6)    : voltage (complex, 20 long)
    &#32;V(5)    : voltage (complex, 20 long)
    </pre>
    <blockquote>
    (and so on...)
    </blockquote>
    <br>
    <tt>wrspice 16 -> plot v(4)</tt><br>
    <blockquote>
    (plot takes place)
    </blockquote>
    <br>
    <tt>wrspice 17 -> write outfile freq v(4)</tt><br>
    <tt>wrspice 18 -> ac lin 30 1 2</tt><br>
    <tt>wrspice 19 -> display</tt><br>
    <tt>Here are the vectors currently active:</tt><br>
    <br>
    <pre>
    Title: crystal filter
    Plotname: AC analysis curves.
    Date: Thu Sep 26 12:16:34 PDT 1985
    
    &#32; FREQ    : frequency (complex, 30 long) [scale]
    &#32; V(4)    : voltage (complex, 30 long)
    &#32; V(6)    : voltage (complex, 30 long)
    &#32; V(5)    : voltage (complex, 30 long)
    </pre>
    <blockquote>
    (and so on...)
    </blockquote>
    <br>
    <tt>wrspice 20 -> print v(4) > tempfile</tt><br>
    <blockquote>
    (print to tempfile takes place)
    </blockquote>
    <br>
    <tt>wrspice 21 -> shell lpr tempfile</tt><br>
    <blockquote>
    (a printout is made of the results)
    </blockquote>
    <br>
    <tt>wrspice 22 -> load testh</tt><br>
    <pre>
    Title:  SPICE 3-C raw output test heading
    Name:  Transient analysis.
    Date:  08/19/84 03:17:11
    </pre>
    <br>
    <tt>wrspice 23 -> display</tt><br>
    <tt>Here are the variables currently active:</tt><br>
    <br>
    <pre>
    Title: SPICE 3-C raw output test heading
    Plotname: Transient analysis.
    Date: Sun Dec 1 11:18:25 PST 1985

    &#32; TIME    : time (real, 152 long) [scale]
    &#32; v(1)    : voltage (real, 152 long)
    &#32; v(2)    : voltage (real, 152 long)
    &#32; v(3)    : voltage (real, 152 long)
    &#32; v(4)    : voltage (real, 152 long)
    &#32; v(5)    : voltage (real, 152 long)
    </pre>
    <br>
    <tt>wrspice 24 -> print v(1)</tt><br>
    <blockquote>
    (prints v(1) values)
    </blockquote>
    <br>
    <tt>wrspice 25 -> plot v(1)</tt>
    <blockquote>
    (plot takes place)
    </blockquote>
    <br>
    <tt>wrspice 26 -> let xxx = log(v(1))</tt><br>
    <tt>wrspice 27 -> plot xxx</tt><br>
    <blockquote>
    (plot takes place)
    </blockquote>
    <br>
    <tt>wrspice 28 -> plot v(1) v(2) v(3) + 1 vs TIME * 2</tt><br>
    <blockquote>
    (plot takes place)
    </blockquote>
    <br>
    <tt>wrspice 30 -> asciiplot v(1) v(2) TIME + 2 > File</tt><br>
    <tt>wrspice 31 -> shell lpr File</tt><br>
    <blockquote>
    (Pick up ASCII plot ...)
    </blockquote>
    <br>
    <tt>wrspice 33 -> quit</tt><br>
    <tt>Warning: the following plot hasn't been saved:</tt><br>
    <tt>    crystal filter, AC analysis curves.</tt><br>
    <br>
    <tt>Are you sure you want to quit? y</tt><br>
    <br>
    <tt>csh%</tt><br>
    </blockquote>

    <p>
    Note that <i>WRspice</i> will issue a warning if there is work in
    progress that has not been saved.

!!SEEALSO
spice


!! useriface.tex 120424
!!KEYWORD
batchmode
!!TITLE
Batch Mode
!!HTML 
    Although <i>WRspice</i> is intended to be an interactive program,
    batch mode, similar to SPICE2, is supported.  If <i>WRspice</i> is
    invoked with the <a href="-b"><tt>-b</tt></a> command line option,
    it will process the input circuit files in batch mode.  The files
    are input on the command line, and if no files are listed, the
    standard input is read.  Most of the control lines recognized by
    SPICE2 will be handled, including <a
    href=".plot"><tt>.plot</tt></a>, <a
    href=".print"><tt>.print</tt></a>, and <a
    href=".four"><tt>.four</tt></a>.  These lines are more or less
    ignored in interactive mode, but provide the traditional SPICE2
    behavior in batch mode.

    <p>
    For normal analysis, output is sent to the standard output, in the
    form of ASCII plots and print output as directed by
    <tt>.plot</tt>/<tt>.print</tt> lines, plus additional information
    about the run, somewhat similar to SPICE2 but less verbose by
    default.  The batch mode output format and content can be
    controlled with the option keywords described in <a
    href="batch_vars">Batch Mode Option Variables</a>.  If the input
    file is a margin or operating range analysis file, a result file
    will be produced (as in interactive mode), however there will be
    little or no standard output other than printing from <a
    href="echo"><b>echo</b></a> commands within the analysis scripts.

    <p>
    If the <a href="-r"><tt>-r</tt></a> command line option is used
    (<tt>-r</tt> <i>filename</i>), a plot data file will be produced. 
    This will also be true if specified with the <a
    href="post"><tt>post</tt><a> option in the circuit description.

    <p>
    Batch node is non-graphical, and plots produced from
    <tt>.plot</tt> lines use the line printer format of ancient times. 
    Saving output in a rawfile or CSDF file for later viewing with
    graphical <i>WRspice</i> or another viewing program is
    recommended.

    <p>
    The input files provided may have <a
    href=".newjob"><tt>.newjob</tt></a> lines, which logically divide
    the input into two or more separate circuit decks.  Each circuit
    deck is processed in order.  This is one way to run multiple
    simulations in a single batch job.

    <p>
    There is also a "server" mode which is similar to batch mode,
    which is invoked with the <a href="-s"><tt>-s</tt></a> command
    line option.  This is intended for use in remote SPICE runs. 
    Input is taken only from the standard input, and output is
    exclusively to the standard output.  The output is either in
    rawfile or margin analysis format, and inappropriate command line
    options such as <a href="-r"><tt>-r</tt></a>, <a
    href="-b"><tt>-b</tt></a> are ignored.  There is probably no
    reason for a user to invoke this mode directly.

    <h2>Scripts and Batch Mode</a>

    <a href="script">Scripts</a> can be written to automate a large
    number of runs on a circuit, saving the output in a sequence of
    rawfiles.  Typically this may be done in the background, using
    <i>WRspice</i> in batch mode.  This section addresses some of the
    subtleties of using scripts in batch mode.

    <p>
    Any script, or circuit file containing a script, can be sourced by
    <i>WRspice</i> when started in batch mode (<tt>-b</tt> option
    given).  However, the batch mode behavior will not be evident
    unless 1) the sourced file (and any inclusions) contains a circuit
    description, and 2) no analysis command is run on the circuit from
    a <tt>.control</tt> block in the same file (plus inclusions). 
    That is, after executing the <tt>.control</tt> lines, if
    <i>WRspice</i> finds that an analysis has already been run, such
    as from a <b>tran</b> command in the <tt>.control</tt> block,
    <i>WRspice</i> will simply exit rather than run the circuit again
    in batch mode.  Here, by "batch mode", we mean the usual plots,
    prints, and other data output that would occur for a pure circuit
    file.  When the circuit was run from the <tt>.control</tt> block,
    all of this output is absent, and <tt>.plot</tt>, <tt>.print</tt>
    and similar lines are ignored as in interactive mode.

    <p>
    If the input file contains a circuit description, recall that an
    <tt>.exec</tt> block in the same (logical) file will be executed
    before the circuit is parsed, and therefor can be used to set
    shell variables which can affect the circuit.  For example:
    <blockquote><tt>
    * RC Test<br>
    <br>
    R1 1 0 1k<br>
    c1 1 0 $cval<br>
    i1 0 1 pulse 0 1m 10p 10p<br>
    .plot tran v(1)<br>
    .tran 10n 1u<br>
    <br>
    .exec<br>
    set cval="1n"<br>
    .endc
    </tt></blockquote>

    <p>
    The circuit will run in batch mode, with the capacitance value
    provided from the <tt>.exec</tt> script.  This example is trivial,
    but conceptually the <tt>.exec</tt> script can be far more
    elaborate, configuring the circuit according to an external data
    file, for example.

    <p>
    Often, it is more convenient to provide our own analysis control
    in the input file.  For example, add a trivial <tt>.control</tt>
    block to the example above.
    <blockquote><tt>
    * RC Test<br>
    <br>
    R1 1 0 1k<br>
    c1 1 0 $cval<br>
    i1 0 1 pulse 0 1m 10p 10p<br>
    .plot tran v(1)<br>
    .tran 10n 1u<br>
    <br>
    .exec<br>
    set cval="1n"<br>
    .endc<br>
    .control<br>
    run<br>
    .endc
    </tt></blockquote>

    <p>
    When run with the <tt>-b</tt> option, there is no "batch mode"
    output.  Further, if the <tt>-r</tt> option was used to generate a
    plot data file, the file would not be created.  The presence of an
    analysis command ("<tt>run</tt>") in the <tt>.control</tt> block
    inhibits the "batch mode" behavior.  The analysis was run, but we
    forgot to save any data.  One must add an explicit <a
    href="write"><b>write</b></a> command to save vectors to a file
    for later review.  One could also add <a
    href="print"><b>print</b></a> and <a href="plot"><b>plot</b></a>
    commands.  Since there is no graphics, the <b>plot</b> command
    reverts to the <a href="asciiplot"><b>asciiplot</b></a> as used in
    batch mode output, so is not of much value.  Note that the
    <b>plot</b> command and <tt>.plot</tt> control line have similar
    but different syntax, one should avoid confusing the two.

    <p>
    Again, our example is trivial, but the <tt>.control</tt> block can
    implement complex procedures and run sequences, provide
    post-simulation data manipulation, and perform other tasks.

    <p>
    At the start of every analysis command execution, the circuit is
    reset, meaning that the input is re-parsed.  This will not happen
    with the first analysis command found in a <tt>.control</tt>
    block, as the circuit is already effectively in the reset state. 
    However, on subsequent analysis commands, the <tt>.exec</tt> block
    will be re-executed, and the circuit will be re-parsed.  Chances
    are, if we are running more than one simulation, we would like to
    change the parameter value.  Consider the example:
    <blockquote><tt>
    * RC Test<br>
    <br>
    R1 1 0 1k<br>
    c1 1 0 $cval<br>
    i1 0 1 pulse 0 1m 10p 10p<br>
    .tran 10n 1u<br>
    <br>
    .exec<br>
    if $?cval = 0<br>
    &nbsp;&nbsp;set cval="1n"<br>
    endif<br>
    .endc<br>
    .control<br>
    run<br>
    write out1n.raw<br>
    set cval="2n"<br>
    run<br>
    write out2n.raw<br>
    .endc
    </tt></blockquote>

    <p>
    We are now running two transient analyses, with different
    capacitance values.  The first change is within the <tt>.exec</tt>
    block.  The <b>set</b> command will be applied only if the
    <tt>cval</tt> variable is unset, i.e., it will be set once only,
    when the file is first read.  Instead, ahead of the second
    <b>run</b> command in the <tt>.control</tt> block, we use the
    <b>set</b> command to provide a new value for <tt>cval</tt>.  This
    will update the circuit as the circuit is re-parsed in the second
    <b>run</b> command.  Without the change to the <tt>.exec</tt>
    block, the evaluation of the <tt>.exec</tt> block in the second
    <b>run</b> command would override our new <tt>cval</tt> value.

!! useriface.tex 091822
!!KEYWORD
loadable
!!TITLE
Loadable Device Modules
!!HTML
    It is possible to load device models into <i>WRspice</i> at run
    time, through use of "loadable device modules".  These are
    dynamically loaded libraries containing the device model
    description in a form which can be read into a running
    <i>WRspice</i> process.  This capability opens up some interesting
    possibilities for future versions of <i>WRspice</i> in how new
    device models are distributed.  It also gives the user, at least
    in principle, the ability to generate and use custom device models
    in <i>WRspice</i>.  Support for this important new feature is
    available in all releases.

    <p>
    Loadable device modules are most often created by translating and
    compiling <a href="veriloga">Verilog-A</a> compact model descriptions,
    though it is also possible to write C/C++ code directly.

    <p>
    Loadable device modules are specific to a particular release
    number of <i>WRspice</i>, and to the operating system.  Since the
    interface may change, user-created loadable modules need to be
    rebuilt for new releases of <i>WRspice</i>.  This may be relaxed
    in future releases, when the interface stabilizes.

    <p>
    Loadable device modules can be loaded into <i>WRspice</i> in two
    ways.

    <ol>
    <li>On startup, <i>WRspice</i> will look for loadable modules in
    the directories listed in the <a
    href="modpath"><tt>modpath</tt></a> variable, or, if that variable
    is not set, in the <tt>devices</tt> directory under the
    <tt>startup</tt> directory (i.e.,
    <tt>/usr/local/xictools/wrspice/startup/devices</tt> if installed
    in the default location).  Modules found will be loaded
    automatically by default.

    <p>
    If either of the <a href="-m"><tt>-m</tt></a> 
    or <a href="-mnone"><tt>-mnone</tt></a> command line options is given,
    or if the <a href="nomodload"><tt>nomodload</tt></a> variable is
    set in the <a href="startup_files"><tt>.wrspiceinit</tt></a> file,
    the automatic device loading will not be done.

    <li>The <a href="devload"><b>devload</b></a> command can be used to
    load a module from the command prompt or from a script.  The
    syntax is
    <blockquote>
      <tt>devload</tt> [<i>path_to_loadable_module</i>]
    </blockquote>

    The argument can also be a directory containing loadable modules,
    all of which would be loaded by the command.

    <p>
    The "<tt>devload all</tt>" command will load all known modules,
    as when <i>WRspice</i> starts.

    <p>
    If no argument is given, a list of the presently loaded modules
    is printed.
    </ol>

    <p>
    Once a module is loaded, it can't presently be unloaded.  The file
    can be re-loaded, however, so if a module is modified and rebuilt,
    it can be loaded again to update the running <i>WRspice</i>.

    <p>
    There are two ways to reference a loaded device model.
    <ol>
    <li>By traditional SPICE model level and name.<br>
    There are traditional model names in SPICE, which often provide
    differentiation of device polarity.  These are names like
    "<tt>npn</tt>" and "<tt>pnp</tt>" for a BJT device, and
    "<tt>nmos</tt>" and "<tt>pmos</tt>" for MOSFETs.  Other devices
    will use the key character as the model name, The SPICE input file
    will include lines like
    <blockquote>
    <tt>.model mynpn npn level=100 ...</tt><br>
    <tt>.model nch nmos level=101 ...</tt><br>
    <tt>.model sxx s level=2 ...</tt>
    </blockquote>
    Every device model must have a unique <tt>level</tt> value (an
    integer) for its type.  If a module is loaded that has a
    conflicting level, a warning is issued.  If the conflict is with a
    built-in model, the built-in model will always have precedence,
    and the loaded model will not be accessible.

    <p>
    <li>By model name.<br>
    Every loadable module has a given model name.  Further, device
    models of dual-polarity devices have a parameter that sets the
    device polarity.  This is defined in the model code, but most
    models have standardized on a parameter named "<tt>type</tt>"
    which is set to 1 for n-type and -1 for p-type.

    <p>
    The model can be referenced by name, for example
    <blockquote>
    <tt>.model mynpn hicum2 type=1 level=8 ...</tt><br>
    <tt>.model nch bsim6 type=1 level=80 ...</tt>
    </blockquote>
    If the device has a level value different from 1, a matching level
    parameter must be defined in the .model line.  <i>WRspice</i> does
    not check for a unique name, as the level parameter should enforce
    uniqueness.
    </ol>

    <p>
    The <tt>devkit</tt> directory in the <i>WRspice</i> installation
    location (<tt>/usr/local/xictools/wrspice</tt> is the
    default) will provide the tools needed to build loadable device
    modules.

    <h2>Creating Loadable Modules from Verilog-A</h2>

    <i>WRspice</i> provides support for building loadable modules
    from Verilog-A model source.  Many new compact device models have
    been released in this format, as it is (theoretically) portable to
    all simulators.  Most commercial simulators now have this
    capability.

    <p>
    To build modules from Verilog-A source, the Whiteley Research
    version of the open-source <tt>adms-2.3.x</tt> package must be
    installed on the system.  This is included in the <i>XicTools</i>
    packages and source.  The <i>XicTools</i> version of <tt>adms</tt>
    contains enhancements and bug fixes for use with <o>WRspice</i>,
    and should be used in preference to other versions of this
    software.

    <p>
    The <tt>devkit/README</tt> file provides instructions on how to
    build a module, and there are several examples.  Pre-built modules
    are provided.  These can be loaded into <i>WRspice</i> and used.

    <h2>Requirements</h2>

    In order to build loadable device modules from Verilog-A, the
    following requirements must be met.

    <ol>
    <li>The user's computer must contain the Gnu C/C++ compiler and the
    regular set of program development tools.  Apple users are advised to
    install Apple's XCode program development environment, which is a free
    (but huge) download from Apple.  It is recommended that you set up a
    build environment as described in the <tt>README</tt> file at the top level of
    the <i>XicTools</i> source tree.

    <p>
    <li>The compiler version used to build modules must be compatible with
    the version used to build <i>WRspice</i>.  Incompatibility may be
    manifested in various ways:
    <ul>
    <li>The module fails to load, with an error message.
    <li>The module loads, but with warnings.
    <li>The module loads, but causes program instability when used.
    </ul>

    <p>
    That being said, I haven't noticed any problems, even in the case
    of using different major versions to compile the module and to
    compile the program, but this can not be counted on.  The safest
    approach is to build <i>WRspice</i> from source, which should not
    be hard since the build environment is already set up.

    <p>
    <li>The <i>XicTools</i> version of the ADMS translator must be
    installed.  This is available as a package and as part of the
    source code for <i>XicTools</i>.

    <p>
    <li>The procedure to build the example modules is simple. 
    However, to successfully build an arbitrary module will probably
    require expertise in C++ coding/program building, Verilog-A
    syntax, and possibly the ADMS language, if the module does not
    build or work properly initially.
    </ol>

    <h2>How It Works</h2>

    The ADMS program reads the Verilog-A file, and builds a
    representation of the file logic in memory.  A set of XML scripts
    access this tree and generate the C++ code to describe the device
    functionality.  The C++ files are then compiled into a loadable
    module (shared library) which can be loaded into <i>WRspice</i>.

    <p>
    <i>WRspice</i> can load device modules in two ways.  On program
    startup, any device modules found in the <tt>devices</tt>
    sub-directory in the startup directory (typically
    <tt>/usr/local/xictools/wrspice/startup/devices</tt>) will be
    loaded.  While running, the <i>WRspice</i> <a
    href="devload"><b>devload</b></a> command can be used to load a
    module, with the command argument being the path to the module. 
    If no argument is given, a list of the modules currently loaded is
    printed.

    <h2>The ADMS Scripts</h2>

    The scripts which control the interpretation of the Verilog-A
    source during translation into C++ reside in the <tt>admst</tt>
    directory.  There is a fairly steep learning curve in gaining
    proficiency with the language and logic of these scripts, but they
    can in theory be modified by the user.  In fact, the
    <tt>wrspiceVersion.xml</tt> file provides some user-customization
    switches.

    <p>
    Some of the features provided by the <i>WRspice</i> script set,
    that are not available in the script sets available for
    many/most/all other simulators, are the following:

    <ol>
    <li>Rigorous automatic partitioning of static and dynamic
        contribution terms, as well as noise terms.
    <li>Support for potential nature contributions (<tt>V()
        &#60;+</tt> ...), and automatic node collapsing when possible.
    <li>Support for optional ports and the <tt>$port_connected</tt>
        call.
    <li>Support for the <tt>idt</tt> (time integration) operator, and
        most other system functions.
    <li>Does not require adms-specific format extensions, but will use
        them if found.
    <li>Full computation of second-derivative terms.
    <li>Full support for noise analysis in <i>WRspice</i>.
    <li>A new and more efficient math package.
    <li>No "built in" fixes for common public Verilog-A models, scripts
        are intended to be completely generic.
    <li>Produces C++ code that is indented and humanly-readable.

    <h2>How to Build a Module</h2>

    If all goes according to plan, this is easy.

    <ol>
    <li>Create a fresh directory somewhere.

    <p>
    <li>Copy the <tt>Makefile</tt> from the <tt>devkit</tt> directory
    (typically <tt>/usr/local/xictools/wrspice/devkit</tt>) into the
    new directory.

    <p>
    <li>This is optional, but you may want to copy the Verilog-A
    source file (or files) into this directory as well, for
    convenience.

    <p>
    <li>Edit the top of the <tt>Makefile</tt> with a text editor.  The
    <tt>Makfile</tt> contains comments explaining what needs setting. 
    Basically, you need to set the device key letter and model level
    (as will be used in <i>WRspice</i>), a short name for the module,
    and the path to the XML scripts provided under the
    <tt>devkit</tt>.

    <p>
    <li>Type "<tt>make</tt>" at the shell prompt.  The processing may
    take a few minutes.  Some compiler warnings may appear.

    <p>
    There may be a lot of messages like:
    <blockquote>
      <tt>warning: declaration of T10 shadows a previous local</tt>
    </blockquote>
    These appear when the module code defines a variable in a block,
    and also in a lower-level block.  These should be harmless, but
    some models (<tt>bsimsoi</tt>) generate a lot of these messages.

    <p>
    Messages like
    <blockquote>
      <tt>warning: unused variable vd</tt>
    </blockquote>
    appear if a variable is declared in a block but never used.  Once
    again, these are harmless, but may represent declarations in the
    Verilog-A source that could be omitted.

    <p>
    <li>If all goes well, a loadable module will be created.  This is
    a file with a "<tt>.so</tt>" extension ("<tt>.dylib</tt>" under OS
    X, or "<tt>.dll</tt>" in Windows) with the base name the same as
    the module name that was supplied in the <tt>Makefile</tt>.  One
    should be able to load this module into <i>WRspice</i>, and access
    the device description in simulation files.
    </ol>

    <h2>Building the Examples</h2>

    The <tt>examples</tt> subdirectory contains several
    publicly-available Verilog-A models for testing and illustrating
    the procedure.  The <tt>README</tt> files provide more
    information.  You should copy the directories and their contents
    to your local directory to build the modules.  In each model
    directory, follow the procedure above.

    <p>
    Test the new loadable module.  First, verify that the loadable
    module file exists, i.e., the compile succeeded.  Then, change to
    the "<tt>tests</tt>" subdirectory, and start <i>WRspice</i>.  At
    the <i>WRspice</i> prompt, give the command
    <blockquote>
    <tt>devload ../</tt><i>module.so</i>
    </blockquote>
    where <i>module.so</i> is the actual name of the module file. 
    <i>WRspice</i> will print a "<tt>Loading device</tt> ..." message,
    and no error messages should appear.

    <p>
    Next, bring up the <b>File Selection</b> panel with the <b>File
    Select</b> button in the <b>File</b> menu.  There will be at least
    one file listed with a "<tt>.sp</tt>" or "<tt>.cir</tt>" extension,
    these are the SPICE input source files.  Click on one of these to
    select, and click on the green octagon button.  The simulation
    will run and a plot will appear.

    <p>
    Have fun!

    <h2>What if it Doesn't Work?</h2>

    There are many things that can go wrong, and it is likely that
    something will.  Most likely, the Verilog-A file contains a
    construct that either ADMS or the scripts can't handle.  The
    author of ADMS describes the translator as "alpha", but that being
    said, it seems fairly complete and stable.  The problem most
    likely resides with the XML scripts.  These were adapted to
    <i>WRspice</i> using scripts for other simulators as a starting
    point.  They will evolve to provide more complete and error-free
    translation.  As a quick look at the script text will show, they
    can be hideously complex.  The language itself is not well
    documented, though "experts" can figure it out from the
    configuration files in the ADMS installation.

!!SEEALSO
devload
devls
veriloga

!! useriface.tex 040718
!!KEYWORD
veriloga adms
!!TITLE
Support for ADMS/Verilog-A
!!HTML
    The ADMS package translates the Verilog-A model description into a
    set of C++ files, which are then compiled into a <a
    href="loadable">loadable module</a> (a shared library loaded on
    demand).

    <p>
    There may be some documentation of ADMS on the internet.  Last I
    looked, there was very little, but is included with the
    <i>XicTools</i> version of ADMS.  One should also google-up a copy
    of the Verilog-A manual, as this describes the official syntax.

    <p>
    This section is a catch-all for information about the
    <i>WRspice</i> ADMS implementation, with regard to syntax and
    features.

    <h2>1.  The "<tt>insideADMS</tt>" define</h2>

    The symbol <tt>insideADMS</tt> is defined (as if with <tt>`define
    insideADMS</tt>), and can be used to test for ADMS in the
    Verilog-A code.

    <h2>2. The ADMS "attributes"</h2>

    This is a syntax extension to Verilog-A supported by ADMS.  It
    allows additional information in parameter and variable
    declarations to be passed to the simulator.

    <p>
    <b>Examples</b>:<br>
    <tt>parameter real c10 = 2e-30 from [0:1] (* info="GICCR constant"
     unit="A^2s" *);</tt><br>
    <tt>real outTheta   (* info="Theta" *);</tt>

    <p>
    The attributes are delimited by <tt>(* ...  *)</tt> just ahead of
    the line-terminating semicolon.  The content consists of
    <i>keyword</i>=<i>value</i> terms, separated by white space.  The
    <i>value</i> is taken as a literal string, and should be
    double-quoted if it contains white space.  The <i>keyword</i> can
    be any token, but only certain keywords are recognized by ADMS.

    <dl>
    <dt><tt>info=</tt>"<i>string describing the parameter or variable</i>"<dd>
    The string will be used in the <i>WRspice</i> <a
    href="show"><b>show</b></a> command and perhaps elsewhere.
    </dl>

    <dl>
    <dt><tt>units=</tt><i>units_token</i><dd>
    This gives the units of the parameter or variable.  (I'm not sure
    that this is actually used.)
    </dl>

    <dl>
    <dt><tt>type=model</tt><dd>
    This construct indicates that the parameter should be taken as a
    model parameter, i.e., a parameter given in a <tt>.model</tt> line
    in SPICE.
    </dl>

    <dl>
    <dt><tt>type=instance</tt><dd>
    This construct indicates that the parameter should be taken as an
    instance parameter, i.e., a parameter given in a device instance
    line.
    </dl>

    <p>
    Models may use the following code to hide this construct from
    non-ADMS parsers.
    <blockquote><tt>
    `ifdef insideADMS<br>
    &nbsp;&nbsp;`define ATTR(txt) (*txt*)<br>
    `else<br>
    &nbsp;&nbsp;`define ATTR(txt)<br>
    `endif<br>
    ...<br>
    parameter real c10 = 2e-30 from [0:1] `ATTR(info="GICCR constant" unit="A^2s");<br>
    real outTheta   `ATTR( info="Theta" );
    </tt></blockquote>

    <h2>3.  Read-Only Parameters</h2>

    The presence of any attribute on a normal variable magically
    transforms that variable into a parameter which is read-only. 
    This means that it can be used to pass data out of the model
    during simulation.

    <p>
    Such variables are initialized to the starting value at the
    beginning of the simulation only.  Regular variables are
    initialized on every pass through the equation set, which occurrs
    on every Newton iteration.  The read-only parameters can therefor
    retain history from the last iteration.

    <p>
    In <i>WRspice</i>, data from these (and all) parameters can be
    obtained from the
    <tt>@</tt><i>device</i><tt>[</tt><i>parmname</i><tt>]</tt> special
    vector construct.

    <h2>4. Initialization Blocks and Global Events</h2>

    ADMS will handle the two standard global events, but only in the
    forms containing no arguments.

    <dl>
    <dt><tt>@(initial_step) begin ... end</tt><dd>
    The block is executed while computing the initial analysis point,
    in accord with the Verilog-AMS standard.  The block will be called
    for the operating point analysis (if any), all iterations.  Thus,
    it will be called multiple times, which makes it unattractive for
    use as an initializer.
    </dl>

    <dl>
    <dt><tt>@(final_step) begin ... end</tt><dd>
    The block is executed while computing the final analysis point, in
    accord with the Verilog-AMS standard.  The block will be called
    for all iterations.  It will be called after <tt>initial_step</tt>
    if both are called.
    </dl>

!!IFDEF notdef
Here's the Verilog-AMS truth table for the various forms, the forms
containing arguments are not available in ADMS.  The $analysis function
can be used in the block to provide analysis-specific code.

                      DCOP  Sweep     TRAN        AC          NOISE
                      OP    d1 d2 dN  OP  p2  pN  OP  p2  pN  OP  p2  pN
initial_step()        1     1  0  0   1   0   0   1   0   0   1   0   0
initial_step("ac")    0     0  0  0   0   0   0   1   0   0   0   0   0
initial_step("noise") 0     0  0  0   0   0   0   0   0   0   1   0   0
initial_step("tran")  0     0  0  0   1   0   0   0   0   0   0   0   0
initial_step("dc")    1     1  0  0   0   0   0   0   0   0   0   0   0
initial_step(unknown) 0     0  0  0   0   0   0   0   0   0   0   0   0
final_step()          1     0  0  1   0   0   1   0   0   1   0   0   1
final_step("ac")      0     0  0  0   0   0   0   0   0   1   0   0   0
final_step("noise")   0     0  0  0   0   0   0   0   0   0   0   0   1
final_step("tran")    0     0  0  0   0   0   1   0   0   0   0   0   0
final_step("dc")      1     0  0  1   0   0   0   0   0   0   0   0   0
final_step(unknown)   0     0  0  0   0   0   0   0   0   0   0   0   0

These SHOULD NOT be used in compact model code.  Instead, use the following:
!!ENDIF

    <dl>
    <dt><tt>@(initial_model) begin ... end</tt><dd>
    This block is run once-only before any analysis.  It can be used
    to initialize per-model parameters, such as temperature
    dependence.  This is not in the Verilog-AMS standard and may be
    particular to ADMS.
    </dl>

    <dl>
    <dt><tt>@(initial_instance) begin ... end</tt><dd>
    This block is run once-only before any analysis.  It can be used
    to initialize per-instance parameters, such as geometrical
    dependence.  This is not in the Verilog-AMS standard and may be
    particular to ADMS.
    </dl>

    <p>
    In ADMS, the "global events" are equivalent to named blocks, for
    example:

    <table border=0 cellspacing=4>
    <tr><td><tt>begin : initial_model</tt></td> <td width=40>&nbsp;</td>
      <td><tt>@(initial_model) begin</tt></td></tr>
    <tr><td>...</td><td></td><td>...</td></tr>
    <tr><td><tt>end</tt></td><td></td><td><tt>end</tt></td></tr>
    </table>

    <p>
    Either form can be used for <tt>initial_step</tt>,
    <tt>final_step</tt>, <tt>initial_model</tt>, and
    <tt>initial_instance</tt>.

    <h2>System Tasks</h2>

    <h4>1. Input/Output</h4>
                
    <dl>
    <dt>
    <tt>$display</tt>(<i>format</i>, <i>variable list</i>)<br>
    <tt>$strobe</tt>(<i>format</i>, <i>variable list</i>)<br>
    <tt>$monitor</tt>(<i>format</i>, <i>variable list</i>)<br>
    <tt>$write</tt>(<i>format</i>, <i>variable list</i>)<dd>
    These commands have the same syntax, and display text on the
    screen during simulation.  <tt>$display</tt> and <tt>$strobe</tt>
    display once every time they are executed, whereas
    <tt>$monitor</tt> displays every time one of its parameters
    changes.  The difference between <tt>$display</tt> and
    <tt>$strobe</tt> is that <tt>$strobe</tt> displays the parameters
    at the very end of the current simulation time unit rather than
    exactly when it is executed.  The format string is like that in
    C/C++, and may contain format characters.  Format characters
    include <tt>%d</tt> (decimal), <tt>%h</tt> (hexadecimal),
    <tt>%b</tt> (binary), <tt>%c</tt> (character), <tt>%s</tt>
    (string) and <tt>%t</tt> (time), <tt>%m</tt> (hierarchy level). 
    Forms like <tt>%5d</tt>, <tt>%5b</tt> etc.  would assign a field
    width of 5 when printing the item.

    <p>
    <tt>$display</tt> and <tt>$write</tt> are the same except
    <tt>$display</tt> appends a newline if the string does not have a
    trailing newline character, <tt>$write</tt> does not do this.
    </dl>

    <dl>
    <dt>
    <tt>$error</tt>(<i>format</i>, ...)<br>
    <tt>$warning</tt>(<i>format</i>, ...)<dd>
    Print a message starting with "<tt>Fatal:</tt>" or "<tt>Warning:</tt>".
    </dl>

    <dl>
    <dt>
    <tt>$fopen</tt>(<i>filename</i>)<br>
    <tt>$fclose</tt>(<i>handle</i>)<br>
    <tt>$fdisplay</tt>(<i>handle</i>, <i>format</i>, <i>variable list</i>)<br>
    <tt>$fstrobe</tt>(<i>handle</i>, <i>format</i>, <i>variable list</i>)<br>
    <tt>$fmonitor</tt>(<i>handle</i>, <i>format</i>, <i>variable list</i>)<br>
    <tt>$fwrite</tt>(<i>handle</i>, <i>format</i>, <i>variable list</i>)<dd>
    These commands write more selectively to files.

    <p>
    <tt>$fopen</tt> opens an output file and gives the open file an
    integer handle for use by the other commands.

    <p>
    <tt>$fclose</tt> closes the file and lets other programs access it.

    <p>
    In <i>WRspice</i>, there are two special handles that are automatically
    open and can't be closed.

    <blockquote>
    <table border=1 cellspacing=2 cellpadding=2>
    <tr><td>0   </td><td>Print to the pop-up error window.</td></tr>
    <tr><td>1 or &#60; 0</td><td>Print to the standard output (terminal
      window).</td></tr>
    </table>
    </blockquote>

    <p>
    <tt>$fdisplay</tt> and <tt>$fwrite</tt> write formatted data to a
    file whenever they are executed.  They are the same except
    <tt>$fdisplay</tt> appends a newline if the string does not have a
    trailing newline character, <tt>$fwrite</tt> does not do this.

    <p>
    <tt>$fstrobe</tt> also writes to a file when executed, but it
    waits until all other operations in the time step are complete
    before writing.  Thus
    <blockquote>
    <tt>initial #1 a=1; b=0; $fstrobe(hand1, a,b); b=1;</tt>
    </blockquote>
    will write write 1 1 for a and b.

    <p>
    <tt>$monitor</tt> writes to a file whenever any of its arguments
    changes.
    </dl>

    <h4>2. Simulation Control</h4>

    <dl>
    <dt><tt>$bound_step</tt>(<i>max_delta</i>)<dd>
    Limit the next time point to be <i>max_delta</i> or less from the
    present time point in transient analysis.
    </dl>

    <dl>
    <dt><tt>$finish</tt>[(<i>n</i>[, <i>type_string</i>])]<dd>
    Halt the analysis.  If integer <i>n</i> is given, it can be one of
    these values, which determine what if anything is printed.

    <blockquote>
    From the spec, this is not currently supported.
    <table border=1 cellspacing=2 cellpadding=2>
    <tr><td>0</td>  <td>Prints nothing (the default if no argument)</td></tr>
    <tr><td>1</td>  <td>Prints simulation time and location</td></tr>
    <tr><td>2</td>  <td>Prints simulation time, location, and statistics
      about the memory and CPU time used in simulation</td></tr>
    </table>
    </blockquote>

    <p>
    Verilog-AMS HDL allows an additional option string argument to be
    specified to <tt>$finish</tt> to indicate the type of the finish. 
    <i>type_string</i> can take one of three values: 
    <tt>accepted</tt>, <tt>immediate</tt> or
    <tt>current_analysis</tt>.  <tt>accepted</tt> is the default
    setting.

    <p>
    If the <i>type_string</i> is set to <tt>accepted</tt> and
    <tt>$finish</tt> is called during an accepted iteration, then the
    simulator will exit after the current solution is complete.

    <p>
    If the <i>type_string</i> is set to <tt>current_analysis</tt>
    and <tt>$finish</tt> is called during an accepted iteration, then
    the simulator terminates the current analysis and will start the
    next analysis if one requested. 

    <p>
    If the <i>type_string</i> is set to <tt>immediate</tt> and
    <tt>$finish</tt> is called during an iteration, then the
    simulation will exit immediately without the current solution
    being completed.  This is not recommended as it may leave the
    output files generated by the simulator in an undefined state.
    </dl>

    <dl>
    <dt><tt>$stop</tt>[(<i>n</i>)]<dd>
    A call to <tt>$stop</tt> during an accepted iteration causes
    simulation to be suspended at a converged timepoint.  This task
    takes an optional integer expression argument (0, 1, or 2), which
    determines what type of diagnostic message is printed.  The amount
    of diagnostic message output increases with the value of <i>n</i>,
    as shown for <tt>$finish</tt>.
    </dl>

    <h4>3.  Random Numbers</h4>

    <dl>
    <dt><tt>$random</tt>[(<i>seed</i>)]<dd>
    <tt>$random</tt> generates a random integer every time it is
    called.  If the sequence is to be repeatable, the first time one
    invokes <tt>$random</tt> it is given a numerical argument (a
    seed).  Otherwise the seed is derived from the computer clock.
    </dl>

    <dl>
    <dt>
    <tt>$rdist_uniform</tt>(<i>seed</i>, <i>start</i>, <i>end</i>[, <i>dt</i>])<br>
    <tt>$rdist_normal</tt>(<i>seed</i>, <i>mean</i>, <i>stddev</i>[, <i>dt</i>])<br>
    <tt>$rdist_exponential</tt>(<i>seed</i>, <i>mean</i>[, <i>dt</i>])<br>
    <tt>$rdist_poisson</tt>(<i>seed</i>, <i>mean</i>[, <i>dt</i>])<br>
    <tt>$rdist_chi_square</tt>(<i>seed</i>, <i>dof</i>[, <i>dt</i>])<br>
    <tt>$rdist_t</tt>(<i>seed</i>, <i>dof</i>[, <i>dt</i>])<br>
    <tt>$rdist_erlang</tt>(<i>seed</i>, <i>k</i>, <i>mean</i>[, <i>dt</i>])<dd>
    In <i>WRspice</i>, the following functions are implemented in such
    a way that they are compatible with Newton iterations and
    convergence testing.  Logically, a separate random value is
    obtained at each point of a grid in time that covers the
    simulation interval.  The actual random number used is
    interpolated from this grid at the present simulation time.  Thus,
    the "random" function becomes deterministic, and simulations that
    include output from the random generator will converge and iterate
    normally.  This can be used to model Johnson noise in the time
    domain, for example.

    <p>
    Each has an additional optional "<i>dt</i>" argument which if
    given is taken as the time period of the random number grid.  If
    not given, the <i>TStep</i> from the running transient analysis is
    assumed.  This value has significance only in transient analysis. 
    During other types of analysis, calls to these functions will
    return a single random value, generated on the first call.

    <p>
    Note that during transient analysis, the seed value should not
    change, or non-convergence can result.

    <p>
    The following rules apply to these functions.
    <ul>
    <li>All arguments to the system functions are real values, except
    for <i>seed</i> (which is defined by <tt>$random</tt>).  For the
    <tt>$rdist_exponential</tt>, <tt>$rdist_poisson</tt>,
    <tt>$rdist_chi_square</tt>, <tt>$rdist_t</tt>, and
    <tt>$rdist_erlang</tt> functions, the arguments <i>mean</i>,
    <i>dof</i>, and <i>k</i> shall be greater than zero (0).

    <p>
    <li>Each of these functions returns a pseudo-random number whose
    characteristics are described by the function name, e.g.,
    <tt>$rdist_uniform</tt> returns random numbers uniformly
    distributed in the interval specified by its arguments.

    <p>
    <li>For each system function, the <i>seed</i> argument shall be an
    integer.  If it is an integer variable, then it is an inout
    argument; that is, a value is passed to the function and a
    different value is returned.  The variable is initialized by the
    user and only updated by the system function.  This ensures the
    desired distribution is achieved upon successive calls to the
    system function.  If the <i>seed</i> argument is a parameter or
    constant, then the system function does not update the value. 
    This makes the system function useable for parameter
    initialization.  <i>WRspice</i> doesn't handle this.

    <p>
    <li>The system functions shall always return the same value given
    the same seed.  This facilitates debugging by making the operation
    of the system repeatable.  In order to get different random values
    when the seed argument is a parameter, the user can override the
    parameter.

    <p>
    The two paragraphs above are difficult to follow.  In
    <i>WRspice</i>, if the same seed value is used for all calls, the
    sequence of values is repeatable.  A call with a different seed
    will reset the internal random number generator and a different
    sequence would be returned.  The system functions never reset the
    seed.  There is only one seed in <i>WRspice</i>, so if any
    function call changes the seed, all subsequent random number calls
    are affected.

    <li>All functions return a real value.

    <p>
    <li>In <tt>$rdist_uniform</tt>, the <i>start</i> and <i>end</i>
    arguments are real inputs which bound the values returned.  The
    <i>start</i> value shall be smaller than the <i>end</i> value.

    <p>
    <li>The <i>mean</i> argument used by <tt>$rdist_normal</tt>,
    <tt>$rdist_exponential</tt>, <tt>$rdist_poisson</tt>, and
    <tt>$rdist_erlang</tt> is a real input which causes the average
    value returned by the function to approach the value specified. 

    <p>
    <li>The <i>standard_deviation</i> argument used by
    <tt>$rdist_normal</tt> is a real input, which helps determine the
    shape of the density function.  Using larger numbers for
    <i>standard_deviation</i> spreads the returned values over a wider
    range.  Using a mean of zero (0) and a standard deviation of one
    (1), <tt>$rdist_normal</tt> generates Gaussian distribution.

    <p>
    <li>The <i>dof</i> (degree of freedom) argument used by
    <tt>$rdist_chi_square</tt> and <tt>$rdist_t</tt> is a real input,
    which helps determine the shape of the density function.  Using
    larger numbers for <i>dof</i> spreads the returned values over a
    wider range. 
    </ul>
    </dl>


    <h4>3.  Other System Functions Recognized in ADMS/<i>WRspice</i></h4>

    <dl>
    <dt>
    <tt>absdelay</tt>(<i>arg1</i>, <i>arg2</i>)<br>
    <tt>delay</tt>(<i>arg1</i>, <i>arg2</i>)<dd>
    Recognized but not implemented.
    </dl>

    <dl>
    <dt>
    <tt>$abstime</tt><br>
    <tt>$realtime</tt><dd>
    Returns the simulation time, the names are equivalent.
    </dl>

    <dl>
    <dt><tt>analysis</tt>(<i>keyword</i>)<dd>
    Return nonzero if the analysis type represented by the
    <i>keyword</i> is being performed.  The <i>keyword</i> is one of:
    <dl>
    <dt><tt>ac</tt><dd>
    True when running AC analysis.
    </dl>

    <dl>
    <dt><tt>dc</tt><dd>
    True when running DC sweep or operating point analysis.
    </dl>

    <dl>
    <dt><tt>noise</tt><dd>
    True when running noise analysis.
    </dl>

    <dl>
    <dt><tt>tran</tt><dd>
    True when running transient analysis.
    </dl>

    <dl>
    <dt><tt>ic</tt><dd>
    True in the initial-condition analysis that preceeds a transient
    analysis.
    </dl>

    <dl>
    <dt><tt>static</tt><dd>
    Any equilibrium point calculation, including a DC analysis as well
    as those that precede another analysis, such as the DC analysis
    that precedes an AC or noise analysis, or the IC analysis that
    precedes a transient analysis.
    </dl>

    <dl>
    <dt><tt>nodeset</tt><dd>
    The phase during an equilibrium point calculation where node
    voltages are forced.
    </dl>
    </dl>

    <dl>
    <dt><tt>ceil</tt>(<i>x</i>)<dd>
    Return the integer value greater than or equal to the argument.
    </dl>

    <dl>
    <dt><tt>ddt</tt>(<i>expression</i>[, <i>ignored</i>])<dd>
    Return the time derivative, any second argument is ignored.
    </dl>

    <dl>
    <dt><tt>ddx</tt>(<i>variable</i>, <i>probe</i>)<dd>
    Return the partial derivative of the variable with respect to the
    probe.
    </dl>

    <dl>
    <dt><tt>flicker_noise</tt>(<i>a</i>, <i>b</i>[, <i>c</i>])<dd>
    Probably not implemented.
    </dl>

    <dl>
    <dt><tt>floor</tt>(<i>x</i>)<dd>
    Return the integer value less than or equal to the argument.
    </dl>

    <dl>
    <dt><tt>$given</tt>(<i>model_or_instance_parameter</i>)<dd>
    Return nonzero if the parameter was given, same as
    <tt>$param_given</tt>.
    </dl>

    <dl>
    <dt><tt>idt</tt>(<i>expression</i>, <i>icval</i>, <i>reset</i>[,
     <i>ignored</i>)<dd>
    Return the time integral of <i>expression</i> using the initial
    value <i>icval</i>.  If <i>reset</i> is nonzero, instead zero the
    internal integration history.
    </dl>

    <dl>
    <dt><tt>$mfactor</tt><dd>
    Return the device <tt>M</tt> scale factor if the model was built
    for this support, otherwise 1.0.
    </dl>

    <dl>
    <dt><tt>$model</tt><dd>
    Expands to the name of the current device model.
    </dl>

    <dl>
    <dt><tt>$nominal_temperature</tt><dd>
    Return the nominal temperature in Kelvin.
    </dl>

    <dl>
    <dt><tt>$instance</tt><dd>
    Expands to the name of the currenly scoped instance, or "???".
    </dl>

    <dl>
    <dt><tt>$param_given</tt>(<i>model_or_instance_parameter</i>)<dd>
    Return nonzero if the parameter was given, same as <tt>$given</tt>.
    </dl>

    <dl>
    <dt><tt>$port_connected</tt>(<i>port_name</i>)<dd>
    Return nonzero if the named port is connected externally.
    </dl>

    <dl>
    <dt>
    <tt>$realtime</tt><br>
    <tt>$abstime</tt><dd>
    Return the simulation time, the names are equivalent.
    </dl>

    <dl>
    <dt><tt>$scale</tt><dd>
    Return 1.0, no scaling in <i>WRspice</i>.
    </dl>

    <dl>
    <dt><tt>$simparam</tt>(<i>string</i>[, <i>expression</i>])<dd>
    This queries the simulator for a simulation parameter named in
    <i>string</i>.  If <i>string</i> is known, its value is returned. 
    If string is not known, and the optional <i>expression</i> is not
    supplied, then an error is generated.  If the optional
    <i>expression</i> is supplied, its value is returned if
    <i>string</i> is not known and no error is generated. 

    <p>
    <tt>$simparam</tt>() shall always return a real value; simulation
    parameters that have integer values shall be coerced to real. 
    There is no fixed list of simulation parameters.  However,
    simulators shall accept the strings below to access commonly-known
    simulation parameters, if they support the parameter.  Simulators
    can also accept other strings to access the same parameters.

    <p>
    The first group below comes from the Verilog-AMS specification.

    <p>
    <dl>
    <dt><tt>gdev</tt><dd>
    Additional conductance to be added to nonlinear branches for
    conductance homotopy convergence algorithm.  Returns the
    <i>WRspice</i> <a href="gmin"><tt>gmin</tt></a> parameter.
    </dl>

    <dl>
    <dt><tt>gmin</tt><dd>
    Minimum conductance placed in parallel with nonlinear branches,
    returns the <i>WRspice</i> <a href="gmin"><tt>gmin</tt></a>
    parameter.
    </dl>

    <dl>
    <dt><tt>imax</tt><dd>
    Branch current threshold above which the constitutive relation
    of a nonlinear branch should be linearized.  Returns 1.0.
    </dl>

    <dl>
    <dt><tt>imelt</tt><dd>
    Branch current threshold indicating device failure.  Returns 1.0.
    </dl>

    <dl>
    <dt><tt>iteration</tt><dd>
    Iteration number of the analog solver, returns an internal
    iteration count.
    </dl>

    <dl>
    <dt><tt>scale</tt><dd>
    Scale factor for device instance geometry parameters.  Returns 1.0.
    </dl>

    <dl>
    <dt><tt>shrink</tt><dd>
    Optical linear shrink factor.  Returns 1.0.
    </dl>

    <dl>
    <dt><tt>simulatorSubversion</tt><dd>
    The simulator sub-version.  Returns, e.g., 5 for <i>WRspice</i>-4.3.5.
    </dl>

    <dl>
    <dt><tt>simulatorVersion</tt><dd>
    The simulator version.  Retursn, e.g., 4.3 for <i>WRspice</i>-4.3.5.
    </dl>

    <dl>
    <dt><tt>sourceScaleFactor</tt><dd>
    Multiplicative factor for independent sources for source stepping
    homotopy convergence algorithm.  <i>WRspice</i> returns the
    scaling value from source stepping.
    </dl>

    <dl>
    <dt><tt>tnom</tt><dd>
    Default value of temperature in Celsius at which model parameters were
    extracted (same as <tt>$nominal_temperature</tt>).
    </dl>

    <p>
    The following group has unknown origin.

    <dl>
    <dt><tt>checkjcap</tt><dd>
    Returns 1.0.
    </dl>

    <dl>
    <dt><tt>maxmosl</tt><dd>
    Returns 1.0.
    </dl>

    <dl>
    <dt><tt>maxmosw</tt><dd>
    Returns 1.0.
    </dl>

    <dl>
    <dt><tt>minmosl</tt><dd>
    Returns 1.0e-12.
    </dl>

    <dl>
    <dt><tt>minmosw</tt><dd>
    Returns 1.0e-12.
    </dl>

    <p>
    The final group is implemented in <i>WRspice</i>, perhaps uniquely.

    <dl>
    <dt><a href=".tran"><tt>tstep</tt></a><dd>
    The current transient analysis output time increment.
    </dl>

    <dl>
    <dt><a href=".tran"><tt>tstart</tt></a><dd>
    The current start time for transient analysis output.
    </dl>

    <dl>
    <dt><a href=".tran"><tt>tstop</tt></a><dd>
    The current final time point in transient analysis.
    </dl>

    <dl>
    <dt><tt>delta</tt><dd>
    The current internal time step in transient analysis.
    </dl>

    <dl>
    <dt><a href="delmin"><tt>delmin</tt></a><dd>
    The minimum allowable transient analysis time step.
    </dl>

    <dl>
    <dt><tt>delmax</tt><dd>
    The maximum allowable transient analysis time step.
    </dl>

    <dl>
    <dt><a href="abstol"><tt>abstol</tt></a><dd>
    The absolute tolerance parameter.
    </dl>

    <dl>
    <dt><a href="reltol"><tt>reltol</tt></a><dd>
    The relative tolerance parameter.
    </dl>

    <dl>
    <dt><a href="chgtol"><tt>chgtol</tt></a><dd>
    The charge tolerance parameter.
    </dl>

    <dl>
    <dt><a href="vntol"><tt>vntol</tt></a><dd>
    The voltage tolerance parameter.
    </dl>

    <dl>
    <dt><tt>predictor</tt><dd>
    Nonzero when in the first iteration of a time point.
    </dl>

    <dl>
    <dt><tt>smallsig</tt><dd>
    Nonzero when loading small-signal values in AC analysis.
    </dl>

    <dl>
    <dt><tt>dcphasemode</tt><dd>
    Nonzero if using phase-mode DC analysis, may be true when Josephson
    junctions are present.
    </dl>

    <dl>
    <dt><a href="dphimax"><tt>dphimax</tt></a><dd>
    Returns the maximum phase change for internal time point for
    sinusoidal sources and Josephson junctions.
    </dl>
    </dl>

    <dl>
    <dt><tt>$temperature</tt><dd>
    Returns the circuit ambient temperature in Kelvin.
    </dl>

    <dl>
    <dt><tt>$vt</tt>[(<i>temperature_expression</i>)]<dd>
    Returns the thermal voltage KT/q using the argument for temerature,
    or the ambient temperature if no argument is given.
    </dl>

    <h4>WRspice C/C++ Bridge Function</h4>

    <dl>
    <dt><tt>cfunc</tt>(<i>funcname</i>, <i>arg1</i>, ..., <i>argN</i>)<dd>
    The <tt>cfunc</tt> pseudo-function allows arbitrary C/C++ function
    calls to be made from the model code.

    <p>
    The return value can be used in an assignment.  In the C++ files,
    the construct maps to <i>funcname</i>(<i>arg1</i>, ...,
    <i>argN</i>).

    <p>
    This can be used to, for example, make available special math
    functions callable from Verilog-A.  Be advised that this can be
    unsafe to use in model code, as the derivative is not included in
    the Jacobian, which can lead to convergence problems.  However, if
    such functions are used only for initialization, use is safe.

    <p>
    To use this facility, the <tt>HEADER</tt> variable in the
    <tt>Makefile</tt> should be redefined to yes, and the user should
    create an include file that contains (perhaps through another
    include) prototypes of the functions called using <tt>cfunc</tt>. 
    This file must be named <i>MODULE</i><tt>extra.h</tt>, where
    <i>MODULE</i> is the short name also provided from the
    <tt>Makefile</tt>.

    <p>
    The header file must also be modified to link the library
    containing the function implementations to the loadable module. 
    The user is expected to know how to do this.
    </dl>

!!SEEALSO
loadable
veriloga

!!REDIRECT vlad         refs#vlad
!!REDIRECT sheu         refs#sheu
!!REDIRECT pierret      refs#pierret
!!REDIRECT jeng         refs#jeng
!!REDIRECT park         refs#park
!!REDIRECT szeto        refs#szeto
!!REDIRECT parker       refs#parker
!!REDIRECT cheng        refs#cheng
!!REDIRECT saleh        refs#saleh
!!REDIRECT statz1       refs#statz1
!!REDIRECT statz2       refs#statz2
!!REDIRECT jewett       refs#jewett
!!REDIRECT whiteley     refs#whiteley
!!REDIRECT roy          refs#roy
!!REDIRECT lin          refs#roy
!!REDIRECT tolpygo      refs#tolpygo

!! bib.tex.tex 041415
!!KEYWORD
refs
!!TITLE
References
!!HTML 
    <blockquote>
    <ol>
    <li> <a name="vlad"></a>
    A. Vladimirescu and  S.  Liu,  "The  Simulation  of  MOS
    Integrated  Circuits  Using SPICE2", ERL Memo No. ERL M80/7,
    Electronics Research Laboratory, University  of  California,
    Berkeley, Oct. 1980.

    <p>
    <li> <a name="sheu"></a>
    B. J. Sheu, D. L. Scharfetter, and  P.  K.  Ko,  "SPICE2
    Implementation of BSIM" ERL Memo No. ERL M85/42, Electronics
    Research Laboratory, University of California, Berkeley, May
    1985.

    <p>
    <li> <a name="pierret"></a>
    J. R. Pierret, "A MOS Parameter Extraction  Program  for
    the  BSIM Model" ERL Memo Nos. ERL M84/99 and M84/100,
    Electronics  Research  Laboratory,  University  of   California,
    Berkeley, Nov. 1984.

    <p>
    <li> <a name="jeng"></a>
    Min-Chie Jeng, "Design and Modeling of Deep-Submicrometer
    MOSFETs", ERL Memo Nos.  ERL M84/99 and ERL M90/90, Electronics
    Research Laboratory, University of California, Berkeley, October
    1990.

    <p>
    <li> <a name="park"></a>
    Soyeon Park, "Analysis and SPICE implementation of High
    Temperature Effects on MOSFET", Master's Thesis, University of
    California, Berkeley, December 1986.

    <p>
    <li> <a name="szeto"></a>
    Clement Szeto, "Simulator of Temperature effects in MOSFETs
    (STEIM)", Master's Thesis, University of California, Berkeley, May
    1988.

    <p>
    <li> <a name="parker"></a>
    A.  E.  Parker and D.  J.  Skellern, "An Improved FET Model
    for Computer Simulators", IEEE Trans.  CAD, vol.  9, no.5, pp. 
    551-553, May 1990.

    <p>
    <li> <a name="cheng"></a>
    Y.  Cheng, M.  Chan, K.  Hui, M-C Jeng, Z.  Liu, J.  Huang, K. 
    Chen, J.  Chen, R.  Tu, P.  Ko and C.  Hu, "BSIM3v3 Manual",
    Department of Electrical Engineering and Computer Sciences,
    University of California, Berkeley, 1996.

    <p>
    <li> <a name="saleh"></a>
    R.  Saleh and A.  Yang, Editors, "Simulation and Modeling,
    IEEE Circuits and Devices", vol.  8, no.  3, pp.  7-8 and 49, May
    1992.

    <p>
    <li> <a name="statz1"></a>
    H. Statz et al.,"GaAs FET Device and  Circuit  Simulation
    in  SPICE", Internal memorandum, Raytheon Research Division,
    Lexington, Mass., 1985.

    <p>
    <li> <a name="statz2"></a>
    H.  Statz et al., "GaAs FET Device and Circuit Simulation in
    SPICE", IEEE Transactions on Electron Devices, Vol.  34, Number 2,
    February 1987 pp.  160-169.

    <p>
    <li> <a name="jewett"></a>
    R.  E.  Jewett, "Josephson Junctions in SPICE2G5", ERL Memo,
    Electronics Research Laboratory, University of California,
    Berkeley, 1982. 

    <p>
    <li> <a name="whiteley"></a>
    S.  R.  Whiteley, "Josephson Junctions in SPICE3", IEEE Trans. 
    Magn., vol.  27, no.  2, pp.  2902-2905, March 1991. 

    <p>
    <li> <a name="roy"></a>
    J. S.  Roychowdhury and D. O.  Pederson, "Efficient Transient
    Simulation of Lossy Interconnect", Proc.  DAC, pp. 740-745, 1991.

    <p>
    <li> <a name="lin"></a>
    Shen Lin and Ernest S. Kuh, "Transient Simulation of Lossy
    Interconnect", Proc. DAC, pp 81-86, 1992.

    <p>
    <li> <a name="jeffery"></a>
    M. Jeffery, P. Y. Xie, S. R. Whiteley, and T. Van Duzer,
    "Monte Carlo and thermal noise analysis of ultra-high-speed high
    temperature superconductor digital circuits,"
    IEEE Trans. Applied Superconductivity,
    vol. 9, no. 2, pt. 3, pp. 4095-4098, June 1999.

    <p>
    <li> <a name="tolpygo"></a>
    Sergey K. Tolpygo, Vladimir Bolkhovsky, T. J. Weir, Alex Wynn,
    D. E. Oats, L. M. Johnson, and M. A. Gouker, "Advanced
    Fabrication Processes for Superconducting Very Large-Scale
    Integrated Circuits", IEEE Trans. Appl. Superconductivity vol. 26,
    no. 3, 1100110, 2016.<br>

    Sergey K. Tolpygo, Vladimir Bolkovsky, Scott Zarr, T. J. Weir,
    Alex Wynn, Alexandra L. Day, L. M. Johnson, and M. A. Gouker,
    "Properties of Unshunted and Resistively Shunted Nb/AlO<sub>X</sub>-Al/Nb
    Josephson Junctions With Critical Current Densities From 0.1 to 1
    mA/&mu;m<sup>2</sup>", IEEE Trans.  Appl.  Superconductivity, vol. 
    27, no.  4, 1100815, 2017. 

    </ol>
    </blockquote>
 
!! appendix.tex 012409
!!KEYWORD
rawfilefmt
!!TITLE
Rawfile Format
!!HTML 
    Rawfiles produced and read by <i>WRspice</i> have either an ASCII
    or a binary format.  ASCII format is the preferred format for
    general use, as it is hardware independent and easy to modify,
    though the binary format is the most economical in terms of space
    and speed of access.

    <p>
    The ASCII format consists of lines or sets of lines introduced by
    a keyword.  The <tt>Title</tt> and <tt>Date</tt> lines should be
    the first in the file and should occur only once.  There may be
    any number of plots in the file, each one beginning with the
    <tt>Plotname</tt>, <tt>Flags</tt>, <tt>No.  Variables</tt>,
    <tt>No.  Points</tt>, <tt>Variables</tt>, and <tt>Values</tt>
    lines.  The <tt>Command</tt> and <tt>Option</tt> lines are
    optional and may occur anywhere between the <tt>Plotname</tt> and
    <tt>Values</tt> lines.  Note that after the <tt>Variables</tt>
    keyword there must be <i>numvars</i> "declarations" of outputs,
    and after the <tt>Values</tt> keyword, there must be
    <i>numpoints</i> lines, each consisting of <i>numvars</i> values. 
    To clarify this discussion, one should create an ASCII rawfile
    with <i>WRspice</i> and examine it.

    <p>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><th>Line name</th> <th>Description</th></tr>
    <tr><td><tt>Title</tt></td>
     <td>An arbitrary string describing the circuit</td></tr>
    <tr><td><tt>Date</tt></td>
     <td>A free-format date string</td></tr>
    <tr><td><tt>Plotname</tt></td>
     <td>A string describing the analysis type</td></tr>
    <tr><td><tt>Flags</tt></td>
     <td>Either "<tt>complex</tt>" or "<tt>real</tt>"</td></tr>
    <tr><td><tt>No. Variables</tt></td>
     <td>The number of variables (numvars)</td></tr>
    <tr><td><tt>No. Points</tt></td>
     <td>The number of points (numpoints)</td></tr>
    <tr><td><tt>Command</tt></td>
     <td>An arbitrary <i>WRspice</i> command</td></tr>
    <tr><td><tt>Option</tt></td>
     <td><i>WRspice</i> variables</td></tr>
    <tr><td><tt>Variables</tt></td>
     <td>A number of variable lines (see below)</td></tr>
    <tr><td><tt>Values</tt></td>
     <td>A number of data lines (see below)</td></tr>
    </table>

    <p>
    Any text on a <tt>Command</tt> line is executed when the file is
    loaded as if it were typed as a command.  By default,
    <i>WRspice</i> puts a <a href="version"><b>version</b></a> command
    into every rawfile it creates.

    <p>
    Text on an <tt>Option</tt> line is parsed as if it were the
    arguments to a <i>WRspice</i> <a href="set"><b>set</b></a>
    command.  The variables set are then available normally, except
    that they are read-only and are associated with the plot.

    <p>
    A <tt>Variable</tt> line looks like
    <blockquote>
    "<i>number name typename</i> [ <i>parm=value</i> ] ..."
    </blockquote>
    The <i>number</i> field is ignored by <tt>WRspice</tt>.  The
    <i>name</i> is the name by which this quantity will be referenced
    in <i>WRspice</i>.  The <i>typename</i> may be either a
    pre-defined type from the table below, or one defined with the <a
    href="deftype"><b>deftype</b></a> command.

    <p>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <caption>Predefined Types</caption>
    <tr><th><tt>Name</tt></th> <th>Description</th> <th>SPICE2 Numeric Code</th></tr>
    <tr><td><tt>notype</tt></td> <td>Dimensionless value</td> <td>0</td></tr>
    <tr><td><tt>time</tt></td> <td>Time</td> <td>1</td></tr>
    <tr><td><tt>frequency</tt></td> <td>Frequency</td> <td>2</td></tr>
    <tr><td><tt>voltage</tt></td> <td>Voltage</td> <td>3</td></tr>
    <tr><td><tt>current</tt></td> <td>Current</td> <td>4</td></tr>
    <tr><td><tt>output-noise</tt></td> <td>SPICE2 .noise result</td> <td>5</td></tr>
    <tr><td><tt>input-noise</tt></td> <td>SPICE2 .noise result</td> <td>6</td></tr>
    <tr><td><tt>HD2</tt></td> <td>SPICE2 .disto result</td> <td>7</td></tr>
    <tr><td><tt>HD3</tt></td> <td>SPICE2 .disto result</td> <td>8</td></tr>
    <tr><td><tt>DIM2</tt></td> <td>SPICE2 .disto result</td> <td>9</td></tr>
    <tr><td><tt>SIM2</tt></td> <td>SPICE2 .disto result</td> <td>10</td></tr>
    <tr><td><tt>DIM3</tt></td> <td>SPICE2 .disto result</td> <td>11</td></tr>
    <tr><td><tt>pole</tt></td> <td>SPICE3 pz result</td> <td>12</td></tr>
    <tr><td><tt>zero</tt></td> <td>SPICE3 pz result</td>  <td>13</td></tr>
    </table>

    <p>
    The (optiona) <i>parm</i> keywords and values follow.  The known
    parameter names are listed in the table below.

    <p>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <caption><b>Parameters</b></caption>
    <tr><th>Name</th>  <th>Description</th></tr>
    <tr><td><tt>min</tt></td>
     <td>Minimum significant value for this output</td></tr>
    <tr><td><tt>max</tt></td>
     <td>Maximum significant value for this output</td></tr>
    <tr><td><tt>color</tt></td>
     <td>The name of a color to use for this value</td></tr>
    <tr><td><tt>scale</tt></td>
     <td>The name of another output to use as the scale</td></tr>
    <tr><td><tt>grid</tt></td>
     <td>The type of grid to use - numeric codes are:<br>
      0  Linear grid<br>
      1  Log-log grid<br>
      2  X-log/Y-linear grid<br>
      3  X-linear/Y-log grid<br>
      4  Polar grid<br>
      5  Smith grid</td></tr>
    <tr><td><tt>plot</tt></td>
     <td>The plotting style to use - numeric codes are:<br>
      0  Connected points<br>
      1  "Comb" style<br>
      2  Unconnected points</td></tr>
    <tr><td><tt>dims</tt></td>
     <td>The dimensions of this vector - not fully supported</td></tr>
    </table>

    <p>
    If the flags value is <tt>complex</tt>, the points look like
    <i>r</i>,<i>i</i> where <i>r</i> and <i>i</i> are exponential
    floating point format.  Otherwise they are real numbers in
    exponential format.  Only one of <tt>real</tt> and
    <tt>complex</tt> should appear.

    <p>
    The lines are guaranteed to be less than 80 columns wide, unless
    the plot title or variable names are very long, or a large number
    of variable options are given.

    <p>
    The binary format is similar to the ASCII format in organization,
    except that it is not text-mode.  Strings are NULL terminated
    instead of newline terminated, and the values are in the machine's
    double precision floating point format instead of in ASCII.  This
    makes the file easier to read and write and reduces file size, but
    the binary format is not portable between machines with different
    floating point formats.

    <p>
    The circuit title, date, and analysis type name in that order are
    at the start of the plot, each terminated by a NULL byte.  Then
    the flags field (a short, which is 1 for real data and 2 for
    complex data), the number of outputs, and the number of points
    (both integers) are present.  Following this is a list of
    NULL-terminated strings which are command lines.  This list is
    terminated by an extra NULL byte.  Then come the options, which
    consist of the name, followed by the type and the value in binary. 
    The output "declarations" consist of the name, type code, flags,
    color, grid type, plot type, and dimension information in that
    order.  Next come the values, which are either doubles or pairs of
    doubles in the case of complex data.

    <p>
    The "old" binary format, which is used by SPICE2, is not accepted
    by <i>WRspice</i>, however the format is given below should it be
    necessary to write a translator.

    <p>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <caption><b>SPICE2 Binary Rawfile  Format</b></caption>
    <tr><th>Field(s)</th>      <th>Size in Bytes</th></tr>
    <tr><td><tt>title          </tt></td> <td>80</td></tr>
    <tr><td><tt>date           </tt></td> <td>8</td></tr>
    <tr><td><tt>time           </tt></td> <td>8</td></tr>
    <tr><td><tt>numoutputs     </tt></td> <td>2</td></tr>
    <tr><td><tt>the integer 4  </tt></td> <td>2</td></tr>
    <tr><td><tt>output names   </tt></td> <td>8 for each output</td></tr>
    <tr><td><tt>types of output</tt></td> <td>2 for each output</td></tr>
    <tr><td><tt>node index     </tt></td> <td>2 for each output</td></tr>
    <tr><td><tt>plot title     </tt></td> <td>24</td></tr>
    <tr><td><tt>data     </tt></td> <td>numpoints * numoutputs * 8</td></tr>
    </table>

    <p>
    The data are in the form of double-precision numbers, or pairs of
    single-precision numbers if the data are complex.

    <p>
    The values recognized for the "types of output" fields are listed
    in the data types (top) table above as the "SPICE2 Numeric Code".

!!SEEALSO
nopadding
filetype
rawfileprec

!! utilities.tex 012609
!!KEYWORD
utilities
!!TITLE
Utility Programs
!!HTML
    The <i>WRspice</i> distribution provides a few supplemental
    utility and accessory programs.

!!SUBTOPICS
mmjco
multidec
printtoraw
proc2mod
wrspiced

!! utilities.tex 091524
!!KEYWORD
csvtoraw
!!TITLE
    The <tt>csvtoraw</tt> Utility: CSV to Rawfile Conversion
!!HTML 
    This program will convert a space/comma separated file to a rawfile.

    <p>
    Usage:  <tt>csvtoraw</tt> [<i>filename</i>]<br>
    Output goes to the standard output channel.  Input comes from the
    file if a name was given, or standard input otherwise.

    <p>
    A "csv" (comma-separated values) file is assumed to have a form as
    described below.
    <ul>
    <li>Any lines that start with white space or a comment character
    ahead of the header line are ignored.  Comment characters are <tt>*#!</tt>.
    <li>The header line contains a number of words, space and/or comma
    separated, these are the vector names.  If they contain a comment
    character or comma the word should be double-quoted.
    <li>Lines that follow are ignored if the first non-space character is
    a comment character, comma, or the line is blank.
    <li>Otherwise the lines should contain the same number of numbers as
    words in the header line.  Any number format as used in <i>WRspice</i>
    is fine, numbers are separated by spaces and/or commas.
    <li>The leftmost logical column will be taken as the scale vector.
    </ul>

!!SEEALSO
utilities

!! utilities.tex 090222
!!KEYWORD
mmjco
!!TITLE
The <tt>mmjco</tt> Utility: Tunnel Junction Model Calculator
!!HTML 
    <i>WRspice</i> contains an internal tunnel junction model (<a
    href="tjm">TJM</a>) of a Josephson junction.  The model requires
    pre-prepared tables of "fit" parameters, which avoid performing
    lengthly calculation at run time.  The <b>mmjco</b> program generates
    the needed files.

    <p>
    In general, the user may not need to interact directly with
    <b>mmjco</b>, as <i>WRspice</i> will call <b>mmjco</b> when needed to
    create new fit files, and store these under a directory named
    <tt>.mmjco</tt> in the user's home directory.  Once a fit file has
    been created for a particular parameter set, it will be reused in
    future <i>WRspice</i> sessions when needed,

    <p>
    The core functionality of <b>mmjco</b> is derived from the MiTMoJCo
    project by D.  R.  Gulevich (found on GitHub.com), specifically the
    <tt>mitmojco.py</tt> environment that provides an interface for
    creating tunnel junction amplitude (TCA) and fitting tables.  This has
    been implemented in <b>mmjco</b> as two C++ classes, one for creating
    tunnel junction amplitudes, which basically evaluates the Werthamer
    model as formulated for MiTMoJCo by Gulevich, the second to compress
    the amplitudes into a compact representation.  This representation is
    used by the TJM (JJ level=3) device model in <i>WRspice</i>.  The
    method is that of Odintsov, Semenov, and Zorin (See below for a list
    of references).

    <p>
    The <b>mmjco</b> program has additional features.
    <ul>
    <li>Sweep tables can be produced for a range of temperatures,
    allowing temperature sweeps to be performed in simulation without
    having to create a fit file at each temperature.
    <p>
    <li>There is a built-in BCS computation of energy gap given
    temperature, superconducting transition temperature, and Debye
    temperature of the junction materials.
    <p>
    <li>Tunnel current amplitude tables are generated in "rawfile"
    format, so can be plotted within <i>WRspice</i> or Synopsys
    <i>WaveView</i>.
    <p>
    <li>The fit and sweep file formats are compatible with the TJM
    developed for Synopsys PrimeSim-HSPICE under the IARPA SuperTools
    program.
    </ul>

    <h3>Running mmjco</h3>

    <p>
    Running <b>mmjco</b> enters a command-line processing loop, the
    user responds to the "<tt>mmjco></tt> " prompt with commands from
    the list below.  Each command can be followed by options as
    indicated.  Additionally, there are "<tt>cdf</tt>" and "<tt>swp</tt>"
    modes where <b>mmjco</b> will create TCA and fit files or
    temperature sweep files according to the arguments, and exit. 
    This is mostly to support <i>WRspice</i>, which uses this mode to
    create new models on-the-fly.

    <p>
    In this document, text in square brackets ([...]) is optional.  A
    vertical pipe character ( | ) indicates that either the text to the
    right or left is acceptable, i.e., it separates options.

    <h3>Command Line Operations</h3>

    These modes are used by the TJM device model in <i>WRspice</i>.

    <p>
    Command:  <tt>mmjco cdf</tt> <i>arguments</i>

    <p>
    If the first argument to the <b>mmjco</b> executable is <tt>cdf</tt>,
    a TCA file and corresponding fit file are created, and <b>mmjco</b>
    exits immediately in this case.  Arguments following <tt>cdf</tt> are
    the same arguments that can follow the <tt>cd</tt> and <tt>cf</tt>
    interactive commands.

    <p>
    Command:  <tt>mmjco swp -fs</tt> <i>sweepfile</i> <i>temperature</i>

    <p>
    Similarly, <tt>swf</tt> will create a possibly-interpolated fit file
    from an existing sweep file, for the temperature provided.

    <h3>Interactive <b>mmjco</b> Commands</h3>

    <p>
    The following are the interactive commands which can be entered after
    starting <b>mmjco</b> with no arguments.

    <dl>
      <dt>
      <tt>cd</tt>[<tt>ata</tt>]  [<tt>-t</tt> <i>temp</i>] 
      [<tt>-d</tt>|<tt>-d1</tt>|<tt>-d2</tt> <i>delta</i>]
      [<tt>-s</tt> <i>smooth</i>] [<tt>-x</tt> <i>nx</i>]
      [<tt>-f</tt> <i>filename</i>] [<tt>-r</tt>|<tt>-rr</tt>|<tt>-rd</tt>]
      <dd>
      Create TCA data, save internally and to a file.  See below for
      an explanation of the options.
    </dl>

    Tunnel current amplitude and smoothing options:
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><td><tt>-t</tt></td> <td>
     The assumed temperature follows, in Kelvin.  Default 4.2.
     </td></tr>
    <tr><td><tt>-d</tt></td> <td>
     This will set both d1 and d2, the pair breaking energy in
     milli-electron volts, of the two superconducting banks.  The default
     is 1.4 mev.
     </td></tr>
    <tr><td><tt>-d1,-d2</tt></td> <td>
     Like <tt>-d</tt>, but apply to only one of the banks.  The final
     occurrence of <tt>d</tt>,<tt>d1</tt>,<tt>d2</tt> will have
     precedence.
     </td></tr>
    <tr><td><tt>-s</tt></dt> <td>
     This provides the smoothing parameter as used in MiTMoJCo.  the
     accepted range is 0.0 - 0.099.  The default is 0.008.  If less than
     0.001, 0 is assumed.  When 0, no smoothing is done and raw BCS tunnel
     amplitudes are generated.
     </td></tr>
    <tr><td><tt>-x</tt></td> <td>
     The number of points used to create the tunnel current amplitudes. 
     The range of sweep of voltage normalized to the gap voltage
     (<tt>d1+d2</tt>) extends from 0.001 through 2.0.  The default point
     count is 500.
     </td></tr>
    <tr><td><tt>-f</tt></td> <td>
     A name for the TCA amplitude file.  If not given, a default is used,
     described below.
     </td></tr>
    <tr><td><tt>-r</tt></td> <td>
     Output file is a complex-valued rawfile.
     </td></tr>
    <tr><td><tt>-rr</tt></td> <td>
     Output file is a real-valued rawfile.
     </td></tr>
    <tr><td><tt>-rd</tt></td> <td>
     Output file simple data file.  If none of
     <tt>-r</tt>,<tt>-rr</tt>,<tt>-rd</tt> options is set, the format will
     be <tt>-rr</tt> if the program was built for <i>XicTools</i>,
     <tt>-rd</tt> otherwise.
     </td></tr>
    </table>

    <dl>
      <dt>
      <tt>cf</tt>[<tt>it</tt>]  [<tt>-n</tt> <i>terms</i>]
      [<tt>-h</tt> <i>thr</i>] [<tt>-ff</tt> <i>filename</i>]
      <dd>
      Create fit parameters for TCA data currently in memory from <tt>cd</tt>
      or <tt>ld</tt> commands.  This is saved internally and to a file.  See
      below for an explanation of the options.
    </dl>

    Fitting table options:
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><td><tt>-n</tt></td> <td>
     The size of the table, defaults to 8.  Larger tables are more
     accurate but take more time to generate and process.  A maximum of 20
     is enforced.
     </td></tr>
    <tr><td><tt>-h</tt></td> <td>
     The ratio of the absolute to relative tolerances, used in
     compression, the default is 0.2.
     </td></tr>
    <tr><td><tt>-ff</tt></td> <td>
     A name for the fitting parameter table.  If not given, a default is
     used, described below.
     </td></tr>
    </table>

    <dl>
      <dt>
      <tt>cm</tt>[<tt>odel</tt>] [<tt>-h</tt> <i>thr</i>]
      [<tt>-fm</tt> [<i>filename</i>]] [<tt>-r</tt>|<tt>-rr</tt>|<tt>-rd</tt>]
      <dd>
      Create a model for TCA data using fitting parameters currently in
      memory, compute the residual, and optionally save to a file.  If
      <tt>-fm</tt> is given without a filename, a file name will be
      generated internally.  If <tt>-fm</tt> is not given, the model will
      not be saved to a file, but used only to compute the residual.  The
      printed residual number is an indication of the fit quality, smaller
      values indicate better matching.

      <p>
      If one of <tt>-r</tt>, <tt>-rr</tt>, <tt>-rd</tt> is given when a
      TCA file is being generated, it overrides the default type for file
      to produce.

        <blockquote>
        <table border=1 cellpadding=2 bgcolor="#ffffee">
        <tr><td><tt>-r</tt></td> <td>complex-valued rawfile</td></tr>
        <tr><td><tt>-rr</tt></td> <td>real-valued rawfile</td></tr>
        <tr><td><tt>-rd</tt></td> <td>simple data file</td></tr>
        </table>
        </blockquote>

      <p>
      The default file type is <tt>-rr</tt> when built for <i>XicTools</i>,
      or the simple data file format otherwise.

      <p>
      The model files are saved in the current directory (unless a path is
      given explicitly).
    </dl>

    <dl>
      <dt>
      <tt>cs</tt>[<tt>weep</tt>] <i>Tstrt Tend</i> [<i>Tdelta</i>] <i>arguments</i>
      <dd>
      Create a temperature sweep file, which involves creating sequential
      records of fit parameters for temperatures starting with
      <i>Tstrt</i> and ending at at or near <i>Tend</i>, spaced in
      temperature by <i>Tdelta</i>.  These are real numbers in Kelvin.  If
      the third number <i>Tdelta</i> does not appear, 0.1K is assumed. 
      The <i>arguments</i> are those that can be given to the <tt>cd</tt>
      or <tt>cf</tt> commands.
    </dl>

    <dl>
      <dt>
      <tt>ct</tt>[<tt>ab</tt>] <i>T1 T2</i> [<i>... TN</i>] <i>arguments</i>
      <dd>
      Create a temperature table file.  The first two temperatures
      <i>T1</i> and <i>T2</i> are required, and these can be followed by
      an arbitrary number of additional temperatures.  The temperatures
      are real numbers in Kelvin.  The <i>arguments</i> are those that can
      be given to the <tt>cd</tt> or <tt>cf</tt> commands.  The file
      will contain fit parameters for each temperature given.
    </dl>

    <dl>
      <dt>
      <tt>d</tt>[<tt>ir</tt>] <i>directory_path</i>
      <dd>
      Give a path to a directory where all amplitude and fit files will be
      stored and loaded from, if a rooted path is not given with the file
      names.  When built for <i>XicTools</i>, the default location is a
      subdirectory "<tt>.mmjco</tt>" in the user's home directory,
      otherwise the current directory is assumed.
    </dl>

    <dl>
      <dt>
      <tt>g</tt>[<tt>ap</tt>] [<tt>-tc</tt> <i>Tc</i>] [<tt>-td</tt> <i>Td</i>]
      [<i>T1 T2...</i>]
      <dd>
      Compute and print the superconducting energy gap at temperatures. 
      The <tt>-tc</tt> specifies the superconducting transition
      temperature, and <tt>-td</tt> specifies the Debye temperature, both
      Kelvin.  If not given, the defaults are for Niobium:  Tc = 9.26K and
      Td = 276K.  There can be zero to 10 real number arguments
      representing temperatures in Kelvin.  If zero, print the gap for
      temperatures from 0 to Tc at 0.1K increments.  If two numbers, print
      the gap for the smaller to the larger in 0.1K increments. 
      Otherwise, print the gap at the given temperatures.
    </dl>

    <dl>
      <dt>
      <tt>ld</tt>[<tt>ata</tt>] <i>filename</i>
      <dd>
      Load the internal TCA data register from a TCA data file whose name
      must be given.  This understands all supported file formats.
    </dl>

    <dl>
      <dt>
      <tt>lf</tt>[<tt>it</tt>] <i>filename</i>
      <dd>
      Load the internal fit parameters register from a fit parameter file
      given.
    </dl>

    <dl>
      <dt>
      <tt>ls</tt>[<tt>weep</tt>] <tt>-fs</tt> <i>filename</i> <i>temp</i>
      <dd>
      Load the internal fit register from a sweep file, interpolating to
      temperature <i>temp</i>.
    </dl>

    <dl>
      <dt>
      <tt>h</tt>[<tt>elp</tt>] | <tt>v</tt>[<tt>ersion</tt>] | ?
      <dd>
      Print help and the running mmjco release number.
    </dl>

    <dl>
      <dt>
      <tt>q</tt>[<tt>uit</tt>] | <tt>e</tt>[<tt>xit</tt>]
      <dd>
      Exit <b>mmjco</b>.
    </dl>

    <h3>File Name Encoding</h3>

    <p>
    Running <b>mmjco</b> can generate three types of files:  a file
    containing values of the tunnel current amplitudes (TCA files), a file
    containing the fitting parameters used to represent the tunnel current
    amplitues in a compact form, and files that contain collections of
    fitting parameter sets, as for a temperature sweep.  The "model" files
    use the same format as the TCA files.  By default, these files are
    given a name that encodes the various parameter values used in
    creation.

    <p>
    Tunnel current amplitude files, including model files, are by default
    given an internally-generated file name in the forms below.
    <blockquote>
    <tt>tcaTTTTTTdddddDDDDDssPPPP.data</tt><br>
    <tt>tcaTTTTTTdddddDDDDDssPPPP.raw</tt>
    </blockquote>

    The "<tt>tca</tt>" and "<tt>.data</tt>"/"<tt>.raw</tt>" and similar
    are literal.  All fields are fixed width and zero padded.  Real
    numbers are converted to integers by multiplying by a scale factor and
    rounding to integer.

    <dl>
    <dt><tt>TTTTTT</tt>
    <dd>A six-digit integer equal to 1e4*<i>temperature</i>.
    <dt><tt>ddddd</tt>
    <dd>A 5-digit integer equal to 1e7*<i>d1</i>, where <i>d1</i> is the
     side 1 gap potential in volts.
    <dt><tt>DDDDD</tt>
    <dd>A 5-digit integer equal to 1e7*<i>d2</i>, where <i>d2</i> is the
     side 2 gap potential in volts.
    <dt><tt>ss</tt>
    <dd>A two digit integer equal to 1e3*<i>sf</i>, where <i>sf</i> is the
     smoothing parameter.
    <dt><tt>PPPP</tt>
    <dd>The number of points used (<tt>-x</tt> option).
    </dl>

    In <i>WRspice</i>, a rawfile (<tt>.raw</tt> extension) can be loaded
    with the <a href="load"><b>load</b></a> command, and the amplitudes
    can then be plotted with "<tt>plot all</tt>".

    <p>
    The fitting parameter file name has the following form.

    <blockquote>
    <tt>tcaTTTTTTdddddDDDDDssPPPP-nnHHH.fit</tt>
    </blockquote>

    The first part, ahead of the '-', is as described above.  Following
    the hyphen:
    <dl>
    <dt><tt>nn</tt>
    <dd>The two-digit fitting table size.
    <dt><tt>HHH</tt>
    <dd>A three digit integer equal to 1e3*<i>thr</i>, where <i>thr</i> is
     the compression threshold.
    </dl>

    Sweep file names have the following form.

    <blockquote>
    <tt>tswNNNttttttTTTTTTssPPPP-nnHHH.swp</tt>
    </blockquote>

    The part following the hyphen is the same as for the fit file.
    <dl>
    <dt><tt>NNN</tt>
    <dd>A three digit integer giving the number of records in the file.
    <dt><tt>tttttt</tt>
    <dd>A six digit integer equal to 1e4*<i>Tstart</i>, where
    <i>Tstart</i> is the starting temperature in Kelvin.
    <dt><tt>TTTTTT</tt>
    <dd>A six digit integer equal to 1e4*<i>Tdelta</i>, where
    <i>Tdelta</i> is the temperature spacing.
    <dt><tt>ss</tt>
    <dd>A two digit integer equal to 1e3*<i>sf</i>, where <i>sf</i> is the
     smoothing parameter.
    <dt><tt>PPPP</tt>
    <dd>The number of points used (<tt>-x</tt> option).
    </dl>

    The fit parameter table format is similar to that used by MiTMoJCo,
    identical if the header is ignored.  Note that the table values do not
    match those found in the MiTMoJCo distribution.  It seems that these
    values are not unique, and the various programs can converge to
    different sets.  It was found that the original and present versions
    of <tt>mitmojco.py</tt> gave different values, and neither matched the
    values provided in the amplitudes folder.

    <h3>File Formats</h3>

    <h4>TCA file formats</h4>

    Tunnel current amplitude (TCA) tables are created by the
    <tt>cd</tt> and <tt>cm</tt> commands.  They consist of real and
    imaginary parts of the pair and quasiparticle amplitudes, on a
    scale of normalized potential across the structure, where the unit
    value is the sum of the gap energies of the two electrodes.  The
    scale extends from 0 to 2 in these units.

    <p>
    There actually are three formats available, selectable with
    options to the <tt>cd</tt> and <tt>cm</tt> commands.

    <dl>
    <dt>
    option: <tt>-rd</tt><dd>
    The file name is described in the previous section, with a suffix
    "<tt>.data</tt>".  This is a generic numerical format, consisting
    of a comment line and six columns of numbers.  The number of data
    lines is the value given with the "<tt>-x</tt>" option to the
    <tt>cd</tt> command, defaulting to 500.  The example below
    illustrates the format.
    </dl>

    <p>
    <pre>
    #    X            Jpair_real   Jpair_imag   Jqp_real     Jqp_imag
    0    1.00000e-03  7.50623e-01  2.85275e-04  -7.50625e-01 3.37356e-04
    1    5.00601e-03  7.51136e-01  1.36358e-03  -7.51123e-01 1.62410e-03
    2    9.01202e-03  7.51643e-01  2.27465e-03  -7.51594e-01 2.74301e-03
    3    1.30180e-02  7.52144e-01  3.03372e-03  -7.52040e-01 3.70900e-03
    ...
    498  1.99599e+00  4.22402e-01  -5.29166e-01 1.52235e-02  1.87539e+00
    499  2.00000e+00  4.21420e-01  -5.28564e-01 1.51180e-02  1.87962e+00
    </pre>

    <p>
    The other two options emit the data using the SPICE "rawfile"
    format.  This is a format developed for plot data in Berkeley
    Spice3, which is supported by most plotting programs, including
    Synopsys WaveView and the <a href="load"><b>load</b></a> function
    of <i>WRspice</i>.  The only difference is that one format ouptuts
    complex numbers for two variables (pair and quasiparticle
    amplitudes), while the other format outputs real values for four
    variables (the real and imaginary parts of the amplitudes).

    <dl>
    <dt>
    option: <tt>-r</tt><dd>
    The file name is described in the previous section, with a suffix
    "<tt>.raw</tt>".  Output is in rawfile format using complex
    numbers.
    </dl>

    <dl>
    <dt>
    option: <tt>-rr</tt><dd>
    The file name is described in the previous section, with a suffix
    "<tt>.raw</tt>".  Output is in rawfile format using real numbers.
    </dl>

    <p>
    The <a href="rawfilefmt">rawfile format</a> description can be
    found in the <i>WRspice</tt> documentation.


    <h4>Fit file format</h4>

    A fit file contains a compacted digest of a TCA table, as
    prescribed by the Odintsov, Semenov and Zorin (OSZ) algorithm. 
    These can be generated with the <tt>cf</tt> command.  Fit files
    can be used as input to simulators that contain a compatible
    tunnel junction model (TJM).  Presently, <i>WRspice</i> and
    Synopsys HSPICE can use these files.

    <p>
    An example fit file is shown below.

    <p>
    <pre>
    tcafit  4.2000e+00  1.3696e-03  1.3696e-03 0.008 500  8  0.200 3.9580e-2
    -5.55136e+00, 7.35249e-02, 1.28573e+00, 1.08362e+01,-1.58776e-01, 2.87279e+01
    -1.24623e-02, 1.00032e+00, 5.84894e-03,-4.50828e-04, 5.81876e-03,-2.11396e-04
    -3.83312e-02, 1.00112e+00, 2.10779e-02,-3.09528e-04, 2.13882e-02, 1.13197e-03
    -1.18261e-01, 9.98252e-01, 6.29481e-02, 1.95061e-03, 6.04875e-02, 1.68472e-02
    -5.41049e-02, 7.52572e-07,-2.72420e-04, 5.67468e+00, 5.43002e-04, 2.37802e+00
    -9.94491e-01, 6.50936e-01, 7.80341e-01, 1.14849e-01,-2.36003e-01, 9.49693e-01
    -3.42835e-01, 9.60836e-01, 1.75970e-01, 1.81214e-02, 1.47672e-01, 1.40112e-01
    -2.80018e-01, 6.49039e-03, 6.26863e-03, 1.81423e-01, 9.20013e-03, 3.23103e-02
    </pre>

    <p>
    The first line is a header, the first word of which is "<tt>tcafit</tt>".
    The numbers that follow in this line are:
    <ul>
    <li>The temperature in Kelvin (4.2000e+00).
    <li>The left electrode pair-breaking energy in ev (1.3696e-03).
    <li>The right electrode pair-breaking energy in ev (1.3696e-03).
    <li>The smoothing parameter value used to create the TCA table,
    <tt>-s</tt> option in the <tt>cd</tt> command for example (0.008).
    <li>The number of scale points used in the TCA table, <tt>-x</tt>
    option in the <tt>cd</tt> command for example (500).
    <li>The number of terms used in the fit table, <tt>-n</tt> option
    in the <tt>cf</tt> command (8).
    <li>The value of the threshold parameter used when generating the
    fit parameter table, <tt>-h</tt> option of the <tt>cf</tt> command
    (0.200).
    <li>Normalized quasiparticle current at x=0.8, used to estimate
    the sub-gap conductance (3.9580e-2).
    </ul>

    <p>
    Following the header line are six columns of real numbers.  The
    number of rows is equal to the "terms", which is the <tt>-n</tt>
    option to the <tt>cf</tt> command.  The columns are the OSZ
    parameters P.real, P.imag, A.real, A.imag, B.real, B.imag.


    <h4>Sweep file format</h4>

    Temperature sweep files are concatenations of fit records as
    described above for a temperature range.  These allow rapid
    temperature modeling through interpolation in supporting
    simulators (<t>WRspice</i> and Synopsys HSPICE).  Sweep files are
    created with the <tt>cs</tt> command.

    <p>
    Below is an example temperature sweep file.

    <p>
    <pre>
    tsweep 91 0.1000 0.1000 0.008 500 8 0.200
    tcafit  1.0000e-01  1.4086e-03  1.4086e-03  1.3185e-02
    -8.51331e+00, 1.15164e-01, 1.29900e+00, 1.11105e+01,-4.05570e-01, 5.65607e+01
    -1.06700e-02, 1.00009e+00, 3.58651e-03,-2.25268e-04, 3.57013e-03,-5.66586e-05
    -2.47980e-02, 1.00072e+00, 1.14692e-02,-5.49747e-04, 1.15840e-02,-1.07382e-04
    -6.31470e-02, 1.00196e+00, 2.92347e-02,-1.70767e-03, 2.93324e-02, 2.09767e-03
    -1.86179e+00, 9.23541e-01, 7.52628e-01,-8.71131e-02,-4.37397e-01, 2.11473e+00
    -1.56178e-01, 1.00378e+00, 6.81933e-02,-6.76474e-03, 7.04144e-02, 1.46763e-02
    -3.74403e-01, 1.01258e+00, 1.53951e-01,-3.71976e-02, 1.73747e-01, 7.86682e-02
    -8.73847e-01, 1.06711e+00, 2.56553e-01,-1.53780e-01, 4.86150e-01, 3.82557e-01
    tcafit  2.0000e-01  1.4086e-03  1.4086e-03  1.3185e-02
    -8.51331e+00, 1.15164e-01, 1.29900e+00, 1.11105e+01,-4.05570e-01, 5.65607e+01
    -1.06700e-02, 1.00009e+00, 3.58651e-03,-2.25268e-04, 3.57013e-03,-5.66586e-05
    ...
    </pre>

    <p>
    The first line is a file header starting with the word "<tt>tsweep</tt>". 
    The numbers that follow on this line are:
    <ul>
    <li>The number of fit records contained in this file (91).
    <li>The lowest temperature K used for fit parameters in the file,
    this will be used in the first fit record (0.1000).
    <li>The temperature delta K used in the sweep file (0.1000).
    <li>The smoothing parameter, <tt>-s</tt> option, used to create
    all TCA tables (0.008).
    <li>The number of scale points, <tt>-x</tt> option, used to create
    all TCA tables (500).
    <li>The number of terms used for each fit table, <tt>-n</tt>
    option (8).
    <li>The value of the threshold parameter used in each fit table
    (0.200).
    </ul>

    <p>
    Following this header, fit records are concatenated.  These are
    similar to the format described above, the only difference is that
    the header line is simplified to omit redundant information.  The
    fit record header contains the following value following the word
    "<tt>tcafit</tt>".
    <ul>
    <li>The temperature in Kelvin (4.2000e+00).
    <li>The left electrode pair-breaking energy in ev (1.3696e-03).
    <li>The right electrode pair-breaking energy in ev (1.3696e-03).
    <li>Normalized quasiparticle current at x=0.8, used to estimate
    the sub-gap conductance (3.9580e-2).
    </ul>


    <h3>References</h3>

    Background references from the MiTMoJCo project.

    <p>
    Tunnel current calculation:<br>
    A. I. Larkin and Yu. N. Ovchinnikov, Sov. Phys. JETP 24, 1035 (1967).<br>
    D. R. Gulevich, V. P. Koshelets, and F. V. Kusmartsev, Phys. Rev. B 96,
     024515 (2017).<br>
    A. B. Zorin, I. O. Kulik, K. K. Likharev, and J. R. Schrieffer, Sov. J. 
     Low Temp. Phys. 5, 537 (1979).<br>
    D. R. Gulevich, V. P. Koshelets, and F. V. Kusmartsev, Phys.  Rev. B 96,
     024515 (2017).<br>
    D. R. Gulevich, V. P. Koshelets, F. V. Kusmartsev, arXiv:1709.04052 (2017).<br>
    D. R. Gulevich, L. V. Filippenko, V. P. Koshelets, arXiv:1809.01642 (2018).<br>

    <p>
    Compression:<br>
    A. A. Odintsov, V. K. Semenov and A. B. Zorin, IEEE Trans. Magn. 23, 763
     (1987).<br>
    D. R. Gulevich, V. P. Koshelets, and F. V. Kusmartsev, Phys. Rev. B 96,
      024515 (2017).

!! utilities.tex 012609
!!KEYWORD
multidec
!!TITLE
The <tt>multidec</tt> Utility: Coupled Lossy Transmission Lines
!!HTML 
    The standalone program <tt>multidec</tt> produces a subcircuit for
    multiconductor lossy transmission lines in terms of uncoupled
    (single) simple lossy lines.  This decomposition is valid only if
    the following hold:

    <ol>
    <li>The electrical parameters (R, G, Cs, Cm, Ls, Lm) of all wires
    are identical and independent of frequency.
    <li>Each line is coupled only to its (maximum 2) nearest neighbors.
    </ol>
    The subcircuit is sent to the standard output and is intended to
    be included in an input file.

    <p>
    The command-line options for <tt>multidec</tt> are as follows:

    <blockquote>
     <tt>-l</tt>&#60self-inductance Ls><br>
     <tt>-c</tt>&#60self-capacitance Cs><br>
     <tt>-r</tt>&#60series-resistance R><br>
     <tt>-g</tt>&#60parallel-conductance G><br>
     <tt>-k</tt>&#60coeff.-of-inductive-coupling K> <br>
     <tt>-x</tt>&#60mutual-capacitance Cm><br>
     <tt>-o</tt>&#60subckt-name><br>
     <tt>-n</tt>&#60number-of-conductors><br>
     <tt>-L</tt>&#60length>
    </blockquote>

    <p>
    The inductive coupling coefficient K is the ratio of Lm
    to Ls. Values for -l, -c, -o, -n and -L must be specified.

    <p>
    Example:
    <blockquote>
    <tt>multidec -n4 -l9e-9 -c20e-12 -r5.3 -x5e-12 -k0.7 -otest -L5.4</tt>
    </blockquote>

    <p>
    This utility was written by <a href="refs#roy">J.S. 
    Roychowdhury</a> for use with the lossy transmission line model.
 
!!SEEALSO
ltra
ltramodel
utilities

!! utilities.tex 012609
!!KEYWORD
printtoraw
!!TITLE
The <tt>printtoraw</tt> Utility: Print to Rawfile Conversion
!!HTML
    The <tt>printtoraw</tt> program is a stand-alone utility provided
    with the <i>WRspice</i> distribution.  This converts the data in
    files produced by the <a href="print"><b>print</b></a> command
    using output <a href="io">redirection</a> into the <a
    href="rawfilefmt">rawfile</a> format, which can be plotted.  This
    works only for print files in the standard columnar form.

    <blockquote>
    Usage: <tt>printtoraw</tt> [<i>printfile</i>]
    </blockquote>

    <p>
    The argument, if given, is assumed to be a path to a file that was
    produced by the <i>WRspice</i> <b>print</b> command through
    redirection.  If no argument is given, the standard input is read. 
    The data are converted to rawfile format and dumped to the
    standard output.

    <p>
    Example:
    <blockquote>
    <tt>
    wrspice> run<br>
    wrspice> print v(1) v(2) v(3) > myfile<br>
    wrspice> quit<br>
    <br>
    bash> printtoraw myfile > myfile.raw<br>
    <br>
    wrspice> load myfile.raw<br>
    wrspice> plot all<br>
    </tt></blockquote>

!!SEEALSO
utilities

!! utilities.tex 012609
!!KEYWORD
proc2mod
!!TITLE
The <tt>proc2mod</tt> Utility: BSIM1 Model Generation
!!HTML
    This utility, provided with SPICE3, produces a set of <a
    href="mosmodel#bsim">BSIM1</a> models from process-dependent data
    provided in a "process" file.  An example process (<tt>.pro</tt>)
    file is provided with the <i>WRspice</i> examples.  This utility
    was written by <a href="refs#pierret">J.  Pierret</a>, and the
    reference presumably provides more information.

!!SEEALSO
utilities

!! utilities.tex 021811
!!KEYWORD
wrspiced
!!TITLE
The <tt>wrspiced</tt> Daemon: Remote SPICE Controller
!!HTML
    <i>WRspice</i> can be accessed and run from a remote system for
    asynchronous simulation runs, for assistance in computationally
    intensive tasks such as Monte Carlo analysis, and as a simulator
    for the <i>Xic</i> graphical editor.  This is made possible
    through a daemon (background) process which controls
    <i>WRspice</i> on the remote machine.  The daemon has the
    executable name "<tt>wrspiced</tt>", and should be running on the
    remote machine.  This can be initiated in the system startup
    procedure, or manually.  Generally, any user can start
    <tt>wrspiced</tt>, but only one daemon can be running on the host
    computer.

    <p>
    The <tt>wrspiced</tt> program is part of the <i>WRspice</i>
    distribution, and is installed in the same directory as the
    <tt>wrspice</tt> executable.  The daemon manages the queue of
    submitted jobs and responses, and maintains the communications
    port.  The <tt>wrspiced</tt> daemon will establish itself on a
    port, and wait for client messages.

    <h3>SPICE Server Configuration</h3>

    There is little or no configuration required to run
    <tt>wrspiced</tt>, but there are a few basic prerequisites.  Our
    assumption is that <i>WRspice</i> is installed on a
    network-reachable remote computer (the "SPICE server"), and we
    wish to submit jobs to this <i>WRspice</i> from within <i>Xic</i>,
    or from within <i>WRspice</i> running on local computers (the
    "clients").

    <p>
    The SPICE server must have <i>WRspice</i> installed, and
    <i>WRspice</i> must be licensed to run on the server.  As a
    prerequisite, <i>WRspice</i> should operate on the SPICE server
    host in the normal way.

    <p>
    Historically, <tt>wrspiced</tt> has used the service name
    "<tt>spice</tt>" and port number 3004.  Releases 3.2.8 and later
    use the service name "<tt>wrspice</tt>" instead of
    "<tt>spice</tt>", and use port number 6114 by default.  The port
    6114 is registered with IANA for this service.

    <p>
    The system services database is represented by the contents of the
    file <tt>/etc/services</tt> in simple installations.  If using
    NIS, then the system will get its services information from
    elsewhere.  A system administrator can add service names and port
    assignments to this database.  The <tt>wrspiced</tt> program does
    not require this.

    <h3>Starting the Daemon</h3>

    The <tt>wrspiced</tt> program command line has the following form:

    <blockquote>
    <tt>wrspiced</tt> [<tt>-fg</tt>] [<tt>-l</tt> <i>logfile</i>]
      [<tt>-p</tt> <i>program</i>] [<tt>-m</tt> <i>maxjobs</i>]
      [<tt>-t</tt> <i>port</i>]
    </blockquote>

    There are five optional arguments.
    <dl>
    <dt><tt>-fg</tt>
    <dd>If given, the <tt>wrspiced</tt> program will remain in the
    foreground (i.e., not become a "daemon"), but will service
    requests normally.  This may be useful for debugging purposes.
    </dl>

    <dl>
    <dt><tt>-l</tt> <i>logfile</i>
    <dd>The <i>logfile</i> is a path to a file that will receive
    status messages from <tt>wrspiced</tt>.  The default is the value
    of the <b>SPICE_DAEMONLOG</b> <a
    href="environment">environment</a> variable if set when the
    program is started, or <tt>/tmp/wrspiced.log</tt>.
    </dl>

    <dl>
    <dt><tt>-p</tt> <i>program</i>
    <dd>This specifies the <tt>WRspice</tt> program to run, in case
    for some reason the <tt>wrspice</tt> binary has been renamed, or
    <tt>wrspice</tt> is not in the expected location.  This overrides
    the values of the <b>SPICE_PATH</b> and <b>SPICE_EXEC_DIR</b> <a
    href="environment">environment</a> variables, which can also be
    used to set the path to the binary.  The default is
    "<tt>/usr/local/xictools/bin/wrspice</tt>".
    </dl>

    <dl>
    <dt><tt>-m</tt> <i>maxjobs</i>
    <dd>This sets the maximum number of jobs that the server will
    allow to be running at the same time.  The default is 5.
    </dl>

    <dl>
    <dt><tt>-t</tt> <i>port</i>
    <dd>This sets the port to be used by the daemon, and overrides any
    port set in the services database.  Clients must use the same port
    number to connect to the SPICE server.
    </dl>

    <p>
    The daemon is started by simply typing the command.  If a machine
    is to operate continuously as a SPICE server, it is recommended
    that the <tt>wrspiced</tt> daemon be started in the system
    initialization scripts.  The daemon will run until explicitly
    killed by a signal, or the machine is halted.  When the
    <tt>wrspiced</tt> process terminates, any <i>WRspice</i> processes
    under management will also be killed.  The daemon can be
    terminated, by the process owner, by giving the command "<tt>ps aux
    | grep wrspiced</tt>" and noting the process id (pid) number of the
    running <tt>wrspiced</tt> process, and then issuing "<tt>kill</tt>
    <i>pid</i>" using this pid number.

    <p>
    It may be necessary to become root before starting
    <tt>wrspiced</tt>, as on some systems connection to the port will
    otherwise be refused due to permission requirements.  Starting by
    root is also required if the log file is to be written to a
    directory such as <tt>/var/log</tt> that requires root permission
    for writing.

    <h3>Client Configuration</h3>

    The port number used by the client must be the same as that used
    for the server.  As for the server, if not supplied the port
    number will be resolved if possible in the services database
    (e.g., the <tt>/etc/services</tt> file), and will revert to a
    default if not found.

    <p>
    In <i>Xic</i> and <i>WRspice</i>, the port number to use can be
    specified with the host name, by appending the number following a colon,
    i.e.,
    <blockquote>
    <i>hostname</i>[:<i>port</i>]
    </blockquote>

    <p>
    A <i>WRspice</i> server can receive jobs from <i>Xic</i>, and from
    <i>WRspice</i> (<a href="rspice"><b>rspice</b></a> command).  Both
    programs have means by which the SPICE server can be specified
    from within the program.  One means common to both programs is
    through use of the <b>SPICE_HOST</b> <a
    href="environment">environment</a> variable.  The variable should
    be set to the host name of the SPICE server, as resolvable by the
    client, followed by the optional colon and port number.  When set,
    <i>Xic</i> will by default use this server for SPICE jobs
    initiated with the <b>Run</b> button in the side menu, and
    <i>WRspice</i> will use this host in the <b>rspice</b> command. 
    In a situation where the SPICE server provides the only SPICE
    available, the <b>SPICE_HOST</b> variable should be set in the
    user's shell startup script.  In <i>WRspice</i> the <a
    href="rhost"><tt>rhost</tt></a> shell variable and the <a
    href="rhostcom"><b>rhost</b></a> command can also be used to
    specify the remote host, and these override any value set in the
    environment.

    <p>
    Note:  In <i>Xic</i>, when <i>WRspice</i> connects, a message is
    printed in the terminal window similar to
    <blockquote>
    <tt>Stream established to wrspice://chaucer, port 4573.</tt>
    </blockquote>
    The "port" in this case is <i>not</i> the <tt>wrspiced</tt> port
    discussed above, but is a transient port created for the process.

!!SEEALSO
utilities

