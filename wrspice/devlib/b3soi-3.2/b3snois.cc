
/*========================================================================*
 *                                                                        *
 *  Distributed by Whiteley Research Inc., Sunnyvale, California, USA     *
 *                       http://wrcad.com                                 *
 *  Copyright (C) 2017 Whiteley Research Inc., all rights reserved.       *
 *  Author: Stephen R. Whiteley, except as indicated.                     *
 *                                                                        *
 *  As fully as possible recognizing licensing terms and conditions       *
 *  imposed by earlier work from which this work was derived, if any,     *
 *  this work is released under the Apache License, Version 2.0 (the      *
 *  "License").  You may not use this file except in compliance with      *
 *  the License, and compliance with inherited licenses which are         *
 *  specified in a sub-header below this one if applicable.  A copy       *
 *  of the License is provided with this distribution, or you may         *
 *  obtain a copy of the License at                                       *
 *                                                                        *
 *        http://www.apache.org/licenses/LICENSE-2.0                      *
 *                                                                        *
 *  See the License for the specific language governing permissions       *
 *  and limitations under the License.                                    *
 *                                                                        *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,      *
 *   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES      *
 *   OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-        *
 *   INFRINGEMENT.  IN NO EVENT SHALL WHITELEY RESEARCH INCORPORATED      *
 *   OR STEPHEN R. WHITELEY BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER     *
 *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,      *
 *   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE       *
 *   USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                        *
 *========================================================================*
 *               XicTools Integrated Circuit Design System                *
 *                                                                        *
 * WRspice Circuit Simulation and Analysis Tool:  Device Library          *
 *                                                                        *
 *========================================================================*
 $Id:$
 *========================================================================*/

/**********
Copyright 1990 Regents of the University of California.  All rights reserved.
Author: 1998 Samuel Fung, Dennis Sinitsky and Stephen Tang
File: b3soinoi.c          98/5/01
Modified by Hui Wan 02/3/5
Modified by Hui Wan 03/07/30
**********/

#include <stdio.h>
#include "b3sdefs.h"
#include "noisdefs.h"

#define B3SOInextModel      next()
#define B3SOInextInstance   next()
#define B3SOIinstances      inst()
#define B3SOIname GENname
#define MAX SPMAX
#define CKTtemp CKTcurTask->TSKtemp
#define NOISEAN sNOISEAN
#define Nintegrate(a, b, c, d) (d)->integrate(a, b, c)
#define NstartFreq JOBac.fstart()

/*
 * B3SOInoise (mode, operation, firstModel, ckt, data, OnDens)
 *    This routine names and evaluates all of the noise sources
 *    associated with MOSFET's.  It starts with the model *firstModel and
 *    traverses all of its insts.  It then proceeds to any other models
 *    on the linked list.  The total output noise density generated by
 *    all of the MOSFET's is summed with the variable "OnDens".
 */

/*
 Channel thermal and flicker noises are calculated based on the value
 of model->B3SOItnoiMod and model->B3SOIfnoiMod
 If model->B3SOItnoiMod = 0,
    Channel thermal noise = Charge based model
 If model->B3SOItnoiMod = 1,
    Channel thermal noise = Holistic noise model
 If model->B3SOIfnoiMod = 0,
    Flicker noise         = Simple model
 If model->B3SOIfnoiMod = 1,
    Flicker noise         = Unified model
*/


static double
B3SOIEval1ovFNoise(double vds, sB3SOImodel *model, sB3SOIinstance *here,
                   double freq, double temp)
{
    struct b3soiSizeDependParam *pParam;
    double cd, esat, DelClm, EffFreq, N0, Nl;
    double T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, Ssi;

    pParam = here->pParam;
    cd = fabs(here->B3SOIcd);
    esat = 2.0 * pParam->B3SOIvsattemp / here->B3SOIueff;
    /* v2.2.3 bug fix */
    if(model->B3SOIem<=0.0) DelClm = 0.0;
    else
    {
        T0 = ((((vds - here->B3SOIVdseff) / pParam->B3SOIlitl)
               + model->B3SOIem) / esat);
        DelClm = pParam->B3SOIlitl * log (MAX(T0, N_MINLOG));
    }

    EffFreq = pow(freq, model->B3SOIef);
    T1 = CHARGE * CHARGE * CONSTboltz * cd * temp * here->B3SOIueff;
    T2 = 1.0e10 * EffFreq * here->B3SOIAbulk * model->B3SOIcox
         * pParam->B3SOIleff * pParam->B3SOIleff;

    /* v2.2.3 bug fix */
    N0 = model->B3SOIcox * here->B3SOIVgsteff / CHARGE;
    Nl = model->B3SOIcox * here->B3SOIVgsteff
         * (1.0 - here->B3SOIAbovVgst2Vtm * here->B3SOIVdseff) / CHARGE;


    T3 = model->B3SOIoxideTrapDensityA
         * log(MAX(((N0 + here->B3SOInstar) / (Nl + here->B3SOInstar)), N_MINLOG));
    T4 = model->B3SOIoxideTrapDensityB * (N0 - Nl);
    T5 = model->B3SOIoxideTrapDensityC * 0.5 * (N0 * N0 - Nl * Nl);

    T6 = CONSTboltz * temp * cd * cd;
    T7 = 1.0e10 * EffFreq * pParam->B3SOIleff
         * pParam->B3SOIleff * pParam->B3SOIweff;
    T8 = model->B3SOIoxideTrapDensityA + model->B3SOIoxideTrapDensityB * Nl
         + model->B3SOIoxideTrapDensityC * Nl * Nl;
    T9 = (Nl + here->B3SOInstar) * (Nl + here->B3SOInstar);

    Ssi = T1 / T2 * (T3 + T4 + T5) + T6 / T7 * DelClm * T8 / T9;

    return Ssi;
}


int
B3SOIdev::noise(int mode, int operation, sGENmodel *genmod, sCKT *ckt,
                sNdata *data, double *OnDens)
{
    sB3SOImodel *model = static_cast<sB3SOImodel*>(genmod);
    sB3SOIinstance *here;

    struct b3soiSizeDependParam *pParam;
    char b3sname[N_MXVLNTH];
    double tempOnoise;
    double tempInoise;
    double noizDens[B3SOINSRCS];
    double lnNdens[B3SOINSRCS];

    double vgs, vds;
//double N0, Nl;
    double T0, T1, T2, /*T3, T4,*/ T5, /*T6, T7, T8, T9,*/ T10, T11;
    double /*n, ExpArg,*/ Ssi, Swi;

    /* v3.2 */
    double npart_theta, npart_beta, igsquare, esat;
    /* v3.2 end */

    int /*error,*/ i;

    /* define the names of the noise sources */
    static const char *B3SOInNames[B3SOINSRCS] =
    {
        /* Note that we have to keep the order */
        ".rd",              /* noise due to rd */
        /* consistent with the index definitions */
        ".rs",              /* noise due to rs */
        /* in B3SOIdefs.h */
        ".rg",              /* noise due to rgeltd, v3.2 */
        ".id",              /* noise due to id */
        ".1overf",          /* flicker (1/f) noise */
        ".fb",              /* noise due to floating body */
        ".igs",             /* shot noise due to IGS, v3.2 */
        ".igd",             /* shot noise due to IGD, v3.2 */
        ".igb",             /* shot noise due to IGB, v3.2 */

        ""                  /* total transistor noise */
    };

    for (; model != NULL; model = model->B3SOInextModel)
    {
        for (here = model->B3SOIinstances; here != NULL;
                here = here->B3SOInextInstance)
        {
            pParam = here->pParam;
            switch (operation)
            {
            case N_OPEN:
                /* see if we have to to produce a summary report */
                /* if so, name all the noise generators */

                if (((NOISEAN*)ckt->CKTcurJob)->NStpsSm != 0)
                {
                    switch (mode)
                    {
                    case N_DENS:
                        for (i = 0; i < B3SOINSRCS; i++)
                        {
                            (void) sprintf(b3sname, "onoise.%s%s",
                                           (char*)here->B3SOIname,
                                           B3SOInNames[i]);
                            /* SRW
                                                                   data->namelist = (IFuid *) trealloc(
                                                                         (char *) data->namelist,
                                                                         (data->numPlots + 1)
                                                                         * sizeof(IFuid));
                                                                   if (!data->namelist)
                                                                       return(E_NOMEM);
                                                                   (*(SPfrontEnd->IFnewUid)) (ckt,
                                                                      &(data->namelist[data->numPlots++]),
                                                                      (IFuid) NULL, b3sname, UID_OTHER,
                                                                      (GENERIC **) NULL);
                            */

                            Realloc(&data->namelist, data->numPlots+1,
                                    data->numPlots);
                            ckt->newUid(&data->namelist[data->numPlots++],
                                        0, b3sname, UID_OTHER);

                            /* we've added one more plot */
                        }
                        break;
                    case INT_NOIZ:
                        for (i = 0; i < B3SOINSRCS; i++)
                        {
                            (void) sprintf(b3sname, "onoise_total.%s%s",
                                           (char*)here->B3SOIname,
                                           B3SOInNames[i]);
                            /* SRW
                                                                   data->namelist = (IFuid *) trealloc(
                                                                         (char *) data->namelist,
                                                                         (data->numPlots + 1)
                                                                         * sizeof(IFuid));
                                                                   if (!data->namelist)
                                                                       return(E_NOMEM);
                                                                   (*(SPfrontEnd->IFnewUid)) (ckt,
                                                                      &(data->namelist[data->numPlots++]),
                                                                      (IFuid) NULL, b3sname, UID_OTHER,
                                                                      (GENERIC **) NULL);
                            */

                            Realloc(&data->namelist, data->numPlots+2,
                                    data->numPlots);
                            ckt->newUid(&data->namelist[data->numPlots++],
                                        0, b3sname, UID_OTHER);

                            /* we've added one more plot */

                            (void) sprintf(b3sname, "inoise_total.%s%s",
                                           (char*)here->B3SOIname,
                                           B3SOInNames[i]);
                            /* SRW
                                                                   data->namelist = (IFuid *) trealloc(
                                                                         (char *) data->namelist,
                                                                         (data->numPlots + 1)
                                                                         * sizeof(IFuid));
                                                                   if (!data->namelist)
                                                                       return(E_NOMEM);
                                                                   (*(SPfrontEnd->IFnewUid)) (ckt,
                                                                      &(data->namelist[data->numPlots++]),
                                                                      (IFuid) NULL, b3sname, UID_OTHER,
                                                                      (GENERIC **)NULL);
                            */

                            ckt->newUid(&data->namelist[data->numPlots++],
                                        0, b3sname, UID_OTHER);

                            /* we've added one more plot */
                        }
                        break;
                    }
                }
                break;
            case N_CALC:
                switch (mode)
                {
                case N_DENS:
                    NevalSrc(&noizDens[B3SOIRDNOIZ],
                             &lnNdens[B3SOIRDNOIZ], ckt, THERMNOISE,
                             here->B3SOIdNodePrime, here->B3SOIdNode,
                             here->B3SOIdrainConductance);

                    NevalSrc(&noizDens[B3SOIRSNOIZ],
                             &lnNdens[B3SOIRSNOIZ], ckt, THERMNOISE,
                             here->B3SOIsNodePrime, here->B3SOIsNode,
                             here->B3SOIsourceConductance);

                    if ((here->B3SOIrgateMod == 1) ||
                            (here->B3SOIrgateMod == 2))
                    {
                        NevalSrc(&noizDens[B3SOIRGNOIZ],
                                 &lnNdens[B3SOIRGNOIZ], ckt, THERMNOISE,
                                 here->B3SOIgNode,
                                 here->B3SOIgNodeExt,
                                 here->B3SOIgrgeltd);
                    }
                    else if (here->B3SOIrgateMod == 3)
                    {
                        NevalSrc(&noizDens[B3SOIRGNOIZ],
                                 &lnNdens[B3SOIRGNOIZ], ckt, THERMNOISE,
                                 here->B3SOIgNodeMid,
                                 here->B3SOIgNodeExt,
                                 here->B3SOIgrgeltd);
                    }
                    else
                    {
                        noizDens[B3SOIRGNOIZ] = 0.0;
                        lnNdens[B3SOIRGNOIZ] =
                            log(MAX(noizDens[B3SOIRGNOIZ],
                                    N_MINLOG));
                    }

                    switch( model->B3SOItnoiMod )
                    {
                    case 0:
                        NevalSrc(&noizDens[B3SOIIDNOIZ],
                                 &lnNdens[B3SOIIDNOIZ], ckt,
                                 THERMNOISE, here->B3SOIdNodePrime,
                                 here->B3SOIsNodePrime,
                                 (here->B3SOIueff
                                  * FABS(here->B3SOIqinv
                                         / (pParam->B3SOIleff
                                            * pParam->B3SOIleff
                                            + here->B3SOIueff*FABS
                                            (here->B3SOIqinv)
                                            *  here->B3SOIrds)))
                                 * model->B3SOIntnoi );
                        break;

                        /* v2.2.3 bug fix */
                    case 1:
                        T0 = here->B3SOIgm + here->B3SOIgmbs +
                             here->B3SOIgds;
                        T0 *= T0;
                        esat = 2.0 * pParam->B3SOIvsattemp /
                               here->B3SOIueff;
                        T5 = here->B3SOIVgsteff / esat /
                             pParam->B3SOIleff;
                        T5 *= T5;
                        npart_beta = model->B3SOIrnoia * (1.0 +
                                                          T5 * model->B3SOItnoia *
                                                          pParam->B3SOIleff);
                        npart_theta = model->B3SOIrnoib * (1.0 +
                                                           T5 * model->B3SOItnoib *
                                                           pParam->B3SOIleff);
                        igsquare = npart_theta * npart_theta *
                                   T0 * here->B3SOIVdseff /
                                   here->B3SOIcd;
                        T1 = npart_beta * (here->B3SOIgm
                                           + here->B3SOIgmbs) + here->B3SOIgds;
                        T2 = T1 * T1 * here->B3SOIVdseff /
                             here->B3SOIcd;

                        NevalSrc(&noizDens[B3SOIIDNOIZ],
                                 &lnNdens[B3SOIIDNOIZ], ckt,
                                 THERMNOISE,
                                 here->B3SOIdNodePrime,
                                 here->B3SOIsNodePrime,
                                 (T2 - igsquare));
                        break;
                    }

                    NevalSrc(&noizDens[B3SOIFLNOIZ], (double*) NULL,
                             ckt, N_GAIN, here->B3SOIdNodePrime,
                             here->B3SOIsNodePrime, (double) 0.0);

                    switch( model->B3SOIfnoiMod )
                    {
                    case 0:
                        noizDens[B3SOIFLNOIZ] *= model->B3SOIkf
                                                 * exp(model->B3SOIaf
                                                       * log(MAX(FABS(here->B3SOIcd),
                                                               N_MINLOG)))
                                                 / (pow(data->freq, model->B3SOIef)
                                                    * pParam->B3SOIleff
                                                    * pParam->B3SOIleff
                                                    * model->B3SOIcox);
                        break;
                    case 1:
                        vgs = *(ckt->CKTstates[0] + here->B3SOIvgs);
                        vds = *(ckt->CKTstates[0] + here->B3SOIvds);
                        if (vds < 0.0)
                        {
                            vds = -vds;
                            vgs = vgs + vds;
                        }

                        Ssi = B3SOIEval1ovFNoise(vds, model, here,
                                                 data->freq, ckt->CKTtemp);

                        T10 = model->B3SOIoxideTrapDensityA
                              * CONSTboltz * ckt->CKTtemp;
                        T11 = pParam->B3SOIweff
                              * pParam->B3SOIleff
                              * pow(data->freq, model->B3SOIef)
                              * 1.0e10 * here->B3SOInstar
                              * here->B3SOInstar ;
                        Swi = T10 / T11 * here->B3SOIcd
                              * here->B3SOIcd;
                        T1 = Swi + Ssi;
                        if (T1 > 0.0)
                            noizDens[B3SOIFLNOIZ] *= (Ssi
                                                      * Swi) / T1;
                        else
                            noizDens[B3SOIFLNOIZ] *= 0.0;
                        break;
                    }

                    lnNdens[B3SOIFLNOIZ] =
                        log(MAX(noizDens[B3SOIFLNOIZ], N_MINLOG));

                    /* v3.2 for gate tunneling shot noise */
                    NevalSrc(&noizDens[B3SOIIGSNOIZ],
                             &lnNdens[B3SOIIGSNOIZ], ckt, SHOTNOISE,
                             here->B3SOIgNode, here->B3SOIsNodePrime,
                             (here->B3SOIIgs + here->B3SOIIgcs));

                    NevalSrc(&noizDens[B3SOIIGDNOIZ],
                             &lnNdens[B3SOIIGDNOIZ], ckt, SHOTNOISE,
                             here->B3SOIgNode, here->B3SOIdNodePrime,
                             (here->B3SOIIgd + here->B3SOIIgcd));

                    NevalSrc(&noizDens[B3SOIIGBNOIZ],
                             &lnNdens[B3SOIIGBNOIZ], ckt, SHOTNOISE,
                             here->B3SOIgNode, here->B3SOIbNode,
                             here->B3SOIig);
                    /* v3.2 for gate tunneling shot noise end */

                    /* Low frequency excess noise due to FBE */
                    NevalSrc(&noizDens[B3SOIFBNOIZ], &lnNdens[B3SOIFBNOIZ],
                             ckt, SHOTNOISE, here->B3SOIsNodePrime,
                             here->B3SOIbNode,
                             2.0 * model->B3SOInoif * here->B3SOIibs);

                    noizDens[B3SOITOTNOIZ] = noizDens[B3SOIRDNOIZ]
                                             + noizDens[B3SOIRSNOIZ]
                                             + noizDens[B3SOIRGNOIZ]
                                             + noizDens[B3SOIIDNOIZ]
                                             + noizDens[B3SOIFLNOIZ]
                                             + noizDens[B3SOIFBNOIZ]
                                             + noizDens[B3SOIIGSNOIZ]
                                             + noizDens[B3SOIIGDNOIZ]
                                             + noizDens[B3SOIIGBNOIZ];
                    lnNdens[B3SOITOTNOIZ] =
                        log(MAX(noizDens[B3SOITOTNOIZ], N_MINLOG));

                    *OnDens += noizDens[B3SOITOTNOIZ];

                    if (data->delFreq == 0.0)
                    {
                        /* if we haven't done any previous
                           integration, we need to initialize our
                           "history" variables.
                          */

                        for (i = 0; i < B3SOINSRCS; i++)
                        {
                            here->B3SOInVar[LNLSTDENS][i] =
                                lnNdens[i];
                        }

                        /* clear out our integration variables
                           if it's the first pass
                         */
                        if (data->freq ==
                                ((NOISEAN*) ckt->CKTcurJob)->NstartFreq)
                        {
                            for (i = 0; i < B3SOINSRCS; i++)
                            {
                                here->B3SOInVar[OUTNOIZ][i] = 0.0;
                                here->B3SOInVar[INNOIZ][i] = 0.0;
                            }
                        }
                    }
                    else
                    {
                        /* data->delFreq != 0.0,
                           we have to integrate.
                         */
                        for (i = 0; i < B3SOINSRCS; i++)
                        {
                            if (i != B3SOITOTNOIZ)
                            {
                                tempOnoise = Nintegrate(noizDens[i],
                                                        lnNdens[i],
                                                        here->B3SOInVar[LNLSTDENS][i],
                                                        data);
                                tempInoise = Nintegrate(noizDens[i]
                                                        * data->GainSqInv, lnNdens[i]
                                                        + data->lnGainInv,
                                                        here->B3SOInVar[LNLSTDENS][i]
                                                        + data->lnGainInv, data);
                                here->B3SOInVar[LNLSTDENS][i] =
                                    lnNdens[i];
                                data->outNoiz += tempOnoise;
                                data->inNoise += tempInoise;
                                if (((NOISEAN*)
                                        ckt->CKTcurJob)->NStpsSm != 0)
                                {
                                    here->B3SOInVar[OUTNOIZ][i]
                                    += tempOnoise;
                                    here->B3SOInVar[OUTNOIZ][B3SOITOTNOIZ]
                                    += tempOnoise;
                                    here->B3SOInVar[INNOIZ][i]
                                    += tempInoise;
                                    here->B3SOInVar[INNOIZ][B3SOITOTNOIZ]
                                    += tempInoise;
                                }
                            }
                        }
                    }
                    if (data->prtSummary)
                    {
                        for (i = 0; i < B3SOINSRCS; i++)
                        {
                            /* print a summary report */
                            data->outpVector[data->outNumber++]
                            = noizDens[i];
                        }
                    }
                    break;
                case INT_NOIZ:
                    /* already calculated, just output */
                    if (((NOISEAN*)ckt->CKTcurJob)->NStpsSm != 0)
                    {
                        for (i = 0; i < B3SOINSRCS; i++)
                        {
                            data->outpVector[data->outNumber++]
                            = here->B3SOInVar[OUTNOIZ][i];
                            data->outpVector[data->outNumber++]
                            = here->B3SOInVar[INNOIZ][i];
                        }
                    }
                    break;
                }
                break;
            case N_CLOSE:
                /* do nothing, the main calling routine will close */
                return (OK);
                break;   /* the plots */
            }       /* switch (operation) */
        }    /* for here */
    }    /* for model */

    return(OK);
}

