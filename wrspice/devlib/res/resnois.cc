
/*========================================================================*
 *                                                                        *
 *  XICTOOLS Integrated Circuit Design System                             *
 *  Copyright (c) 1996 Whiteley Research Inc, all rights reserved.        *
 *                                                                        *
 *                                                                        *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,      *
 *   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES      *
 *   OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-        *
 *   INFRINGEMENT.  IN NO EVENT SHALL STEPHEN R. WHITELEY BE LIABLE       *
 *   FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION      *
 *   OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN           *
 *   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN         *
 *   THE SOFTWARE.                                                        *
 *                                                                        *
 *========================================================================*
 *                                                                        *
 * Device Library                                                         *
 *                                                                        *
 *========================================================================*
 $Id: resnois.cc,v 1.8 2015/08/08 01:51:06 stevew Exp $
 *========================================================================*/

/***************************************************************************
JSPICE3 adaptation of Spice3f2 - Copyright (c) Stephen R. Whiteley 1992
Copyright 1990 Regents of the University of California.  All rights reserved.
Authors: 1987 Gary W. Ng
         1993 Stephen R. Whiteley
****************************************************************************/

#include <stdio.h>
#include "resdefs.h"
#include "noisdefs.h"


namespace
{
    inline bool doing_flicker(sRESmodel *model, sRESinstance *inst)
    {
        return (model->RESkfGiven && model->RESkf != 0.0 &&
            inst->RESlength > 0.0 && inst->RESwidth > 0.0);
    }
}


//    This function names and evaluates all of the noise sources
//    associated with resistors.  It starts with the model *firstModel
//    and traverses all of its instances.  It then proceeds to any other
//    models on the linked list.  The total output noise density
//    generated by all the resistors is summed in the variable "OnDens".
//
int
RESdev::noise (int mode, int operation, sGENmodel *genmod, sCKT *ckt,
    sNdata *data, double *OnDens)
{
    sRESmodel *model = static_cast<sRESmodel*>(genmod);
    char resname[N_MXVLNTH];
    if (operation == N_OPEN) {
        // see if we have to to produce a summary report
        // if so, name the noise generator
        if (static_cast<sNOISEAN*>(ckt->CKTcurJob)->NStpsSm == 0)
            return (OK);
        if (mode == N_DENS) {
            for ( ; model; model = model->next()) {
                sRESinstance *inst;
                for (inst = model->inst(); inst; inst = inst->next()) {

                    sprintf(resname, "onoise_%s", (char*)inst->GENname);
                    Realloc(&data->namelist, data->numPlots+1,
                        data->numPlots);
                    ckt->newUid(&data->namelist[data->numPlots++],
                        0, resname, UID_OTHER);
                        // we've added one more plot

                    if (doing_flicker(model, inst)) {
                        sprintf(resname, "onoise_%s_kf", (char*)inst->GENname);
                        Realloc(&data->namelist, data->numPlots+1,
                            data->numPlots);
                        ckt->newUid(&data->namelist[data->numPlots++],
                            0, resname, UID_OTHER);
                            // we've added one more plot
                    }
                }
            }
            return (OK);
        }

        if (mode == INT_NOIZ) {
            for ( ; model; model = model->next()) {
                sRESinstance *inst;
                for (inst = model->inst(); inst; inst = inst->next()) {

                    sprintf(resname, "onoise_total_%s",
                        (char*)inst->GENname);
                    Realloc(&data->namelist, data->numPlots+2,
                        data->numPlots);
                    ckt->newUid(&data->namelist[data->numPlots++],
                        0, resname, UID_OTHER);
                    sprintf(resname, "inoise_total_%s",
                        (char*)inst->GENname);
                    ckt->newUid(&data->namelist[data->numPlots++],
                        0, resname, UID_OTHER);
                    // we've added two more plots

                    if (doing_flicker(model, inst)) {
                        sprintf(resname, "onoise_total_%s_kf",
                            (char*)inst->GENname);
                        Realloc(&data->namelist, data->numPlots+2,
                            data->numPlots);
                        ckt->newUid(&data->namelist[data->numPlots++],
                            0, resname, UID_OTHER);
                        sprintf(resname, "inoise_total_%s_kf",
                            (char*)inst->GENname);
                        ckt->newUid(&data->namelist[data->numPlots++],
                            0, resname, UID_OTHER);
                        // we've added two more plots
                    }
                }
            }
        }
        return (OK);
    }

    if (operation == N_CALC) {
        if (mode == N_DENS) {
            for ( ; model; model = model->next()) {
                sRESinstance *inst;
                for (inst = model->inst(); inst; inst = inst->next()) {

                    double noizDens[2];
                    double lnNdens[2];
                    NevalSrc(&noizDens[0], &lnNdens[0], ckt, THERMNOISE,
                        inst->RESposNode, inst->RESnegNode,
                        inst->RESnoise * inst->RESconduct);

                    *OnDens += noizDens[0];
                    if (doing_flicker(model, inst)) {
                        double cur =
                            inst->RESv * inst->RESnoise * inst->RESconduct;
                        if (!model->RESafGiven)
                            cur *= cur;
                        else if (model->RESaf != 1.0)
                            cur = pow(cur, model->RESaf);
                        double el = inst->RESlength - model->RESshorten;
                        if (model->RESlfGiven && model->RESlf != 1.0)
                            el = pow(el, model->RESlf);
                        double ew = inst->RESwidth - model->RESnarrow;
                        if (model->RESwfGiven && model->RESwfGiven != 1.0)
                            ew = pow(ew, model->RESwf);
                        double freq = data->freq;
                        if (model->RESefGiven && model->RESef != 1.0)
                            freq = pow(freq, model->RESefGiven);

                        noizDens[1] = (model->RESkf*cur)/(el*ew*freq);
                        lnNdens[1] = log(SPMAX(noizDens[1], N_MINLOG));
                        *OnDens += noizDens[1];
                    }

                    if (data->delFreq == 0.0) { 

                        // if we haven't done any previous integration,
                        // we need to initialize our "history" variables

                        inst->RESnVar[LNLSTDENS][0] = lnNdens[0];
                        if (doing_flicker(model, inst))
                            inst->RESnVar[LNLSTDENS][1] = lnNdens[1];

                        // clear out our integration variable if it's the
                        // first pass

                        if (data->freq ==
                                ((sNOISEAN*)ckt->CKTcurJob)->JOBac.fstart()) {
                            inst->RESnVar[OUTNOIZ][0] = 0.0;
                            inst->RESnVar[OUTNOIZ][1] = 0.0;
                        }
                    }
                    else {
                        // data->delFreq != 0.0 (we have to integrate)
                        double tempOutNoise;
                        double tempInNoise;
                        tempOutNoise =
                            data->integrate(noizDens[0], lnNdens[0],
                            inst->RESnVar[LNLSTDENS][0]);
                        tempInNoise =
                            data->integrate(noizDens[0]*data->GainSqInv,
                            lnNdens[0] + data->lnGainInv,
                            inst->RESnVar[LNLSTDENS][0] + data->lnGainInv);

                        data->outNoiz += tempOutNoise;
                        data->inNoise += tempInNoise;
                        inst->RESnVar[LNLSTDENS][0] = lnNdens[0];
                        inst->RESnVar[OUTNOIZ][0] += tempOutNoise;
                        inst->RESnVar[INNOIZ][0] += tempInNoise;

                        if (doing_flicker(model, inst)) {
                            tempOutNoise =
                                data->integrate(noizDens[1], lnNdens[1],
                                inst->RESnVar[LNLSTDENS][1]);
                            tempInNoise =
                                data->integrate(noizDens[1]*data->GainSqInv,
                                lnNdens[1] + data->lnGainInv,
                                inst->RESnVar[LNLSTDENS][1] + data->lnGainInv);

                            data->outNoiz += tempOutNoise;
                            data->inNoise += tempInNoise;
                            inst->RESnVar[LNLSTDENS][1] = lnNdens[1];
                            inst->RESnVar[OUTNOIZ][1] += tempOutNoise;
                            inst->RESnVar[INNOIZ][1] += tempInNoise;
                        }
                    }
                    if (data->prtSummary) {
                        data->outpVector[data->outNumber++] = noizDens[0];
                        if (doing_flicker(model, inst))
                            data->outpVector[data->outNumber++] = noizDens[1];
                    }
                }
            }
            return (OK);
        }

        if (mode == INT_NOIZ) {
            if (static_cast<sNOISEAN*>(ckt->CKTcurJob)->NStpsSm == 0)
                return (OK);
            for ( ; model; model = model->next()) {
                sRESinstance *inst;
                for (inst = model->inst(); inst; inst = inst->next()) {

                    // already calculated, just output
                    data->outpVector[data->outNumber++] =
                        inst->RESnVar[OUTNOIZ][0];
                    data->outpVector[data->outNumber++] =
                        inst->RESnVar[INNOIZ][0];
                    if (doing_flicker(model, inst)) {
                        data->outpVector[data->outNumber++] =
                            inst->RESnVar[OUTNOIZ][1];
                        data->outpVector[data->outNumber++] =
                            inst->RESnVar[INNOIZ][1];
                    }
                }
            }
        }
    }
    return (OK);
}


/*-----------------------------------------------------------------------------
Flicker noise model

Noise(sid) = (KF * I^AF) / (Leff^LF * Weff^WF * f^EF)

Noise(sid)  Noise spectrum density  A^2Hz
I           Current                 A
Leff        Eff length (Ldrawn-dL)  m
Weff        Eff width  (Wdrawn-dw)  m
f           Frequency               Hz

KF          Flicker noise coefficient   0  >= 0
AF          exponent of current         2  > 0
LF          exp of eff length           1  > 0
WF          exp of eff width            1  > 0
EF          exp of frequency            1  > 0

Requires effective l, w params be given.
------------------------------------------------------------------------------*/

