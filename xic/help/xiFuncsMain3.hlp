
!!  ---------------------------------------------------------------
!!  Xic/WRspice Help System Database
!!  $Id: xiFuncsMain3.hlp,v 1.32 2017/03/22 07:30:07 stevew Exp $
!!  Copyright (C) Whiteley Research Inc. 2003.  All Rights Reserved
!!  ---------------------------------------------------------------

!!TAG Xic

!!KEYWORD
xiFuncsMain3.hlp
!!TITLE
xiFuncsMain3.hlp
!!HTML

!!SUBTOPICS
funcs:main3
funcs:main3:snap
funcs:main3:grid
funcs:main3:curlyr
funcs:main3:ltab
funcs:main3:ldb
funcs:main3:layer
funcs:main3:layerex
funcs:main3:sel
funcs:main3:pfgen
funcs:main3:meas

// Grid and Edge Snapping
!!REDIRECT SetMfgGrid           funcs:main3:snap#SetMfgGrid
!!REDIRECT GetMfgGrid           funcs:main3:snap#GetMfgGrid
!!REDIRECT SetGrid              funcs:main3:snap#SetGrid
!!REDIRECT GetGridSnap          funcs:main3:snap#GetGridSnap
!!REDIRECT GetGridInterval      funcs:main3:snap#GetGridInterval
!!REDIRECT GetSnapInterval      funcs:main3:snap#GetSnapInterval
!!REDIRECT ClipToGrid           funcs:main3:snap#ClipToGrid
!!REDIRECT SetEdgeSnappingMode  funcs:main3:snap#SetEdgeSnappingMode
!!REDIRECT SetEdgeOffGrid       funcs:main3:snap#SetEdgeOffGrid
!!REDIRECT SetEdgeNonManh       funcs:main3:snap#SetEdgeNonManh
!!REDIRECT SetEdgeWireEdge      funcs:main3:snap#SetEdgeWireEdge
!!REDIRECT SetEdgeWirePath      funcs:main3:snap#SetEdgeWirePath
!!REDIRECT GetEdgeSnappingMode  funcs:main3:snap#GetEdgeSnappingMode
!!REDIRECT GetEdgeOffGrid       funcs:main3:snap#GetEdgeOffGrid
!!REDIRECT GetEdgeNonManh       funcs:main3:snap#GetEdgeNonManh
!!REDIRECT GetEdgeWireEdge      funcs:main3:snap#GetEdgeWireEdge
!!REDIRECT GetEdgeWirePath      funcs:main3:snap#GetEdgeWirePath
!!REDIRECT SetRulerSnapToGrid   funcs:main3:snap#SetRulerSnapToGrid
!!REDIRECT SetRulerEdgeSnappingMode funcs:main3:snap#SetRulerEdgeSnappingMode
!!REDIRECT SetRulerEdgeOffGrid  funcs:main3:snap#SetRulerEdgeOffGrid
!!REDIRECT SetRulerEdgeNonManh  funcs:main3:snap#SetRulerEdgeNonManh
!!REDIRECT SetRulerEdgeWireEdge funcs:main3:snap#SetRulerEdgeWireEdge
!!REDIRECT SetRulerEdgeWirePath funcs:main3:snap#SetRulerEdgeWirePath
!!REDIRECT GetRulerSnapToGrid   funcs:main3:snap#GetRulerSnapToGrid
!!REDIRECT GetRulerEdgeSnappingMode funcs:main3:snap#GetRulerEdgeSnappingMode
!!REDIRECT GetRulerEdgeOffGrid  funcs:main3:snap#GetRulerEdgeOffGrid
!!REDIRECT GetRulerEdgeNonManh  funcs:main3:snap#GetRulerEdgeNonManh
!!REDIRECT GetRulerEdgeWireEdge funcs:main3:snap#GetRulerEdgeWireEdge
!!REDIRECT GetRulerEdgeWirePath funcs:main3:snap#GetRulerEdgeWirePath

!! Grid Style
!!REDIRECT ShowGrid             funcs:main3:grid#ShowGrid
!!REDIRECT ShowAxes             funcs:main3:grid#ShowAxes
!!REDIRECT SetGridStyle         funcs:main3:grid#SetGridStyle
!!REDIRECT GetGridStyle         funcs:main3:grid#GetGridStyle
!!REDIRECT SetGridCrossSize     funcs:main3:grid#SetGridCrossSize
!!REDIRECT GetGridCrossSize     funcs:main3:grid#GetGridCrossSize
!!REDIRECT SetGridOnTop         funcs:main3:grid#SetGridOnTop
!!REDIRECT GetGridOnTop         funcs:main3:grid#GetGridOnTop
!!REDIRECT SetGridCoarseMult    funcs:main3:grid#SetGridCoarseMult
!!REDIRECT GetGridCoarseMult    funcs:main3:grid#GetGridCoarseMult
!!REDIRECT SaveGrid             funcs:main3:grid#SaveGrid
!!REDIRECT RecallGrid           funcs:main3:grid#RecallGrid

!! Current Layer
!!REDIRECT GetCurLayer          funcs:main3:curlyr#GetCurLayer
!!REDIRECT GetCurLayerIndex     funcs:main3:curlyr#GetCurLayerIndex
!!REDIRECT SetCurLayer          funcs:main3:curlyr#SetCurLayer
!!REDIRECT SetCurLayerFast      funcs:main3:curlyr#SetCurLayerFast
!!REDIRECT NewCurLayer          funcs:main3:curlyr#NewCurLayer
!!REDIRECT GetCurLayerAlias     funcs:main3:curlyr#GetCurLayerAlias
!!REDIRECT SetCurLayerAlias     funcs:main3:curlyr#SetCurLayerAlias
!!REDIRECT GetCurLayerDescr     funcs:main3:curlyr#GetCurLayerDescr
!!REDIRECT SetCurLayerDescr     funcs:main3:curlyr#SetCurLayerDescr

!! Layer Table
!!REDIRECT LayersUsed           funcs:main3:ltab#LayersUsed
!!REDIRECT AddLayer             funcs:main3:ltab#AddLayer
!!REDIRECT RemoveLayer          funcs:main3:ltab#RemoveLayer
!!REDIRECT RenameLayer          funcs:main3:ltab#RenameLayer
!!REDIRECT LayerHandle          funcs:main3:ltab#LayerHandle
!!REDIRECT GenLayers            funcs:main3:ltab#GenLayers
!!REDIRECT GetLayerPalette      funcs:main3:ltab#GetLayerPalette
!!REDIRECT SetLayerPalette      funcs:main3:ltab#SetLayerPalette

!! Layer Database
!!REDIRECT GetLayerNum          funcs:main3:ldb#GetLayerNum
!!REDIRECT GetLayerName         funcs:main3:ldb#GetLayerName
!!REDIRECT IsPurposeDefined     funcs:main3:ldb#IsPurposeDefined
!!REDIRECT GetPurposeNum        funcs:main3:ldb#GetPurposeNum
!!REDIRECT GetPurposeName       funcs:main3:ldb#GetPurposeName

!! Layers
!!REDIRECT GetLayerLayerNum     funcs:main3:layer#GetLayerLayerNum
!!REDIRECT GetLayerPurposeNum   funcs:main3:layer#GetLayerPurposeNum
!!REDIRECT GetLayerAlias        funcs:main3:layer#GetLayerAlias
!!REDIRECT SetLayerAlias        funcs:main3:layer#SetLayerAlias
!!REDIRECT GetLayerDescr        funcs:main3:layer#GetLayerDescr
!!REDIRECT SetLayerDescr        funcs:main3:layer#SetLayerDescr
!!REDIRECT IsLayerDefined       funcs:main3:layer#IsLayerDefined
!!REDIRECT IsLayerVisible       funcs:main3:layer#IsLayerVisible
!!REDIRECT SetLayerVisible      funcs:main3:layer#SetLayerVisible
!!REDIRECT IsLayerSelectable    funcs:main3:layer#IsLayerSelectable
!!REDIRECT SetLayerSelectable   funcs:main3:layer#SetLayerSelectable
!!REDIRECT IsLayerSymbolic      funcs:main3:layer#IsLayerSymbolic
!!REDIRECT SetLayerSymbolic     funcs:main3:layer#SetLayerSymbolic
!!REDIRECT IsLayerNoMerge       funcs:main3:layer#IsLayerNoMerge
!!REDIRECT SetLayerNoMerge      funcs:main3:layer#SetLayerNoMerge
!!REDIRECT GetLayerMinDimension funcs:main3:layer#GetLayerMinDimension
!!REDIRECT GetLayerWireWidth    funcs:main3:layer#GetLayerWireWidth
!!REDIRECT AddLayerGdsOutMap    funcs:main3:layer#AddLayerGdsOutMap
!!REDIRECT RemoveLayerGdsOutMap funcs:main3:layer#RemoveLayerGdsOutMap
!!REDIRECT AddLayerGdsInMap     funcs:main3:layer#AddLayerGdsInMap
!!REDIRECT ClearLayerGdsInMap   funcs:main3:layer#ClearLayerGdsInMap
!!REDIRECT SetLayerNoDRCdatatype funcs:main3:layer#SetLayerNoDRCdatatype

!! Layers - Extraction Support
!!REDIRECT SetLayerExKeyword    funcs:main3:layerex#SetLayerExKeyword
!!REDIRECT SetCurLayerExKeyword funcs:main3:layerex#SetCurLayerExKeyword
!!REDIRECT RemoveLayerExKeyword funcs:main3:layerex#RemoveLayerExKeyword
!!REDIRECT RemoveCurLayerExKeyword funcs:main3:layerex#RemoveCurLayerExKeyword
!!REDIRECT IsLayerConductor     funcs:main3:layerex#IsLayerConductor
!!REDIRECT IsLayerRouting       funcs:main3:layerex#IsLayerRouting
!!REDIRECT IsLayerGround        funcs:main3:layerex#IsLayerGround
!!REDIRECT IsLayerContact       funcs:main3:layerex#IsLayerContact
!!REDIRECT IsLayerVia           funcs:main3:layerex#IsLayerVia
!!REDIRECT IsLayerViaCut        funcs:main3:layerex#IsLayerViaCut
!!REDIRECT IsLayerDielectric    funcs:main3:layerex#IsLayerDielectric
!!REDIRECT IsLayerDarkField     funcs:main3:layerex#IsLayerDarkField
!!REDIRECT GetLayerThickness    funcs:main3:layerex#GetLayerThickness
!!REDIRECT GetLayerRho          funcs:main3:layerex#GetLayerRho
!!REDIRECT GetLayerResis        funcs:main3:layerex#GetLayerResis
!!REDIRECT GetLayerTau          funcs:main3:layerex#GetLayerTau
!!REDIRECT GetLayerEps          funcs:main3:layerex#GetLayerEps
!!REDIRECT GetLayerCap          funcs:main3:layerex#GetLayerCap
!!REDIRECT GetLayerCapPerim     funcs:main3:layerex#GetLayerCapPerim
!!REDIRECT GetLayerLambda       funcs:main3:layerex#GetLayerLambda

!! Selections
!!REDIRECT SetLayerSpecific     funcs:main3:sel#SetLayerSpecific
!!REDIRECT SetLayerSearchUp     funcs:main3:sel#SetLayerSearchUp
!!REDIRECT SetSelectMode        funcs:main3:sel#SetSelectMode
!!REDIRECT SetSelectTypes       funcs:main3:sel#SetSelectTypes
!!REDIRECT Select               funcs:main3:sel#Select
!!REDIRECT Deselect             funcs:main3:sel#Deselect

!! Pseudo-Flat Generator
!!REDIRECT FlatObjList          funcs:main3:pfgen#FlatObjList
!!REDIRECT FlatObjGen           funcs:main3:pfgen#FlatObjGen
!!REDIRECT FlatObjGenLayers     funcs:main3:pfgen#FlatObjGenLayers
!!REDIRECT FlatGenNext          funcs:main3:pfgen#FlatGenNext
!!REDIRECT FlatGenCount         funcs:main3:pfgen#FlatGenCount
!!REDIRECT FlatOverlapList      funcs:main3:pfgen#FlatOverlapList

!! Geometry Measurement
!!REDIRECT Distance             funcs:main3:meas#Distance
!!REDIRECT MinDistPointToSeg    funcs:main3:meas#MinDistPointToSeg
!!REDIRECT MinDistPointToObj    funcs:main3:meas#MinDistPointToObj
!!REDIRECT MinDistSegToObj      funcs:main3:meas#MinDistSegToObj
!!REDIRECT MinDistObjToObj      funcs:main3:meas#MinDistObjToObj
!!REDIRECT MaxDistPointToObj    funcs:main3:meas#MaxDistPointToObj
!!REDIRECT MaxDistObjToObj      funcs:main3:meas#MaxDistObjToObj
!!REDIRECT Intersect            funcs:main3:meas#Intersect

!!REDIRECT stdlyr               funcs:main3#stdlyr   

!!KEYWORD
funcs:main3
!!TITLE
Main Functions 3
!!HTML

    <!-- 101412 -->
    <a name="stdlyr"></a>
    <h4>Standard Layer Argument</h4>

    Many of the layer-related functions take a "standard layer
    argument".  This can be an integer index number into the layer
    table, where the index is 1-based, and values less than 1 return
    the current layer.  The argument can also be a string, giving a
    layer name in <i>layer</i>[<tt>:</tt><i>purpose</i>] form, or an
    alias name.  If the string is null or empty, the current layer is
    returned.

    <table border=1 cellpadding=2 bgcolor="#ffffee">

    <!-- 012815 -->
    <tr><th colspan=2 align="center">
        <a href="funcs:main3:snap">Grid and Edge Snapping</a></th></tr>

    <tr><td><a href="funcs:main3:snap#SetMfgGrid">
     <tt>SetMfgGrid</tt>(<i>mfg_grid</i>)</a>
     </td><td>Set the manufacturing grid</td></tr>
    <tr><td><a href="funcs:main3:snap#GetMfgGrid">
     <tt>GetMfgGrid</tt>()</a>
     </td><td>Return the manufacturing grid</td></tr>
    <tr><td><a href="funcs:main3:snap#SetGrid">
     <tt>SetGrid</tt>(<i>interval</i>, <i>snap</i>, <i>win</i>)</a>
     </td><td>Set grid parameters for window</td></tr>
    <tr><td><a href="funcs:main3:snap#GetGridInterval">
     <tt>GetGridInterval</tt>(<i>win</i>)</a>
     </td><td>Return fine grid spacing</td></tr>
    <tr><td><a href="funcs:main3:snap#GetSnapInterval">
     <tt>GetSnapInterval</tt>(<i>win</i>)</a>
     </td><td>Return the snap grid spacing</td></tr>
    <tr><td><a href="funcs:main3:snap#GetGridSnap">
     <tt>GetGridSnap</tt>(<i>win</i>)</a>
     </td><td>Return grid snap number</td></tr>
    <tr><td><a href="funcs:main3:snap#ClipToGrid">
     <tt>ClipToGrid</tt>(<i>coord</i>, <i>win</i>)</a>
     </td><td>Move coord to grid</td></tr>
    <tr><td><a href="funcs:main3:snap#SetEdgeSnappingMode">
     <tt>SetEdgeSnappingMode</tt>(<i>win</i>, <i>mode</i>)</a>
     </td><td>Set edge snapping scope for window</td></tr>
    <tr><td><a href="funcs:main3:snap#SetEdgeOffGrid">
     <tt>SetEdgeOffGrid</tt>(<i>win</i>, <i>off_grid</i>)</a>
     </td><td>Enable off-grid edge snapping in window</td></tr>
    <tr><td><a href="funcs:main3:snap#SetEdgeNonManh">
     <tt>SetEdgeNonManh</tt>(<i>win</i>, <i>non_manh</i>)</a>
     </td><td>Enable non-Manhattan edge snapping in window</td></tr>
    <tr><td><a href="funcs:main3:snap#SetEdgeWireEdge">
     <tt>SetEdgeWireEdge</tt>(<i>win</i>, <i>wire_edge</i>)</a>
     </td><td>Snap to wire edges in window</td></tr>
    <tr><td><a href="funcs:main3:snap#SetEdgeWirePath">
     <tt>SetEdgeWirePath</tt>(<i>win</i>, <i>wire_path</i>)</a>
     </td><td>Snap to wire path in window</td></tr>
    <tr><td><a href="funcs:main3:snap#GetEdgeSnappingMode">
     <tt>GetEdgeSnappingMode</tt>(<i>win</i>)</a>
     </td><td>Return edge snapping mode for windoiw</td></tr>
    <tr><td><a href="funcs:main3:snap#GetEdgeOffGrid">
     <tt>GetEdgeOffGrid</tt>(<i>win</i>)</a>
     </td><td>Return off-grid edge snapping flag for window</td></tr>
    <tr><td><a href="funcs:main3:snap#GetEdgeNonManh">
     <tt>GetEdgeNonManh</tt>(<i>win</i>)</a>
     </td><td>Return non-Manhattan edge snapping flag for window</td></tr>
    <tr><td><a href="funcs:main3:snap#GetEdgeWireEdge">
     <tt>GetEdgeWireEdge</tt>(<i>win</i>)</a>
     </td><td>Return wire edge snapping flag for window</td></tr>
    <tr><td><a href="funcs:main3:snap#GetEdgeWirePath">
     <tt>GetEdgeWirePath</tt>(<i>win</i>)</a>
     </td><td>Return wire path snapping flag for window</td></tr>
    <tr><td><a href="funcs:main3:snap#SetRulerSnapToGrid">
     <tt>SetRulerSnapToGrid</tt>(<i>snap</i>)</a>
     </td><td>Set ruler command grid snapping state</td></tr>
    <tr><td><a href="funcs:main3:snap#SetRulerEdgeSnappingMode">
     <tt>SetRulerEdgeSnappingMode</tt>(<i>mode</i>)</a>
     </td><td>Set ruler command edge snapping mode</td></tr>
    <tr><td><a href="funcs:main3:snap#SetRulerEdgeOffGrid">
     <tt>SetRulerEdgeOffGrid</tt>(<i>off_grid</i>)</a>
     </td><td>Set ruler command edge snapping off-grid state</td></tr>
    <tr><td><a href="funcs:main3:snap#SetRulerEdgeNonManh">
     <tt>SetRulerEdgeNonManh</tt>(<i>non_manh</i>)</a>
     </td><td>Set ruler command edge snapping non-Manhattan
     state</td></tr>
    <tr><td><a href="funcs:main3:snap#SetRulerEdgeWireEdge">
     <tt>SetRulerEdgeWireEdge</tt>(<i>wire_edge</i>)</a>
     </td><td>Set ruler command edge snapping wire-edge state</td></tr>
    <tr><td><a href="funcs:main3:snap#SetRulerEdgeWirePath">
     <tt>SetRulerEdgeWirePath</tt>(<i>wire_path</i>)</a>
     </td><td>Set ruler command edge snapping wire-path state</td></tr>
    <tr><td><a href="funcs:main3:snap#GetRulerSnapToGrid">
     <tt>GetRulerSnapToGrid</tt>()</a>
     </td><td>Return ruler command grid snapping state</td></tr>
    <tr><td><a href="funcs:main3:snap#GetRulerEdgeSnappingMode">
     <tt>GetRulerEdgeSnappingMode</tt>()</a>
     </td><td>Return ruler command edge snapping mode</td></tr>
    <tr><td><a href="funcs:main3:snap#GetRulerEdgeOffGrid">
     <tt>GetRulerEdgeOffGrid</tt>()</a>
     </td><td>Return ruler command edge snapping off-grid
     state</td></tr>
    <tr><td><a href="funcs:main3:snap#GetRulerEdgeNonManh">
     <tt>GetRulerEdgeNonManh</tt>()</a>
     </td><td>Return ruler command edge snapping non-Manhattan
     state</td></tr>
    <tr><td><a href="funcs:main3:snap#GetRulerEdgeWireEdge">
     <tt>GetRulerEdgeWireEdge</tt>()</a>
     </td><td>Return ruler command edge snapping wire-edge
     state</td></tr>
    <tr><td><a href="funcs:main3:snap#GetRulerEdgeWirePath">
     <tt>GetRulerEdgeWirePath</tt>()</a>
     </td><td>Return ruler command edge snapping wire-path
     state</td></tr>

    <!-- 012815 -->
    <tr><th colspan=2 align="center">
        <a href="funcs:main3:grid">Grid Style</a></th></tr>

    <tr><td><a href="funcs:main3:grid#ShowGrid">
     <tt>ShowGrid</tt>(<i>on</i>, <i>win</i>)</a>
     </td><td>Set grid visibility in window</td></tr>
    <tr><td><a href="funcs:main3:grid#ShowAxes">
     <tt>ShowAxes</tt>(<i>style</i>, <i>win</i>)</a>
     </td><td>Set axes style in window</td></tr>
    <tr><td><a href="funcs:main3:grid#SetGridStyle">
     <tt>SetGridStyle</tt>(<i>style</i>, <i>win</i>)</a>
     </td><td>Set grid line style</td></tr>
    <tr><td><a href="funcs:main3:grid#GetGridStyle">
     <tt>GetGridStyle</tt>(<i>win</i>)</a>
     </td><td>Return grid line style</td></tr>
    <tr><td><a href="funcs:main3:grid#SetGridCrossSize">
     <tt>SetGridCrossSize</tt>(<i>xsize</i>, <i>win</i>)</a>
     </td><td>Set grid "dot" cross size</td></tr>
    <tr><td><a href="funcs:main3:grid#GetGridCrossSize">
     <tt>GetGridCrossSize</tt>(<i>win</i>)</a>
     </td><td>Return grid "dot" cross size</td></tr>
    <tr><td><a href="funcs:main3:grid#SetGridOnTop">
     <tt>SetGridOnTop</tt>(<i>ontop</i>, <i>win</i>)</a>
     </td><td>Set grid on top of geometry</td></tr>
    <tr><td><a href="funcs:main3:grid#GetGridOnTop">
     <tt>GetGridOnTop</tt>(<i>win</i>)</a>
     </td><td>Return grid top/bottom status</td></tr>
    <tr><td><a href="funcs:main3:grid#SetGridCoarseMult">
     <tt>SetGridCoarseMult</tt>(<i>mult</i>, <i>win</i>)</a>
     </td><td>Set coarse grid spacing multiple</td></tr>
    <tr><td><a href="funcs:main3:grid#GetGridCoarseMult">
     <tt>GetGridCoarseMult</tt>(<i>win</i>)</a>
     </td><td>Return coarse grid spacing multiple</td></tr>
    <tr><td><a href="funcs:main3:grid#SaveGrid">
     <tt>SaveGrid</tt>(<i>regnum</i>, <i>win</i>)</a>
     </td><td>Save grid parameters in register</td></tr>
    <tr><td><a href="funcs:main3:grid#RecallGrid">
     <tt>RecallGrid</tt>(<i>regnum</i>, <i>win</i>)</a>
     </td><td>Recall grid parameters from register</td></tr>

    <!-- 030115 -->
    <tr><th colspan=2 align="center">
        <a href="funcs:main3:curlyr">Current Layer</a></th></tr>

    <tr><td><a href="funcs:main3:curlyr#GetCurLayer">
     <tt>GetCurLayer</tt>()</a>
     </td><td>Return name of current layer</td></tr>
    <tr><td><a href="funcs:main3:curlyr#GetCurLayerIndex">
     <tt>GetCurLayerIndex</tt>()</a>
     </td><td>Return index of current layer</td></tr>
    <tr><td><a href="funcs:main3:curlyr#SetCurLayer">
     <tt>SetCurLayer</tt>(<i>name</i>)</a>
     </td><td>Set current layer, layer must exist</td></tr>
    <tr><td><a href="funcs:main3:curlyr#SetCurLayerFast">
     <tt>SetCurLayerFast</tt>(<i>name</i>)</a>
     </td><td>As SetCurLayer, but no screen updating</td></tr>
    <tr><td><a href="funcs:main3:curlyr#NewCurLayer">
     <tt>NewCurLayer</tt>(<i>name</i>)</a>
     </td><td>Set current layer, create if necessary</td></tr>
    <tr><td><a href="funcs:main3:curlyr#GetCurLayerAlias">
     <tt>GetCurLayerAlias</tt>()</a>
     </td><td>Return alias name of current layer</td></tr>
    <tr><td><a href="funcs:main3:curlyr#SetCurLayerAlias">
     <tt>SetCurLayerAlias</tt>(<i>alias</i>)</a>
     </td><td>Set alias name of current layer</td></tr>
    <tr><td><a href="funcs:main3:curlyr#GetCurLayerDescr">
     <tt>GetCurLayerDescr</tt>()</a>
     </td><td>Return description of current layer</td></tr>
    <tr><td><a href="funcs:main3:curlyr#SetCurLayerDescr">
     <tt>SetCurLayerDescr</tt>(<i>descr</i>)</a>
     </td><td>Set description of current layer</td></tr>

    <!-- 101412 -->
    <tr><th colspan=2 align="center">
        <a href="funcs:main3:ltab">Layer Table</a></th></tr>

    <tr><td><a href="funcs:main3:ltab#LayersUsed">
     <tt>LayersUsed</tt>()</a>
     </td><td>Return number of layers in table</td></tr>
    <tr><td><a href="funcs:main3:ltab#AddLayer">
     <tt>AddLayer</tt>(<i>name</i>, <i>index</i>)</a>
     </td><td>Add a new layer</td></tr>
    <tr><td><a href="funcs:main3:ltab#RemoveLayer">
     <tt>RemoveLayer</tt>(<i>stdlyr</i>)</a>
     </td><td>Remove a layer</td></tr>
    <tr><td><a href="funcs:main3:ltab#RenameLayer">
     <tt>RenameLayer</tt>(<i>oldname</i>, <i>newname</i>)</a>
     </td><td>Give a new name to a layer</td></tr>
    <tr><td><a href="funcs:main3:ltab#LayerHandle">
     <tt>LayerHandle</tt>(<i>down</i>)</a>
     </td><td>Return a handle to a list of layer names</td></tr>
    <tr><td><a href="funcs:main3:ltab#GenLayers">
     <tt>GenLayers</tt>(<i>stringlist_handle</i>)</a>
     </td><td>Return a layer name and advance list to next</td></tr>
    <tr><td><a href="funcs:main3:ltab#GetLayerPalette">
     <tt>GetLayerPalette</tt>(<i>regnum</i>)</a>
     </td><td>Return list of palette layers</td></tr>
    <tr><td><a href="funcs:main3:ltab#SetLayerPalette">
     <tt>SetLayerPalette</tt>(<i>list</i>, <i>regnum</i>)</a>
     </td><td>Save list of palette layers</td></tr>

    <!-- 032017 -->
    <tr><th colspan=2 align="center">
        <a href="funcs:main3:ldb">Layer Database</a></th></tr>

    <tr><td><a href="funcs:main3:ldb#GetLayerNum">
     <tt>GetLayerNum</tt>(<i>name</i>)</a>
     </td><td>Return component layer number for name</td></tr>
    <tr><td><a href="funcs:main3:ldb#GetLayerName">
     <tt>GetLayerName</tt>(<i>num</i>)</a>
     </td><td>Return component layer name for number</td></tr>
    <tr><td><a href="funcs:main3:ldb#IsPurposeDefined">
     <tt>IsPurposeDefined</tt>(<i>name</i>)</a>
     </td><td>Return true if name matches a purpose</td></tr>
    <tr><td><a href="funcs:main3:ldb#GetPurposeNum">
     <tt>GetPurposeNum</tt>(<i>name</i>)</a>
     </td><td>Return purpose number for name</td></tr>
    <tr><td><a href="funcs:main3:ldb#GetPurposeName">
     <tt>GetPurposeName</tt>(<i>num</i>)</a>
     </td><td>Return purpose name for number</td></tr>

    <!-- 032017 -->
    <tr><th colspan=2 align="center">
        <a href="funcs:main3:layer">Layers</a></th></tr>

    <tr><td><a href="funcs:main3:layer#GetLayerLayerNum">
     <tt>GetLayerLayerNum</tt>(<i>stdlyr</i>)</a>
     </td><td>Return the component layer number for layer</td></tr>
    <tr><td><a href="funcs:main3:layer#GetLayerPurposeNum">
     <tt>GetLayerPurposeNum</tt>(<i>stdlyr</i>)</a>
     </td><td>Return the purpose number for layer</td></tr>
    <tr><td><a href="funcs:main3:layer#GetLayerAlias">
     <tt>GetLayerAlias</tt>(<i>stdlyr</i>)</a>
     </td><td>Return the alias for layer</td></tr>
    <tr><td><a href="funcs:main3:layer#SetLayerAlias">
     <tt>SetLayerAlias</tt>(<i>stdlyr</i>, <i>alias</i>)</a>
     </td><td>Set the alias for layer</td></tr>
    <tr><td><a href="funcs:main3:layer#GetLayerDescr">
     <tt>GetLayerDescr</tt>(<i>stdlyr</i>)</a>
     </td><td>Return the description for layer</td></tr>
    <tr><td><a href="funcs:main3:layer#SetLayerDescr">
     <tt>SetLayerDescr</tt>(<i>stdlyr</i>, <i>descr</i>)</a>
     </td><td>Set the description for layer</td></tr>
    <tr><td><a href="funcs:main3:layer#IsLayerDefined">
     <tt>IsLayerDefined</tt>(<i>lname</i>)</a>
     </td><td>Return nonzero if layer exists with given name</td></tr>
    <tr><td><a href="funcs:main3:layer#IsLayerVisible">
     <tt>IsLayerVisible</tt>(<i>stdlyr</i>)</a>
     </td><td>Return true if layer is visible</td></tr>
    <tr><td><a href="funcs:main3:layer#SetLayerVisible">
     <tt>SetLayerVisible</tt>(<i>stdlyr</i>, <i>visible</i>)</a>
     </td><td>Set layer visibility flag</td></tr>
    <tr><td><a href="funcs:main3:layer#IsLayerSelectable">
     <tt>IsLayerSelectable</tt>(<i>stdlyr</i>)</a>
     </td><td>Return true if layer is selectable</td></tr>
    <tr><td><a href="funcs:main3:layer#SetLayerSelectable">
     <tt>SetLayerSelectable</tt>(<i>stdlyr</i>, <i>selectable</i>)</a>
     </td><td>Set layer selectability flag</td></tr>
    <tr><td><a href="funcs:main3:layer#IsLayerSymbolic">
     <tt>IsLayerSymbolic</tt>(<i>stdlyr</i>)</a>
     </td><td>Return true if layer is symbolic</td></tr>
    <tr><td><a href="funcs:main3:layer#SetLayerSymbolic">
     <tt>SetLayerSymbolic</tt>(<i>stdlyr</i>, <i>symbolic</i>)</a>
     </td><td>Set layer symbolic flag</td></tr>
    <tr><td><a href="funcs:main3:layer#IsLayerNoMerge">
     <tt>IsLayerNoMerge</tt>(<i>stdlyr</i>)</a>
     </td><td>Return true if layer has no_merge set </td></tr>
    <tr><td><a href="funcs:main3:layer#SetLayerNoMerge">
     <tt>SetLayerNoMerge</tt>(<i>stdlyr</i>, <i>nomerge</i>)</a>
     </td><td>Set layer no_merge flag</td></tr>
    <tr><td><a href="funcs:main3:layer#GetLayerMinDimension">
     <tt>GetLayerMinDimension</tt>(<i>stdlyr</i>)</a>
     </td><td>Return minimum dimension</td></tr>
    <tr><td><a href="funcs:main3:layer#GetLayerWireWidth">
     <tt>GetLayerWireWidth</tt>(<i>stdlyr</i>)</a>
     </td><td>Return default wire width</td></tr>
    <tr><td><a href="funcs:main3:layer#AddLayerGdsOutMap">
     <tt>AddLayerGdsOutMap</tt>(<i>stdlyr</i>, <i>layer_num</i>,
     <i>datatype</i>)</a>
     </td><td>Add GDSII output layer mapping</td></tr>
    <tr><td><a href="funcs:main3:layer#RemoveLayerGdsOutMap">
     <tt>RemoveLayerGdsOutMap</tt>(<i>stdlyr</i>, <i>layer_num</i>,
     <i>datatype</i>)</a>
     </td><td>Remove GDSII output layer mapping</td></tr>
    <tr><td><a href="funcs:main3:layer#AddLayerGdsInMap">
     <tt>AddLayerGdsInMap</tt>(<i>stdlyr</i>, <i>string</i>)</a>
     </td><td>Add GDSII input layer mapping</td></tr>
    <tr><td><a href="funcs:main3:layer#ClearLayerGdsInMap">
     <tt>ClearLayerGdsInMap</tt>(<i>stdlyr</i>)</a>
     </td><td>Clear GDSII input layer mapping</td></tr>
    <tr><td><a href="funcs:main3:layer#SetLayerNoDRCdatatype">
     <tt>SetLayerNoDRCdatatype</tt>(<i>stdlyr</i>, <i>datatype</i>)</a>
     </td><td>Set GDSII NoDRC datatype</td></tr>

    <!-- 011621 -->
    <tr><th colspan=2 align="center">
        <a href="funcs:main3:layerex">Layers - Extraction Support</a></th></tr>

    <tr><td><a href="funcs:main3:layerex#SetLayerExKeyword">
     <tt>SetLayerExKeyword</tt>(<i>stdlyr</i>, <i>string</i>)</a>
     </td><td>Set extraction keyword/value of layer</td></tr>
    <tr><td><a href="funcs:main3:layerex#SetCurLayerExKeyword">
     <tt>SetCurLayerExKeyword</tt>(<i>string</i>)</a>
     </td><td>Set extraction keyword/value of current layer</td></tr>
    <tr><td><a href="funcs:main3:layerex#RemoveLayerExKeyword">
     <tt>RemoveLayerExKeyword</tt>(<i>stdlyr</i>, <i>keyword</i>)</a>
     </td><td>Remove extraction keyword spec from layer</td></tr>
    <tr><td><a href="funcs:main3:layerex#RemoveCurLayerExKeyword">
     <tt>RemoveCurLayerExKeyword</tt>(<i>keyword</i>)</a>
     </td><td>Remove extraction keyword spec from current layer</td></tr>
    <tr><td><a href="funcs:main3:layerex#IsLayerConductor">
     <tt>IsLayerConductor</tt>(<i>stdlyr</i>)</a>
     </td><td>Return nonzero for Conductor</td></tr>
    <tr><td><a href="funcs:main3:layerex#IsLayerRouting">
     <tt>IsLayerRouting</tt>(<i>stdlyr</i>)</a>
     </td><td>Return nonzero for Routing</td></tr>
    <tr><td><a href="funcs:main3:layerex#IsLayerGround">
     <tt>IsLayerGround</tt>(<i>stdlyr</i>)</a>
     </td><td>Return nonzero for GroundPlane</td></tr>
    <tr><td><a href="funcs:main3:layerex#IsLayerContact">
     <tt>IsLayerContact</tt>(<i>stdlyr</i>)</a>
     </td><td>Return nonzero for Contact</td></tr>
    <tr><td><a href="funcs:main3:layerex#IsLayerVia">
     <tt>IsLayerVia</tt>(<i>stdlyr</i>)</a>
     </td><td>Return nonzero for Via</td></tr>
    <tr><td><a href="funcs:main3:layerex#IsLayerViaCut">
     <tt>IsLayerViaCut</tt>(<i>stdlyr</i>)</a>
     </td><td>Return nonzero for ViaCut</td></tr>
    <tr><td><a href="funcs:main3:layerex#IsLayerDielectric">
     <tt>IsLayerDielectric</tt>(<i>stdlyr</i>)</a>
     </td><td>Return nonzero for Dielectric</td></tr>
    <tr><td><a href="funcs:main3:layerex#IsLayerDarkField">
     <tt>IsLayerDarkField</tt>(<i>stdlyr</i>)</a>
     </td><td>Return nonzero for DarkField</td></tr>
    <tr><td><a href="funcs:main3:layerex#GetLayerThickness">
     <tt>GetLayerThickness</tt>(<i>stdlyr</i>)</a>
     </td><td>Return Thickness</td></tr>
    <tr><td><a href="funcs:main3:layerex#GetLayerRho">
     <tt>GetLayerRho</tt>(<i>stdlyr</i>)</a>
     </td><td>Return resistivity</td></tr>
    <tr><td><a href="funcs:main3:layerex#GetLayerResis">
     <tt>GetLayerResis</tt>(<i>stdlyr</i>)</a>
     </td><td>Return resistance per square</td></tr>
    <tr><td><a href="funcs:main3:layerex#GetLayerTau">
     <tt>GetLayerTau</tt>(<i>stdlyr</i>)</a>
     </td><td>Return Drude relaxstion time</td></tr>
    <tr><td><a href="funcs:main3:layerex#GetLayerEps">
     <tt>GetLayerEps</tt>(<i>stdlyr</i>)</a>
     </td><td>Return dielectric constant</td></tr>
    <tr><td><a href="funcs:main3:layerex#GetLayerCap">
     <tt>GetLayerCap</tt>(<i>stdlyr</i>)</a>
     </td><td>Return capacitance per area</td></tr>
    <tr><td><a href="funcs:main3:layerex#GetLayerCapPerim">
     <tt>GetLayerCapPerim</tt>(<i>stdlyr</i>)</a>
     </td><td>Return capacitance per length</td></tr>
    <tr><td><a href="funcs:main3:layerex#GetLayerLambda">
     <tt>GetLayerLambda</tt>(<i>stdlyr</i>)</a>
     </td><td>Return penetration depth</td></tr>

    <!-- 100412 -->
    <tr><th colspan=2 align="center">
        <a href="funcs:main3:sel">Selections</a></th></tr>

    <tr><td><a href="funcs:main3:sel#SetLayerSpecific">
     <tt>SetLayerSpecific</tt>(<i>state</i>)</a>
     </td><td>Restrict selectability to current layer</td></tr>
    <tr><td><a href="funcs:main3:sel#SetLayerSearchUp">
     <tt>SetLayerSearchUp</tt>(<i>state</i>)</a>
     </td><td>Set layer traversal direction</td></tr>
    <tr><td><a href="funcs:main3:sel#SetSelectMode">
     <tt>SetSelectMode</tt>(<i>ptr_mode</i>, <i>area_mode</i>,
     <i>sel_mode</i>)</a>
     </td><td>Set selection modes</td></tr>
    <tr><td><a href="funcs:main3:sel#SetSelectTypes">
     <tt>SetSelectTypes</tt>(<i>string</i>)</a>
     </td><td>Set selectable object types</td></tr>
    <tr><td><a href="funcs:main3:sel#Select">
     <tt>Select</tt>(<i>left</i>, <i>bottom</i>, <i>right</i>, <i>top</i>,
     <i>types</i>)</a>
     </td><td>Select objects</td></tr>
    <tr><td><a href="funcs:main3:sel#Deselect">
     <tt>Deselect</tt>()</a>
     </td><td>Deselect objects</td></tr>

    <!-- 100408 -->
    <tr><th colspan=2 align="center">
        <a href="funcs:main3:pfgen">Pseudo-Flat Generator</a></th></tr>

    <tr><td><a href="funcs:main3:pfgen#FlatObjList">
     <tt>FlatObjList</tt>(<i>l</i>, <i>b</i>, <i>r</i>, <i>t</i>,
     <i>depth</i>)</a>
     </td><td>Return list of object copies</td></tr>
    <tr><td><a href="funcs:main3:pfgen#FlatObjGen">
     <tt>FlatObjGen</tt>(<i>l</i>, <i>b</i>, <i>r</i>, <i>t</i>,
     <i>depth</i>)</a>
     </td><td>Return handle to object generator</td></tr>
    <tr><td><a href="funcs:main3:pfgen#FlatObjGenLayers">
     <tt>FlatObjGenLayers</tt>(<i>l</i>, <i>b</i>, <i>r</i>, <i>t</i>,
     <i>depth</i>, <i>layers</i>)</a>
     </td><td>Return handle to object generator</td></tr>
    <tr><td><a href="funcs:main3:pfgen#FlatGenNext">
     <tt>FlatGenNext</tt>(<i>handle</i>)</a>
     </td><td>Return handle to next object copy</td></tr>
    <tr><td><a href="funcs:main3:pfgen#FlatGenCount">
     <tt>FlatGenCount</tt>(<i>handle</i>)</a>
     </td><td>Count objects accessible by handle</td></tr>
    <tr><td><a href="funcs:main3:pfgen#FlatOverlapList">
     <tt>FlatOverlapList</tt>(<i>object_handle</i>, <i>touch_ok</i>,
     <i>depth</i>, <i>layers</i>)</a>
     </td><td>Return handle to next object copy</td></tr>

    <!-- 100408 -->
    <tr><th colspan=2 align="center">
        <a href="funcs:main3:meas">Geometry Measurement</a></th></tr>

    <tr><td><a href="funcs:main3:meas#Distance">
     <tt>Distance</tt>(<i>x</i>, <i>y</i>, <i>x1</i>, <i>y1</i>)</a>
     </td><td>Measure distance between points</td></tr>
    <tr><td><a href="funcs:main3:meas#MinDistPointToSeg">
     <tt>MinDistPointToSeg</tt>(<i>x</i>, <i>y</i>, <i>x1</i>, <i>y1</i>,
     <i>x2</i>, <i>y2</i>, <i>aret</i>)</a>
     </td><td>Measure minimum distance between point and line segment</td></tr>
    <tr><td><a href="funcs:main3:meas#MinDistPointToObj">
     <tt>MinDistPointToObj</tt>(<i>x</i>, <i>y</i>, <i>object_handle</i>,
     <i>aret</i>)</a>
     </td><td>Measure minimum distance between point and object</td></tr>
    <tr><td><a href="funcs:main3:meas#MinDistSegToObj">
     <tt>MinDistSegToObj</tt>(<i>x1</i>, <i>y1</i>, <i>x2</i>, <i>y2</i>,
     <i>object_handle</i>, <i>aret</i>)</a>
     </td><td>Measure minimum distance from line segment to object</td></tr>
    <tr><td><a href="funcs:main3:meas#MinDistObjToObj">
     <tt>MinDistObjToObj</tt>(<i>object_handle1</i>, <i>object_handle2</i>,
     <i>aret</i>)</a>
     </td><td>Measure minimum distance between objects</td></tr>
    <tr><td><a href="funcs:main3:meas#MaxDistPointToObj">
     <tt>MaxDistPointToObj</tt>(<i>x</i>, <i>y</i>, <i>object_handle</i>,
     <i>aret</i>)</a>
     </td><td>Measure maximum distance from point to object</td></tr>
    <tr><td><a href="funcs:main3:meas#MaxDistObjToObj">
     <tt>MaxDistObjToObj</tt>(<i>object_handle1</i>, <i>object_handle2</i>,
     <i>aret</i>)</a>
     </td><td>Measure maximum distance between objects</td></tr>
    <tr><td><a href="funcs:main3:meas#Intersect">
     <tt>Intersect</tt>(<i>object_handle1</i>, <i>object_handle2</i>,
     <i>touchok</i>)</a>
     </td><td>Check if objects touch or overlap</td></tr>

     </table>

!!SEEALSO
scr:iffuncs

!!KEYWORD
funcs:main3:snap
!!TITLE
Grid and Edge Snapping
!!HTML
    <!-- 101412 -->
    <a name="SetMfgGrid"></a>
    <dl>
    <dt><b>(int) <tt>SetMfgGrid</tt>(<i>mfg_grid</i>)</b>
    <dd><br>This will set the manufacturing grid to the value of the
    argument, provided that the value is in the range 0.0 - 100.0
    microns.  When the manufacturing grid is nonzero, the snap grid is
    constrained to integer multiples of the manufacturing grid.  The
    function returns 1 if the argument is in range, in which case the
    value is accepted, 0 otherwise.
    </dl>
    <hr>

    <!-- 101412 -->
    <a name="GetMfgGrid"></a>
    <dl>
    <dt><b>(real) <tt>GetMfgGrid</tt>()</b>
    <dd><br>This function returns the value of the manufacturing grid. 
    When nonzero, the snap grid is constrained to integer multiples of
    the manufacturing grid.
    </dl>
    <hr>

    <!-- 101412 -->
    <a name="SetGrid"></a>
    <dl>
    <dt><b>(int) <tt>SetGrid</tt>(<i>interval</i>, <i>snap</i>,
      <i>win</i>)</b>
    <dd><br>This function sets the grid parameters for the window
    indicated by the third argument, which is 0 for the main window or
    1-4 for the sub-windows.  The interval argument sets snap grid
    spacing, in microns.  This value can be zero, in which case the
    present value is retained.

    <p>
    The snap value is an integer in the range of -10 to 10.  If
    positive, the number provides the number of snap grid intervals
    between fine grid lines.  If negative, the absolute value is the
    number of fine grid lines displayed per snap grid interval.  If
    zero, the present setting is retained.

    <p>
    For electrical mode windows, the snap points must be on multiples
    of one micron.  If not, this function returns 0 and the grid is
    unchanged.  The function also returns 0 if the window argument
    does not correspond to an existing window.  The return is 1 if the
    operation succeeds.

    <p>
    The function does not redraw the window.  The <a
    href="Redraw"><tt>Redraw()</tt></a> function can be called to
    redraw the window if necessary.
    </dl>
    <hr>

    <!-- 101412 -->
    <a name="GetGridInterval"></a>
    <dl>
    <dt><b>(real) <tt>GetGridInterval</tt>(<i>win</i>)</b>
    <dd><br>This function returns the fine grid interval in microns
    for the grid in the window indicated by the argument, which is 0
    for the main window or 1-4 for the sub-windows.  The function
    returns 0 if the argument does not correspond to an existing
    window.
    </dl>
    <hr>

    <!-- 101412 -->
    <a name="GetSnapInterval"></a>
    <dl>
    <dt><b>(real) <tt>GetSnapInterval</tt>(<i>win</i>)</b>
    <dd><br>This function returns the snap grid interval in microns
    for the grid in the window indicated by the argument, which is 0
    for the main window or 1-4 for the sub-windows.  The function
    returns 0 if the argument does not correspond to an existing
    window.
    </dl>
    <hr>

    <!-- 101412 -->
    <a name="GetGridSnap"></a>
    <dl>
    <dt><b>(int) <tt>GetGridSnap</tt>(<i>win</i>)</b>
    <dd><br>This function returns the snap number for the grid in the
    window specified by the argument, which is 0 for the main window
    or 1-4 for the sub-windows.  The snap number determines the number
    of snap grid intervals between fine grid lines if positive, or
    fine grid lines per snap interval if negative.  The function
    returns 0 if the argument does not correspond to an existing
    window.
    </dl>

    <!-- 121508 -->
    <a name="ClipToGrid"></a>
    <dl>
    <dt><b>(int) <tt>ClipToGrid</tt>(<i>coord</i>, <i>win</i>)</b>
    <dd><br>The first argument to this function is a coordinate in
    microns.  The return value is the coordinate, in microns, snapped
    to the nearest snap point of the grid of the window given in the
    second argument.  The second argument is 0 for the main window, or
    1-4 for the sub-windows.  The function fails if the window
    argument does not correspond to an existing window.

    <p>
    Note that this function must be called twice for an x,y coordinate
    pair.  This function ignores the edge-snapping modes, only taking
    into account the grid resolution and snap values.
    </dl>
    <hr>

    <!-- 012815 -->
    <a name="SetEdgeSnappingMode"></a>
    <dl>
    <dt><b>(int) <tt>SetEdgeSnappingMode</tt>(<i>win</i>, <i>mode</i>)</b>
    <dd><br>
    Change the edge snapping mode in a drawing window.  The first
    argument is an integer representing the drawing window:  0 for the
    main window, and 1-4 for subwindows.  The change will apply only
    to that window, though changes in the main window will apply to
    new sub-windows.  The second argument is an integer in the range
    0-2.  The effects are
    <blockquote>
    <table border=0 cellspacing=2>
    <tr><td>0</td> <td>No edge snapping.</td></tr>
    <tr><td>1</td> <td>Edge snapping is enabled in some commands.</td></tr>
    <tr><td>2</td> <td>Edge snapping is always enabled.</td></tr>
    </table>
    </blockquote>

    The return value is 1 if the window edge snapping was updated, 0
    otherwise.
    </dl>
    <hr>

    <!-- 012815 -->
    <a name="SetEdgeOffGrid"></a>
    <dl>
    <dt><b>(int) <tt>SetEdgeOffGrid</tt>(<i>win</i>, <i>off_grid</i>)</b>
    <dd><br>
    This will enable snapping to off-grid locations when edge snapping
    is enabled, in the given window.  The first argument is an integer
    representing the drawing window:  0 for the main window, and 1-4
    for subwindows.  The second argument is a boolean which will allow
    off-grid snapping when true.  The return value is 1 if the window
    parameter was updated, 0 otherwise.
    </dl>
    <hr>

    <!-- 012815 -->
    <a name="SetEdgeNonManh"></a>
    <dl>
    <dt><b>(int) <tt>SetEdgeNonManh</tt>(<i>win</i>, <i>non_manh</i>)</b>
    <dd><br>
    This will enable snapping to non-Manhattan edges when edge
    snapping is enabled, in the given window.  The first argument is
    an integer representing the drawing window:  0 for the main
    window, and 1-4 for subwindows.  The second argument is a boolean
    which will allow snapping to non-Manhattan edges when true.  The
    return value is 1 if the window parameter was updated, 0
    otherwise.
    </dl>
    <hr>

    <!-- 012815 -->
    <a name="SetEdgeWireEdge"></a>
    <dl>
    <dt><b>(int) <tt>SetEdgeWireEdge</tt>(<i>win</i>, <i>wire_edge</i>)</b>
    <dd><br>
    This will enable snapping to wire edges when edge snapping is
    enabled, in the given window.  The first argument is an integer
    representing the drawing window:  0 for the main window, and 1-4
    for subwindows.  The second argument is a boolean which will allow
    snapping to wire edges when true.  The return value is 1 if the
    window parameter was updated, 0 otherwise.
    </dl>
    <hr>

    <!-- 012815 -->
    <a name="SetEdgeWirePath"></a>
    <dl>
    <dt><b>(int) <tt>SetEdgeWirePath</tt>(<i>win</i>, <i>wire_path</i>)</b>
    <dd><br>
    This will enable snapping to the wire path when edge snapping is
    enabled, in the given window.  The path is the set of line
    segments that invisibly run along the center of the displayed
    wire, which, along with the wire width and end style, actually
    defines the wire.  The first argument is an integer representing
    the drawing window:  0 for the main window, and 1-4 for
    subwindows.  The second argument is a boolean which will allow
    snapping to the wire path when true.  The return value is 1 if the
    window parameter was updated, 0 otherwise.
    </dl>
    <hr>

    <!-- 012815 -->
    <a name="GetEdgeSnappingMode"></a>
    <dl>
    <dt><b>(int) <tt>GetEdgeSnappingMode</tt>(<i>win</i>)</b>
    <dd><br>
    This function returns the edge snapping mode in effect for the
    given window.  The argument is an integer representing the drawing
    window:  0 for the main window, and 1-4 for subwindows.  The
    return value is -1 if the window is not found, 0-2 otherwise.

    <blockquote>
    <table border=0 cellspacing=2>
    <tr><td>0</td> <td>No edge snapping.</td></tr>
    <tr><td>1</td> <td>Edge snapping is enabled in some commands.</td></tr>
    <tr><td>2</td> <td>Edge snapping is always enabled.</td></tr>
    </table>
    </blockquote>
    </dl>
    <hr>

    <!-- 012815 -->
    <a name="GetEdgeOffGrid"></a>
    <dl>
    <dt><b>(int) <tt>GetEdgeOffGrid</tt>(<i>win</i>)</b>
    <dd><br>
    This returns the setting of the allow off-grid edge snapping flag
    for the given window.  The argument is an integer representing the
    drawing window:  0 for the main window, and 1-4 for subwindows. 
    The return value is -1 if the window is not found, 0 or 1 otherwise
    tracking the state of the flag.
    </dl>
    <hr>

    <!-- 012815 -->
    <a name="GetEdgeNonManh"></a>
    <dl>
    <dt><b>(int) <tt>GetEdgeNonManh</tt>(<i>win</i>)</b>
    <dd><br>
    This returns the setting of the allow non-Manhattan edge snapping
    flag for the given window.  The argument is an integer
    representing the drawing window:  0 for the main window, and 1-4
    for subwindows.  The return value is -1 if the window is not
    found, 0 or 1 otherwise tracking the state of the flag.
    </dl>
    <hr>

    <!-- 012815 -->
    <a name="GetEdgeWireEdge"></a>
    <dl>
    <dt><b>(int) <tt>GetEdgeWireEdge</tt>(<i>win</i>)</b>
    <dd><br>
    This returns the setting of the allow wire-edge edge snapping flag
    for the given window.  The argument is an integer representing the
    drawing window:  0 for the main window, and 1-4 for subwindows. 
    The return value is -1 if the window is not found, 0 or 1 otherwise
    tracking the state of the flag.
    </dl>
    <hr>

    <!-- 012815 -->
    <a name="GetEdgeWirePath"></a>
    <dl>
    <dt><b>(int) <tt>GetEdgeWirePath</tt>(<i>win</i>)</b>
    <dd><br>
    This returns the setting of the allow wire-path edge snapping flag
    for the given window.  The argument is an integer representing the
    drawing window:  0 for the main window, and 1-4 for subwindows. 
    The return value is -1 if the window is not found, 0 or 1 otherwise
    tracking the state of the flag.
    </dl>
    <hr>

    <!-- 012815 -->
    <a name="SetRulerSnapToGrid"></a>
    <dl>
    <dt><b>(int) SetRulerSnapToGrid</tt>(<i>snap</i>)</b>
    <dd><br>
    This function sets the snap-to-grid behavior when creating rulers
    in the <a href="xic:ruler"><b>Rulers</b></a> command.  When set,
    the mouse cursor will snap to grid locations, otherwise not.  In
    either case the cursor may snap to object edges if edge snapping
    is enabled.  If the <b>Rulers</b> command is active the mode will
    change immediately, otherwise the new mode will apply when the
    command becomes active.  The return value is 0 or 1 representing
    the previous flag value.
    </dl>
    <hr>

    <!-- 012815 -->
    <a name="SetRulerEdgeSnappingMode"></a>
    <dl>
    <dt><b>(int) SetRulerEdgeSnappingMode</tt>(<i>mode</i>)</b>
    <dd><br>
    This sets the edge snapping mode which is applied during the <a
    href="xic:ruler"><b>Rulers</b></a> command.  This command has its
    own default edge snapping state.  This function changes only the
    initial state when the command starts, and will have no effect in
    a running command (use <tt>SetEdgeSnappingMode</tt> to alter the
    current setting).  The argument is an integer 0-2.

    <blockquote>
    <table border=0 cellspacing=2>
    <tr><td>0</td> <td>No edge snapping.</td></tr>
    <tr><td>1</td> <td>Edge snapping is enabled in some commands.</td></tr>
    <tr><td>2</td> <td>Edge snapping is always enabled.</td></tr>
    </table>
    </blockquote>

    The function returns -1 if the argument is out of range, or 0-2
    representing the previous state otherwise.
    </dl>
    <hr>

    <!-- 012815 -->
    <a name="SetRulerEdgeOffGrid"></a>
    <dl>
    <dt><b>(int) SetRulerEdgeOffGrid</tt>(<i>off_grid</i>)</b>
    <dd><br>
    This sets the edge snapping allow off-grid flag which is applied
    during the <a href="xic:ruler"><b>Rulers</b></a> command.  This
    command has its own default edge snapping state.  This function
    changes only the initial state when the command starts, and will
    have no effect in a running command (use <tt>SetEdgeOffGrid</tt>
    to alter the current setting).  The argument is a boolean value
    which enables the flag when true.

    <p>
    The return value is 0 or 1 representing the previous flag state.
    </dl>
    <hr>

    <!-- 012815 -->
    <a name="SetRulerEdgeNonManh"></a>
    <dl>
    <dt><b>(int) SetRulerEdgeNonManh</tt>(<i>non_manh</i>)</b>
    <dd><br>
    This sets the edge snapping allow non-Manhattan flag which is
    applied during the <a href="xic:ruler"><b>Rulers</b></a> command. 
    This command has its own default edge snapping state.  This
    function changes only the initial state when the command starts,
    and will have no effect in a running command (use
    <tt>SetEdgeNonManh</tt> to alter the current setting).  The
    argument is a boolean value which enables the flag when true.

    <p>
    The return value is 0 or 1 representing the previous flag state.
    </dl>
    <hr>

    <!-- 012815 -->
    <a name="SetRulerEdgeWireEdge"></a>
    <dl>
    <dt><b>(int) SetRulerEdgeWireEdge</tt>(<i>wire_edge</i>)</b>
    <dd><br>
    This sets the edge snapping allow wire-edge flag which is applied
    during the <a href="xic:ruler"><b>Rulers</b></a> command.  This
    command has its own default edge snapping state.  This function
    changes only the initial state when the command starts, and will
    have no effect in a running command (use <tt>SetEdgeWireEdge</tt>
    to alter the current setting).  The argument is a boolean value
    which enables the flag when true.

    <p>
    The return value is 0 or 1 representing the previous flag state.
    </dl>
    <hr>

    <!-- 012815 -->
    <a name="SetRulerEdgeWirePath"></a>
    <dl>
    <dt><b>(int) SetRulerEdgeWirePath</tt>(<i>wire_path</i>)</b>
    <dd><br>
    This sets the edge snapping allow wire-path flag which is applied
    during the <a href="xic:ruler"><b>Rulers</b></a> command.  This
    command has its own default edge snapping state.  This function
    changes only the initial state when the command starts, and will
    have no effect in a running command (use <tt>SetEdgeWirePath</tt>
    to alter the current setting).  The argument is a boolean value
    which enables the flag when true.

    <p>
    The return value is 0 or 1 representing the previous flag state.
    </dl>
    <hr>

    <!-- 012815 -->
    <a name="GetRulerSnapToGrid"></a>
    <dl>
    <dt><b>(int) GetRulerSnapToGrid()</b>
    <dd><br>
    This returns the present default snap-to-grid state used during
    the <a href="xic:ruler"><b>Rulers</b></a> command.  The values are
    0 or 1 depending on the state.
    </dl>
    <hr>

    <!-- 012815 -->
    <a name="GetRulerEdgeSnappingMode"></a>
    <dl>
    <dt><b>(int) GetRulerEdgeSnappingMode()</b>
    <dd><br>
    The return value is an integer 0-2 representing the default edge
    snapping mode to use during the <a
    href="xic:ruler"><b>Rulers</b></a> command.

    <blockquote>
    <table border=0 cellspacing=2>
    <tr><td>0</td> <td>No edge snapping.</td></tr>
    <tr><td>1</td> <td>Edge snapping is enabled in some commands.</td></tr>
    <tr><td>2</td> <td>Edge snapping is always enabled.</td></tr>
    </table>
    </blockquote>
    </dl>
    <hr>

    <!-- 012815 -->
    <a name="GetRulerEdgeOffGrid"></a>
    <dl>
    <dt><b>(int) GetRulerEdgeOffGrid()</b>
    <dd><br>
    The return value is 0 or 1 depending on the setting of the edge
    snapping allow off-grid flag which is the default in the <a
    href="xic:ruler"><b>Rulers</b></a> command.
    </dl>
    <hr>

    <!-- 012815 -->
    <a name="GetRulerEdgeNonManh"></a>
    <dl>
    <dt><b>(int) GetRulerEdgeNonManh()</b>
    <dd><br>
    The return value is 0 or 1 depending on the setting of the edge
    snapping allow non-Manhattan flag which is the default in the <a
    href="xic:ruler"><b>Rulers</b></a> command.
    </dl>
    <hr>

    <!-- 012815 -->
    <a name="GetRulerEdgeWireEdge"></a>
    <dl>
    <dt><b>(int) GetRulerEdgeWireEdge()</b>
    <dd><br>
    The return value is 0 or 1 depending on the setting of the edge
    snapping allow wire-edge flag which is the default in the <a
    href="xic:ruler"><b>Rulers</b></a> command.
    </dl>
    <hr>

    <!-- 012815 -->
    <a name="GetRulerEdgeWirePath"></a>
    <dl>
    <dt><b>(int) GetRulerEdgeWirePath()</b>
    <dd><br>
    The return value is 0 or 1 depending on the setting of the edge
    snapping allow wire-path flag which is the default in the <a
    href="xic:ruler"><b>Rulers</b></a> command.
    </dl>
!!LATEX funcs:main3:snap scrfuncs.tex
\begin{description}
%------------------------------------
% 101412
\index{SetMfgGrid function}
\item{(int) \vt SetMfgGrid({\it mfg\_grid\/})}\\
This will set the manufacturing grid to the value of the argument,
provided that the value is in the range 0.0 -- 100.0 microns.  When
the manufacturing grid is nonzero, the snap grid is constrained to
integer multiples of the manufacturing grid.  The function returns 1
if the argument is in range, in which case the value is accepted, 0
otherwise.

%------------------------------------
% 101412
\index{GetMfgGrid function}
\item{(real) \vt GetMfgGrid()}\\
This function returns the value of the manufacturing grid.  When
nonzero, the snap grid is constrained to integer multiples of the
manufacturing grid.

%------------------------------------
% 101412
\index{SetGrid function}
\item{(int) \vt SetGrid({\it interval\/}, {\it snap},  {\it win\/})}\\
This function sets the grid parameters for the window indicated by the
third argument, which is 0 for the main window or 1--4 for the
sub-windows.  The interval argument sets snap grid spacing, in
microns.  This value can be zero, in which case the present value is
retained.

The snap value is an integer in the range of -10 to 10.  If positive,
the number provides the number of snap grid intervals between fine
grid lines.  If negative, the absolute value is the number of fine
grid lines displayed per snap grid interval.  If zero, the present
setting is retained.
 
For electrical mode windows, the snap points must be on multiples of
one micron.  If not, this function returns 0 and the grid is
unchanged.  The function also returns 0 if the window argument does
not correspond to an existing window.  The return is 1 if the
operation succeeds.

The function does not redraw the window.  The {\vt Redraw()} function
can be called to redraw the window if necessary.

%------------------------------------
% 101412
\index{GetGridInterval function}
\item{(real) \vt GetGridInterval({\it win\/})}\\
This function returns the fine grid interval in microns for the grid
in the window indicated by the argument, which is 0 for the main
window or 1--4 for the sub-windows.  The function returns 0 if the
argument does not correspond to an existing window.

%------------------------------------
% 101412
\index{GetSnapInterval function}
\item{(real) \vt GetSnapInterval({\it win\/})}\\
This function returns the snap grid interval in microns for the grid
in the window indicated by the argument, which is 0 for the main
window or 1--4 for the sub-windows.  The function returns 0 if the
argument does not correspond to an existing window.

%------------------------------------
% 101412
\index{GetGridSnap function}
\item{(int) \vt GetGridSnap({\it win\/})}\\
This function returns the snap number for the grid in the window
specified by the argument, which is 0 for the main window or 1--4 for
the sub-windows.  The snap number determines the number of snap grid
intervals between fine grid lines if positive, or fine grid lines per
snap interval if negative.  The function returns 0 if the argument
does not correspond to an existing window.

%------------------------------------
% 121508
\index{ClipToGrid function}
\item{(int) \vt ClipToGrid({\it coord}, {\it win\/})}\\
The first argument to this function is a coordinate in microns.  The
return value is the coordinate, in microns, snapped to the nearest
snap point of the grid of the window given in the second argument. 
The second argument is 0 for the main window, or 1--4 for the
sub-windows.  The function fails if the window argument does not
correspond to an existing window.

Note that this function must be called twice for an x,y coordinate
pair.  This function ignores the edge-snapping modes, only taking into
account the grid resolution and snap values.

%------------------------------------
% 012815
\index{SetEdgeSnappingMode function}
\item{(int) \vt SetEdgeSnappingMode({\it win}, {\it mode\/})}\\
Change the edge snapping mode in a drawing window.  The first argument
is an integer representing the drawing window:  0 for the main window,
and 1--4 for subwindows.  The change will apply only to that window,
though changes in the main window will apply to new sub-windows.  The
second argument is an integer in the range 0--2.  The effects are

\begin{quote}
\begin{tabular}{ll}
0 & No edge snapping.\\
1 & Edge snapping is enabled in some commands.\\
2 & Edge snapping is always enabled.\\
\end{tabular}
\end{quote}
 
The return value is 1 if the window edge snapping was updated, 0
otherwise. 
 
%------------------------------------
% 012815
\index{SetEdgeOffGrid function}
\item{(int) \vt SetEdgeOffGrid({\it win}, {\it off\_grid\/})}\\
This will enable snapping to off-grid locations when edge snapping is
enabled, in the given window.  The first argument is an integer
representing the drawing window:  0 for the main window, and 1--4 for
subwindows.  The second argument is a boolean which will allow
off-grid snapping when true.  The return value is 1 if the window
parameter was updated, 0 otherwise.

%------------------------------------
% 012815
\index{SetEdgeNonManh function}
\item{(int) \vt SetEdgeNonManh({\it win}, {\it non\_manh\/})}\\
This will enable snapping to non-Manhattan edges when edge snapping is
enabled, in the given window.  The first argument is an integer
representing the drawing window:  0 for the main window, and 1--4 for
subwindows.  The second argument is a boolean which will allow
snapping to non-Manhattan edges when true.  The return value is 1 if
the window parameter was updated, 0 otherwise.

%------------------------------------
% 012815
\index{SetEdgeWireEdge function}
\item{(int) \vt SetEdgeWireEdge({\it win}, {\it wire\_edge\/})}\\
This will enable snapping to wire edges when edge snapping is enabled,
in the given window.  The first argument is an integer representing
the drawing window:  0 for the main window, and 1--4 for subwindows. 
The second argument is a boolean which will allow snapping to wire
edges when true.  The return value is 1 if the window parameter was
updated, 0 otherwise.

%------------------------------------
% 012815
\index{SetEdgeWirePath function}
\item{(int) \vt SetEdgeWirePath({\it win}, {\it wire\_path\/})}\\
This will enable snapping to the wire path when edge snapping is
enabled, in the given window.  The path is the set of line segments
that invisibly run along the center of the displayed wire, which,
along with the wire width and end style, actually defines the wire. 
The first argument is an integer representing the drawing window:  0
for the main window, and 1--4 for subwindows.  The second argument is
a boolean which will allow snapping to the wire path when true.  The
return value is 1 if the window parameter was updated, 0 otherwise.

%------------------------------------
% 012815
\index{GetEdgeSnappingMode function}
\item{(int) \vt GetEdgeSnappingMode({\it win})}\\
This function returns the edge snapping mode in effect for the given
window.  The argument is an integer representing the drawing window: 
0 for the main window, and 1--4 for subwindows.  The return value is
-1 if the window is not found, 0-2 otherwise.

\begin{quote}
\begin{tabular}{ll}
0 & No edge snapping.\\
1 & Edge snapping is enabled in some commands.\\
2 & Edge snapping is always enabled.\\
\end{tabular}
\end{quote}

%------------------------------------
% 012815
\index{GetEdgeOffGrid function}
\item{(int) \vt GetEdgeOffGrid({\it win})}\\
This returns the setting of the allow off-grid edge snapping flag for
the given window.  The argument is an integer representing the drawing
window:  0 for the main window, and 1-4 for subwindows.  The return
value is -1 if the window is not found, 0 or 1 otherwise tracking the
state of the flag.

%------------------------------------
% 012815
\index{GetEdgeNonManh function}
\item{(int) \vt GetEdgeNonManh({\it win})}\\
This returns the setting of the allow non-Manhattan edge snapping flag
for the given window.  The argument is an integer representing the
drawing window:  0 for the main window, and 1--4 for subwindows.  The
return value is -1 if the window is not found, 0 or 1 otherwise
tracking the state of the flag.

%------------------------------------
% 012815
\index{GetEdgeWireEdge function}
\item{(int) \vt GetEdgeWireEdge({\it win})}\\
This returns the setting of the allow wire-edge edge snapping flag for
the given window.  The argument is an integer representing the drawing
window:  0 for the main window, and 1--4 for subwindows.  The return
value is -1 if the window is not found, 0 or 1 otherwise tracking the
state of the flag.

%------------------------------------
% 012815
\index{GetEdgeWirePath function}
\item{(int) \vt GetEdgeWirePath({\it win})}\\
This returns the setting of the allow wire-path edge snapping flag for
the given window.  The argument is an integer representing the drawing
window:  0 for the main window, and 1--4 for subwindows.  The return
value is -1 if the window is not found, 0 or 1 otherwise tracking the
state of the flag.

%------------------------------------
% 012815
\index{SetRulerSnapToGrid function}
\item{(int) \vt SetRulerSnapToGrid({\it snap})}\\
This function sets the snap-to-grid behavior when creating rulers in
the {\cb Rulers} command.  When set, the mouse cursor will snap to
grid locations, otherwise not.  In either case the cursor may snap to
object edges if edge snapping is enabled.  If the {\cb Rulers} command
is active the mode will change immediately, otherwise the new mode
will apply when the command becomes active.  The return value is 0 or
1 representing the previous flag value.

%------------------------------------
% 012815
\index{SetRulerEdgeSnappingMode function}
\item{(int) \vt SetRulerEdgeSnappingMode({\it mode})}\\
This sets the edge snapping mode which is applied during the {\cb
Rulers} command.  This command has its own default edge snapping
state.  This function changes only the initial state when the command
starts, and will have no effect in a running command (use {\vt
SetEdgeSnappingMode} to alter the current setting).  The argument is
an integer 0--2.

\begin{quote}
\begin{tabular}{ll}
0 & No edge snapping.\\
1 & Edge snapping is enabled in some commands.\\
2 & Edge snapping is always enabled.\\
\end{tabular}
\end{quote}

The function returns -1 if the argument is out of range, or 0--2
representing the previous state otherwise.

%------------------------------------
% 012815
\index{SetRulerEdgeOffGrid function}
\item{(int) \vt SetRulerEdgeOffGrid({\it off\_grid})}\\
This sets the edge snapping allow off-grid flag which is applied
during the {\cb Rulers} command.  This command has its own default
edge snapping state.  This function changes only the initial state
when the command starts, and will have no effect in a running command
(use {\vt SetEdgeOffGrid} to alter the current setting).  The argument
is a boolean value which enables the flag when true.

The return value is 0 or 1 representing the previous flag state.

%------------------------------------
% 012815
\index{SetRulerEdgeNonManh function}
\item{(int) \vt SetRulerEdgeNonManh({\it non\_manh})}\\
This sets the edge snapping allow non-Manhattan flag which is applied
during the {\cb Rulers} command.  This command has its own default
edge snapping state.  This function changes only the initial state
when the command starts, and will have no effect in a running command
(use {\vt SetEdgeNonManh} to alter the current setting).  The argument
is a boolean value which enables the flag when true.

The return value is 0 or 1 representing the previous flag state.

%------------------------------------
% 012815
\index{SetRulerEdgeWireEdge function}
\item{(int) \vt SetRulerEdgeWireEdge({\it wire\_edge})}\\
This sets the edge snapping allow wire-edge flag which is applied
during the {\cb Rulers} command.  This command has its own default
edge snapping state.  This function changes only the initial state
when the command starts, and will have no effect in a running command
(use {\vt SetEdgeWireEdge} to alter the current setting).  The
argument is a boolean value which enables the flag when true.

The return value is 0 or 1 representing the previous flag state.

%------------------------------------
% 012815
\index{SetRulerEdgeWirePath function}
\item{(int) \vt SetRulerEdgeWirePath({\it wire\_path})}\\
This sets the edge snapping allow wire-path flag which is applied
during the {\cb Rulers} command.  This command has its own default
edge snapping state.  This function changes only the initial state
when the command starts, and will have no effect in a running command
(use {\vt SetEdgeWirePath} to alter the current setting).  The
argument is a boolean value which enables the flag when true.

The return value is 0 or 1 representing the previous flag state.

%------------------------------------
% 012815
\index{GetRulerSnapToGrid function}
\item{(int) \vt GetRulerSnapToGrid()}\\
This returns the present default snap-to-grid state used during the
{\cb Rulers} command.  The values are 0 or 1 depending on the state.

%------------------------------------
% 012815
\index{GetRulerEdgeSnappingMode function}
\item{(int) \vt GetRulerEdgeSnappingMode()}\\
The return value is an integer 0-2 representing the default edge
snapping mode to use during the {\cb Rulers} command.

\begin{quote}
\begin{tabular}{ll}
0 & No edge snapping.\\
1 & Edge snapping is enabled in some commands.\\
2 & Edge snapping is always enabled.\\
\end{tabular}
\end{quote}

%------------------------------------
% 012815
\index{GetRulerEdgeOffGrid function}
\item{(int) \vt GetRulerEdgeOffGrid()}\\
The return value is 0 or 1 depending on the setting of the edge
snapping allow off-grid flag which is the default in the {\cb Rulers}
command.

%------------------------------------
% 012815
\index{GetRulerEdgeNonManh function}
\item{(int) \vt GetRulerNonManh()}\\
The return value is 0 or 1 depending on the setting of the edge
snapping allow non-Manhattan flag which is the default in the {\cb
Rulers} command.

%------------------------------------
% 012815
\index{GetRulerEdgeWireEdge function}
\item{(int) \vt GetRulerEdgeWireEdge()}\\
The return value is 0 or 1 depending on the setting of the edge
snapping allow wire-edge flag which is the default in the {\cb Rulers}
command.

%------------------------------------
% 012815
\index{GetRulerEdgeWirePath function}
\item{(int) \vt GetRulerEdgeWirePath()}\\
The return value is 0 or 1 depending on the setting of the edge
snapping allow wire-path flag which is the default in the {\cb Rulers}
command.

\end{description}

!!SEEALSO
funcs:main3

!!KEYWORD
funcs:main3:grid
!!TITLE
Grid Presentation
!!HTML
    <!-- 030204 -->
    <a name="ShowGrid"></a>
    <dl>
    <dt><b>(int) <tt>ShowGrid</tt>(<i>on</i>, <i>win</i>)</b>
    <dd><br>This function sets whether or not the grid is shown in a
    window.  If the first argument is nonzero, the grid will be shown,
    otherwise the grid will not be shown.  The second argument is an
    integer representing the drawing window:  0 for the main window,
    and 1-4 for sub-windows.  The change will not be visible until the
    window is redrawn (one can call <a
    href="Redraw"><tt>Redraw</tt></a>).  If success, 1 is returned, or
    0 is returned if the window does not exist.
    </dl>
    <hr>

    <!-- 030204 -->
    <a name="ShowAxes"></a>
    <dl>
    <dt><b>(int) <tt>ShowAxes</tt>(<i>style</i>, <i>win</i>)</b>
    <dd><br>This function sets the axes presentation style in physical
    mode windows.  The first argument is an integer 0-2, where 0
    suppresses drawing of axes, 1 indicates plain axes, and 2 (or
    anything else) indicates axes with a box at the origin.  The
    second argument is an integer representing the drawing window:  0
    for the main window, 1-4 for sub-windows.  Axes are never shown in
    electrical mode windows.  On success, 1 is returned.  If the
    window does not exist or is not showing a physical view, 0 is
    returned.  The change will not be visible until the window is
    redrawn (one can call <a href="Redraw"><tt>Redraw</tt></a>).
    </dl>
    <hr>

    <!-- 030204 -->
    <a name="SetGridStyle"></a>
    <dl>
    <dt><b>(int) <tt>SetGridStyle</tt>(<i>style</i>, <i>win</i>)</b>
    <dd><br>This function sets the line style used for grid rendering. 
    The first argument is an integer mask that defines the on-off
    pattern.  The pattern starts at the most significant '1' bit and
    continues through the least significant bit, and repeats.  Set
    bits are rendered as the visible part of the pattern.  If the
    style is 0, a dot is shown at each grid point.  Passing -1 will
    give continuous lines.  The second argument is an integer
    representing the drawing window:  0 for the main window, 1-4 for
    sub-windows.  The function returns 1 on success, 0 if the window
    does not exist.  The change will not be visible until the window
    is redrawn (one can call <a href="Redraw"><tt>Redraw</tt></a>).
    </dl>
    <hr>

    <!-- 030204 -->
    <a name="GetGridStyle"></a>
    <dl>
    <dt><b>(int) <tt>GetGridStyle</tt>(<i>win</i>)</b>
    <dd><br>This function returns the line style mask used for rendering
    the grid in the given window.  The mask has the interpretation
    described in the description of <tt>SetGridStyle</tt>.  The
    argument is an integer representing the window:  0 for the main
    window, and 1-4 for sub-windows.  If the window does not exist, 0
    is returned.
    </dl>
    <hr>

    <!-- 071110 -->
    <a name="SetGridCrossSize"></a>
    <dl>
    <dt><b>(int) <tt>SetGridCrossSize</tt>(<i>xsize</i>, <i>win</i>)</b>
    <dd><br>This applies only to grids with style 0 (dot grid).  The
    <i>xsize</i> is an integer 0-6 which indicates the number of
    pixels to draw in the four compass directions around the central
    pixel.  Thus, for nonzero values, the "dot" is rendered as a small
    cross.  The second argument is an integer representing the drawing
    window:  0 for the main window, 1-4 for subwindows.  The function
    returns 1 on success, 0 if the window does not exist or the style
    is nonzero.  The change will not be visible until the window is
    redrawn (one can call <a href="Redraw"><tt>Redraw</tt></a>).
    </dl>
    <hr>

    <!-- 071110 -->
    <a name="GetGridCrossSize"></a>
    <dl>
    <dt><b>(int) <tt>GetGridCrossSize</tt>(<i>win</i>)</b>
    <dd><br>This returns an integer 0-6, which will be nonzero only
    for grid style 0 (dot grid), and if the "dots" are being rendered
    as small crosses via a call to <tt>SetGridCrossSize</tt> or
    otherwise.  The argument is an integer representing the window:  0
    for the main window, and 1-4 for subwindows.  If the window does
    not exist, 0 is returned. 
    </dl>
    <hr>

    <!-- 030204 -->
    <a name="SetGridOnTop"></a>
    <dl>
    <dt><b>(int) <tt>SetGridOnTop</tt>(<i>ontop</i>, <i>win</i>)</b>
    <dd><br>This function sets whether the grid is shown above or below
    rendered objects.  If the first argument is nonzero, the grid will
    be shown above rendered objects.  The second argument is an
    integer representing the drawing window:  0 for the main window
    and 1-4 for sub-windows.  The function returns 1 on success, 0 if
    the window does not exist.  The change will not be visible until
    the window is redrawn (one can call <a
    href="Redraw"><tt>Redraw</tt></a>).
    </dl>
    <hr>

    <!-- 030204 -->
    <a name="GetGridOnTop"></a>
    <dl>
    <dt><b>(int) <tt>GetGridOnTop</tt>(<i>win</i>)</b>
    <dd><br>This function returns 1 is the grid is shown on top of
    objects.  The argument is an integer representing the drawing
    window:  0 for the main window and 1-4 for sub-windows.  If the
    grid is shown below rendered objects, 0 is returned.  If the
    window does not exist, -1 is returned.
    </dl>
    <hr>

    <!-- 101412 -->
    <a name="SetGridCoarseMult"></a>
    <dl>
    <dt><b>(int) <tt>SetGridCoarseMult</tt>(<i>mult</i>, <i>win</i>)</b>
    <dd><br>This sets the number of fine grid lines per coarse grid
    line.  The first argument is an integer 1-50 that provides this
    multiple (it is clipped to this range).  If 1, the coarse grid
    color is used for all grid lines.  The second argument represents
    the drawing window whose grid is being changed, 0 for the main
    drawing window, and 1-4 for sub-windows.  The change will not be
    visible until the window is redrawn (one can call <a
    href="Redraw"><tt>Redraw()</tt></a>).

    <p>
    The return value is 1 on success, 0 if the window does not exist.
    </dl>
    <hr>

    <!-- 101412 -->
    <a name="GetGridCoarseMult"></a>
    <dl>
    <dt><b>(int) <tt>GetGridCoarseMult</tt>(<i>win</i>)</b>
    <dd><br>This returns the number of fine grid lines per coarse grid
    interval, as being used in the drawing window indicated by the
    argument.  The argument is 0 for the main drawing window, 1-4 for
    sub-windows.  If the window does not exist, zero is returned.
    </dl>
    <hr>

    <!-- 101412 -->
    <a name="SaveGrid"></a>
    <dl>
    <dt><b>(int) <tt>SaveGrid</tt>(<i>regnum</i>, <i>win</i>)</b>
    <dd><br>This will save a grid parameter set to a register.  The
    first argument is a register index value 0-7.  Register 0 is used
    internally for the "last" value whenever grid parameters are
    changed, so is probably not a good choice unless this behavior is
    expected.  These are the same registers as used with the <a
    href="xic:grid"><b>Grid Setup</b></a> panel, and are associated
    with the <a href="PhysGridReg"><tt>PhysGridReg</tt></a> and <a
    href="ElecGridReg"><tt>ElecGridReg</tt></a> keyword families in
    the technology file.

    <p>
    The second argument represents the drawing window whose grid
    parameters are to be saved.  The value is 0 for the main drawing
    window, and 1-4 for sub-windows.  Note that separate registers
    exist for electrical and physical mode, so register numbers can be
    reused in the two modes.

    <p>
    The return value is 1 on success, 0 if the indicated window does
    not exist, or the register value is out of range.
    </dl>
    <hr>

    <!-- 101412 -->
    <a name="RecallGrid"></a>
    <dl>
    <dt><b>(int) <tt>RecallGrid</tt>(<i>regnum</i>, <i>win</i>)</b>
    <dd><br>This will recall a grid parameter set from a register, and
    update the grid of a drawing window.  The first argument is a
    register index value 0-7.  Register 0 is used internally for the
    "last" value whenever grid parameters are changed, so is probably
    not a good choice unless this behavior is expected.  These are the
    same registers as used with the <a href="xic:grid"><b>Grid
    Setup</b></a> panel, and are associated with the <a
    href="PhysGridReg"><tt>PhysGridReg</tt></a> and <a
    href="ElecGridReg"><tt>ElecGridReg</tt></a> keyword families in
    the technology file.

    <p>
    The second argument represents the drawing window whose grid
    parameters are to be saved.  The value is 0 for the main drawing
    window, and 1-4 for sub-windows.  Note that separate registers
    exist for electrical and physical mode, so register numbers can be
    reused in the two modes.

    <p>
    The return value is 1 on success, 0 if the indicated window does
    not exist.  The change will not be visible until the window is
    redrawn (one can call <a href="Redraw"><tt>Redraw()</tt></a>).
    </dl>
!!LATEX funcs:main3:grid scrfuncs.tex
\begin{description}
%------------------------------------
% 030204
\index{ShowGrid function}
\item{(int) \vt ShowGrid({\it on\/}, {\it win\/})}\\
This function sets whether or not the grid is shown in a window.  If
the first argument is nonzero, the grid will be shown, otherwise the
grid will not be shown.  The second argument is an integer
representing the drawing window:  0 for the main window, and 1--4 for
sub-windows.  The change will not be visible until the window is
redrawn (one can call {\vt Redraw}).  If success, 1 is returned, or 0
is returned if the window does not exist.

%------------------------------------
% 030204
\index{ShowAxes function}
\item{(int) \vt ShowAxes({\it style\/}, {\it win\/})}\\
This function sets the axes presentation style in physical mode
windows.  The first argument is an integer 0--2, where 0 suppresses
drawing of axes, 1 indicates plain axes, and 2 (or anything else)
indicates axes with a box at the origin.  The second argument is an
integer representing the drawing window:  0 for the main window, 1--4
for sub-windows.  Axes are never shown in electrical mode windows.  On
success, 1 is returned.  If the window does not exist or is not
showing a physical view, 0 is returned.  The change will not be
visible until the window is redrawn (one can call {\vt Redraw}).

%------------------------------------
% 030204
\index{SetGridStyle function}
\item{(int) \vt SetGridStyle({\it style}, {\it win\/})}\\
This function sets the line style used for grid rendering.  The first
argument is an integer mask that defines the on-off pattern.  The
pattern starts at the most significant `1' bit and continues through
the least significant bit, and repeats.  Set bits are rendered as the
visible part of the pattern.  If the style is 0, a dot is shown at
each grid point.  Passing -1 will give continuous lines.  The second
argument is an integer representing the drawing window:  0 for the
main window, 1--4 for sub-windows.  The function returns 1 on success, 0
if the window does not exist.  The change will not be visible until
the window is redrawn (one can call {\vt Redraw}).

%------------------------------------
% 030204
\index{GetGridStyle function}
\item{(int) \vt GetGridStyle({\it win\/})}\\
This function returns the line style mask used for rendering the grid
in the given window.  The mask has the interpretation described in the
description of {\vt SetGridStyle}.  The argument is an integer
representing the window:  0 for the main window, and 1--4 for
sub-windows.  If the window does not exist, 0 is returned.

%------------------------------------
% 071110
\index{SetGridCrossSize function}
\item{(int) \vt SetGridCrossSize({\it xsize}, {\it win\/})}\\
This applies only to grids with style 0 (dot grid).  The {\it xsize}
is an integer 0--6 which indicates the number of pixels to draw in the
four compass directions around the central pixel.  Thus, for nonzero
values, the ``dot'' is rendered as a small cross.  The second argument
is an integer representing the drawing window:  0 for the main window,
1--4 for subwindows.  The function returns 1 on success, 0 if the
window does not exist or the style is nonzero.  The change will not be
visible until the window is redrawn (one can call {\vt Redraw}).

%------------------------------------
% 071110
\index{GetGridCrossSize function}
\item{(int) \vt GetGridCrossSize({\it win\/})}\\
This returns an integer 0--6, which will be nonzero only for grid
style 0 (dot grid), and if the ``dots'' are being rendered as small
crosses via a call to {\vt SetGridCrossSize} or otherwise.  The
argument is an integer representing the window:  0 for the main
window, and 1--4 for subwindows.  If the window does not exist, 0 is
returned.

%------------------------------------
% 030204
\index{SetGridOnTop function}
\item{(int) \vt SetGridOnTop({\it ontop}, {\it win\/})}\\
This function sets whether the grid is shown above or below rendered
objects.  If the first argument is nonzero, the grid will be shown
above rendered objects.  The second argument is an integer
representing the drawing window:  0 for the main window and 1--4 for
sub-windows.  The function returns 1 on success, 0 if the window does
not exist.  The change will not be visible until the window is redrawn
(one can call {\vt Redraw}).

%------------------------------------
% 030204
\index{GetGridOnTop function}
\item{(int) \vt GetGridOnTop({\it win\/})}\\
This function returns 1 is the grid is shown on top of objects.  The
argument is an integer representing the drawing window:  0 for the
main window and 1--4 for sub-windows.  If the grid is shown below
rendered objects, 0 is returned.  If the window does not exist, -1 is
returned.

%------------------------------------
% 101412
\index{SetGridCoarseMult function}
\item{(int) \vt SetGridCoarseMult({\it mult\/}, {\it win\/})}\\
This sets the number of fine grid lines per coarse grid line.  The
first argument is an integer 1--50 that provides this multiple (it is
clipped to this range).  If 1, the coarse grid color is used for all
grid lines.  The second argument represents the drawing window whose
grid is being changed, 0 for the main drawing window, and 1--4 for
sub-windows.  The change will not be visible until the window is
redrawn (one can call {\vt Redraw()}).

The return value is 1 on success, 0 if the window does not exist.

%------------------------------------
% 101412
\index{GetGridCoarseMult function}
\item{(int) \vt GetGridCoarseMult({\it win\/})}\\
This returns the number of fine grid lines per coarse grid interval,
as being used in the drawing window indicated by the argument.  The
argument is 0 for the main drawing window, 1--4 for sub-windows.  If
the window does not exist, zero is returned.

%------------------------------------
% 101412
\index{SaveGrid function}
\item{(int) \vt SaveGrid({\it regnum\/}, {\it win\/})}\\
This will save a grid parameter set to a register.  The first argument
is a register index value 0--7.  Register 0 is used internally for the
``last'' value whenever grid parameters are changed, so is probably
not a good choice unless this behavior is expected.  These are the
same registers as used with the {\cb Grid Setup} panel, and are
associated with the {\vt PhysGridReg} and {\vt ElecGridReg} keyword
families in the technology file.

The second argument represents the drawing window whose grid
parameters are to be saved.  The value is 0 for the main drawing
window, and 1--4 for sub-windows.  Note that separate registers exist
for electrical and physical mode, so register numbers can be reused in
the two modes.

The return value is 1 on success, 0 if the indicated window does not
exist, or the register value is out of range.

%------------------------------------
% 101412
\index{RecallGrid function}
\item{(int) \vt RecallGrid({\it regnum\/}, {\it win\/})}\\
This will recall a grid parameter set from a register, and update the
grid of a drawing window.  The first argument is a register index
value 0--7.  Register 0 is used internally for the ``last'' value
whenever grid parameters are changed, so is probably not a good choice
unless this behavior is expected.  These are the same registers as
used with the {\cb Grid Setup} panel, and are associated with the {\vt
PhysGridReg} and {\vt ElecGridReg} keyword families in the technology
file.

The second argument represents the drawing window whose grid
parameters are to be saved.  The value is 0 for the main drawing
window, and 1--4 for sub-windows.  Note that separate registers exist
for electrical and physical mode, so register numbers can be reused in
the two modes.

The return value is 1 on success, 0 if the indicated window does not
exist.  The change will not be visible until the window is redrawn
(one can call {\vt Redraw()}).

\end{description}

!!SEEALSO
funcs:main3

!!KEYWORD
funcs:main3:curlyr
!!TITLE
Current Layer
!!HTML
    <!-- 101312 -->
    <a name="GetCurLayer"></a>
    <dl>
    <dt><b>(string) <tt>GetCurLayer</tt>()</b>
    <dd><br>This function returns a string containing the name of the
    current layer.  If no current layer is defined, a null string is
    returned.
    </dl>
    <hr>

    <!-- 101312 -->
    <a name="GetCurLayerIndex"></a>
    <dl>
    <dt><b>(int) <tt>GetCurLayerIndex</tt>()</b>
    <dd><br>This function returns the 1-based index of the current
    layer in the layer table.  If no current layer is defined, 0 is
    returned.
    </dl>
    <hr>

    <!-- 030115 -->
    <a name="SetCurLayer"></a>
    <dl>
    <dt><b>(int) <tt>SetCurLayer</tt>(<i>stdlyr</i>)</b>
    <dd><br>This function sets the current layer as indicated by the
    <a href="stdlyr">standard layer</a> argument.  The return value is
    the 1-based index of the previous current layer in the layer
    table, or 0 if there was no current layer.  This return can be
    passed as the argument to revert to the previous current layer.
    </dl>
    <hr>

    <!-- 030115 -->
    <a name="SetCurLayerFast"></a>
    <dl>
    <dt><b>(int) <tt>SetCurLayerFast</tt>(<i>stdlyr</i>)</b>
    <dd><br>
    This is like <tt>GetCurLayer</tt>, but there is no visible update,
    i.e., the layer table indication, and the current layer shown in
    various pop-ups, is unchanged.  This is for speed when drawing. 
    When drawing is finished, this should be called with the original
    current layer, or <tt>SetCurLayer</tt> should be called with some
    layer.  The return value is the 1-based index of the previous
    current layer in the layer table, or 0 if there was no current
    layer.  This return can be passed as the argument to revert to the
    previous current layer.
    </dl>
    <hr>

    <!-- 030115 -->
    <a name="NewCurLayer"></a>
    <dl>
    <dt><b>(int) <tt>NewCurLayer</tt>(<i>stdlyr</i>)</b>
    <dd><br>If the <a href="stdlyr">standard layer</a> argument
    matches an existing layer, the current layer is set to that layer. 
    Otherwise, a new layer is created, if possible, and the current
    layer is set to the new layer.  The function will fail if it is
    not possible to create a new layer, for example if the name is not
    a valid layer name.

    <p>
    If the name is not in the <i>layer</i><tt>:</tt><i>purpose</i>
    form, any new layer created will use the default
    "<tt>drawing</tt>" purpose.

    <p>
    The return value is the 1-based index of the previous current
    layer in the layer table, or 0 if there was no current layer. 
    This return can be passed as the argument to revert to the
    previous current layer.
    </dl>
    <hr>

    <!-- 101312 -->
    <a name="GetCurLayerAlias"></a>
    <dl>
    <dt><b>(string) <tt>GetCurLayerAlias</tt>()</b>
    <dd><br>This function is deprecated, see <a
    href="GetLayerAlias"><tt>GetLayerAlias</tt></a>.  Return the alias
    name of the current layer, or a null string if there is no alias.
    </dl>
    <hr>

    <!-- 101312 -->
    <a name="SetCurLayerAlias"></a>
    <dl>
    <dt><b>(int) <tt>SetCurLayerAlias</tt>(<i>alias</i>)</b>
    <dd><br> This function is deprecated, see <a
    href="SetLayerAlias"><tt>SetLayerAlias</tt></a>.  Set the alias
    name of the current layer.  Returns 1 on success, 0 otherwise
    (possibly indicating a name clash).
    </dl>
    <hr>

    <!-- 101312 -->
    <a name="GetCurLayerDescr"></a>
    <dl>
    <dt><b>(string) <tt>GetCurLayerDescr</tt>()</b>
    <dd><br>This function is deprecated, see <a
    href="GetLayerDescr"><tt>GetLayerDescr</tt></a>.  Return the
    description string of the current layer.  This will be null if no
    description has been set.
    </dl>
    <hr>

    <!-- 101312 -->
    <a name="SetCurLayerDescr"></a>
    <dl>
    <dt><b>(int) <tt>SetCurLayerDescr</tt>(<i>descr</i>)</b>
    <dd><br>This function is deprecated, see <a
    href="SetLayerDescr"><tt>SetLayerDescr</tt></a>.  Set the
    description string of the current layer.  The return value is
    always 1.
    </dl>
    <hr>
!!LATEX funcs:main3:curlyr scrfuncs.tex
\begin{description}
%------------------------------------
% 101312
\index{GetCurLayer function}
\item{(string) \vt GetCurLayer()}\\
This function returns a string containing the name of the current
layer.  If no current layer is defined, a null string is returned.

%------------------------------------
% 101312
\index{GetCurLayerIndex function}
\item{(int) \vt GetCurLayerIndex()}\\
This function returns the 1-based index of the current layer in the
layer table.  If no current layer is defined, 0 is returned.

%------------------------------------
% 030115
\index{SetCurLayer function}
\item{(int) \vt SetCurLayer({\it stdlyr\/})}\\
This function sets the current layer as indicated by the standard
layer argument.  The return value is the 1-based index of the previous
current layer in the layer table, or 0 if there was no current layer. 
This return can be passed as the argument to revert to the previous
current layer.

%------------------------------------
% 030115
\index{SetCurLayerFast function}
\item{(int) \vt SetCurLayerFast({\it stdlyr\/})}\\
This is like {\vt GetCurLayer}, but there is no visible update, i.e.,
the layer table indication, and the current layer shown in various
pop-ups, is unchanged.  This is for speed when drawing.  When drawing
is finished, this should be called with the original current layer, or
{\vt SetCurLayer} should be called with some layer.  The return value
is the 1-based index of the previous current layer in the layer table,
or 0 if there was no current layer.  This return can be passed as the
argument to revert to the previous current layer. 

%------------------------------------
% 030115
\index{NewCurLayer function}
\item{(int) \vt NewCurLayer({\it stdlyr\/})}\\
If the standard layer argument matches an existing layer, the current
layer is set to that layer.  Otherwise, a new layer is created, if
possible, and the current layer is set to the new layer.  The function
will fail if it is not possible to create a new layer, for example if
the name is not a valid layer name.

If the name is not in the {\it layer\/}{\vt :}{\it purpose} form, any
new layer created will use the default ``{\vt drawing}'' purpose.

The return value is the 1-based index of the previous current layer in
the layer table, or 0 if there was no current layer.  This return can
be passed as the argument to revert to the previous current layer.

%------------------------------------
% 101312
\index{GetCurLayerAlias function}
\item{(string) \vt GetCurLayerAlias()}\\
This function is deprecated, see {\vt GetLayerAlias}.  Return the
alias name of the current layer, or a null string if there is no
alias.

%------------------------------------
% 101312
\index{SetCurLayerAlias function}
\item{(int) \vt SetCurLayerAlias({\it alias\/})}\\
This function is deprecated, see {\vt SetLayerAlias}.  Set the alias
name of the current layer.  Returns 1 on success, 0 otherwise
(possibly indicating a name clash).

%------------------------------------
% 101312
\index{GetCurLayerDescr function}
\item{(string) \vt GetCurLayerDescr()}\\
This function is deprecated, see {\vt GetLayerDescr}.  Return the
description string of the current layer.  This will be null if no
description has been set.

%------------------------------------
% 101312
\index{SetCurLayerDescr function}
\item{(int) \vt SetCurLayerDescr({\it descr\/})}\\
This function is deprecated, see {\vt SetLayerDescr}.  Set the
description string of the current layer.  The return value is always
1.
\end{description}

!!SEEALSO
funcs:main3

!!KEYWORD
funcs:main3:ltab
!!TITLE
Layer Table
!!HTML
    <!-- 101312 -->
    <a name="LayersUsed"></a>
    <dl>
    <dt><b>(int) <tt>LayersUsed</tt>()</b>
    <dd><br>This returns a count of the layers in the layer table for
    the current display mode.
    </dl>
    <hr>

    <!-- 101312 -->
    <a name="AddLayer"></a>
    <dl>
    <dt><b>(int) <tt>AddLayer</tt>(<i>name</i>, <i>index</i>)</b>
    <dd><br>
    This adds the named layer to the layer table, in the position
    specified by the integer second argument.  If the second argument
    is negative, the new layer will be added at the end, above all
    existing layers.  If the index is 0, the new layer will be
    positioned at the index of the current layer, and the current
    layer and those above moved up.  Otherwise, the index is a 1-based
    index into the layer table, where the new layer will be inserted. 
    The layer at that index and those above will be moved up.

    <p>
    The name can match the name of an existing layer that has been
    removed from the layer table.  It can also be a unique new name,
    and a new layer will be created.  If the name matches an existing
    layer in the table, a new layer will also be created, but with an
    internally generated name.

    <p>
    The function will return 0 if it is not possible to create a new
    layer, for example if the name is not a valid layer name.  On
    success 1 is returned.

    <p>
    If the name is not in the <i>layer</i><tt>:</tt><i>purpose</i>
    form, any new layer created will use the default
    "<tt>drawing</tt>" purpose.
    </dl>
    <hr>

    <!-- 101312 -->
    <a name="RemoveLayer"></a>
    <dl>
    <dt><b>(int) <tt>RemoveLayer</tt>(<i>stdlyr</i>)</b>
    <dd><br>This removes the layer indicated by the <a
    href="stdlyr">standard layer</a> argument from the layer table if
    found.  This returns 1 if the layer is found and removed, 0
    otherwise.
    </dl>
    <hr>

    <!-- 101312 -->
    <a name="RenameLayer"></a>
    <dl>
    <dt><b>(int) <tt>RenameLayer</tt>(<i>oldname</i>, <i>newname</i>)</b>
    <dd><br>The <i>oldname</i> is a <a href="stdlyr">standard
    layer</a> argument.  The <i>newname</i> is a string providing a
    new layer/purpose name in the
    <i>layer</i>[<tt>:</tt><i>purpose</i>] form.  If no purpose field
    is given, the default "<tt>drawing</tt>" purpose is assumed.  This
    renames the layer specified in <i>oldname</i> to <i>newname</i>. 
    The renamed layer will have any alias name removed.

    <p>
    This fails if <i>oldname</i> is unresolved or <i>newname</i> is
    null, and returns 0 on error, with an error message available from
    <a href="GetError"><tt>GetError</tt></a>.
    </dl>
    <hr>

    <!-- 101312 -->
    <a name="LayerHandle"></a>
    <dl>
    <dt><b>(stringlist_handle) <tt>LayerHandle</tt>(<i>down</i>)</b>
    <dd><br>This function returns a handle to a list of the layer
    names from the layer table.  If the argument is 0, the list is in
    ascending order.  If the argument is nonzero, the list is in
    descending order.  The layers used in the current display mode are
    listed.
    </dl>
    <hr>

    <!-- 101312 -->
    <a name="GenLayers"></a>
    <dl>
    <dt><b>(string) <tt>GenLayers</tt>(<i>stringlist_handle</i>)</b>
    <dd><br>This function returns a string containing a layer name
    from the layer table.  The argument is the handle returned by
    <tt>LayerHandle</tt>.  A different layer is returned for each
    call.  The null string is returned after all layers have been
    cycled through.  This is equivalent to <a
    href="ListNext"><tt>ListNext</tt></a>.
    </dl>
    <hr>

    <!-- 101312 -->
    <a name="GetLayerPalette"></a>
    <dl>
    <dt><b>(stringlist_handle) <tt>GetLayerPalette</tt>(<i>regnum</i>)</b>
    <dd><br>The argument is an integer 0-7 corresponding to a layer
    palette register, as used with the <a href="xic:lpal"><b>Layer
    Palette</b></a> panel, and associated with the <a
    href="PhysLayerPalette"><tt>PhysLayerPalette</tt></a> and <a
    href="ElecLayerPalette"><tt>ElecLayerPalette</tt></a> technology
    file keyword families.  The return value is a stringlist handle,
    where the strings are the names of layers saved in the indexed
    palette register corresponding to the display mode of the main
    drawing window.

    <p>
    If the palette register is empty, or the argument is out of range,
    a scalar 0 is returned.

    <p>
    The register with index 0 is used internally to save the last
    <b>Layer Palette</b> user area before it pops down.  Thus, this
    index should not be used unless this behavior is expected.
    </dl>
    <hr>

    <!-- 101312 -->
    <a name="SetLayerPalette"></a>
    <dl>
    <dt><b>(int) <tt>SetLayerPalette</tt>(<i>list</i>, <i>regnum</i>)</b>
    <dd><br>The second argument is an integer 0-7 corresponding to a
    layer palette register, as used with the <a
    href="xic:lpal"><b>Layer Palette</b></a> panel, and associated
    with the <a href="PhysLayerPalette"><tt>PhysLayerPalette</tt></a>
    and <a href="ElecLayerPalette"><tt>ElecLayerPalette</tt></a>
    technology file keyword families.

    <p>
    The first argument provides a list of layers, or null, to be saved
    in the indexed palette register corresponding to the display mode
    of the main drawing window.  If the argument is a scalar 0, or a
    null string, the palette register will be cleared.  Otherwise this
    argument can be a string consisting of space-separated layer
    names, or a stringlist handle, where the strings are layer names. 
    The handle is unaffected by this function call.

    <p>
    The function returns 1 on success, 0 if the register index is out
    of range.  The call will fail (halt the script) if a bad argument
    is passed.

    <p>
    There is no checking of the validity of the string saved as palette
    register data.
    </dl>
    <hr>
!!LATEX funcs:main3:ltab scrfuncs.tex
\begin{description}
%------------------------------------
% 101312
\index{LayersUsed function}
\item{(int) \vt LayersUsed()}\\
This returns a count of the layers in the layer table for the current
display mode.

%------------------------------------
% 101312
\index{AddLayer function}
\item{(int) \vt AddLayer({\it name\/}, {\it index\/})}\\
This adds the named layer to the layer table, in the position
specified by the integer second argument.  If the second argument is
negative, the new layer will be added at the end, above all existing
layers.  If the index is 0, the new layer will be positioned at the
index of the current layer, and the current layer and those above
moved up.  Otherwise, the index is a 1-based index into the layer
table, where the new layer will be inserted.  The layer at that index
and those above will be moved up.

The name can match the name of an existing layer that has been
removed from the layer table.  It can also be a unique new name,
and a new layer will be created.  If the name matches an existing
layer in the table, a new layer will also be created, but with an
internally generated name.

The function will return 0 if it is not possible to create a new
layer, for example if the name is not a valid layer name.  On
success 1 is returned.

If the name is not in the {\it layer\/}{\vt :}{\it purpose} form, any
new layer created will use the default ``{\vt drawing}'' purpose.

%------------------------------------
% 101312
\index{RemoveLayer function}
\item{(int) \vt RemoveLayer({\it stdlyr]/})}\\
This removes the layer indicated by the standard layer argument from
the layer table if found.  This returns 1 if the layer is found and
removed, 0 otherwise.

%------------------------------------
% 101312
\index{RenameLayer function}
\item{(int) \vt RenameLayer({\it oldname\/}, {\it newname\/})}\\
The {\it oldname} is a standard layer argument.  The {\it newname} is
a string providing a new layer/purpose name in the {\it layer\/}[{\vt
:}{\it purpose\/}] form.  If no purpose field is given, the default
``{\vt drawing}'' purpose is assumed.  This renames the layer
specified in {\it oldname} to {\it newname\/}.  The renamed layer will
have any alias name removed.

This fails if {\it oldname} is unresolved or {\it newname} is null,
and returns 0 on error, with an error message available from {\vt
GetError}.

%------------------------------------
% 101312
\index{LayerHandle function}
\item{(stringlist\_handle) \vt LayerHandle({\it down\/})}\\
This function returns a handle to a list of the layer names from the
layer table.  If the argument is 0, the list is in ascending order. 
If the argument is nonzero, the list is in descending order.  The
layers used in the current display mode are listed.

%------------------------------------
% 101312
\index{GenLayers function}
\item{(string) \vt GenLayers({\it stringlist\_handle\/})}\\
This function returns a string containing a layer name from the layer
table.  The argument is the handle returned by {\vt LayerHandle}.  A
different layer is returned for each call.  The null string is
returned after all layers have been cycled through.  This is
equivalent to {\vt ListNext}.

%------------------------------------
% 101312
\index{GetLayerPalette function}
\item{(stringlist\_handle) \vt GetLayerPalette({\it regnum})}\\
The argument is an integer 0--7 corresponding to a layer palette
register, as used with the {\cb Layer Palette} panel, and associated
with the {\vt PhysLayerPalette} and {\vt ElecLayerPalette} technology
file keyword families.  The return value is a stringlist handle, where
the strings are the names of layers saved in the indexed palette
register corresponding to the display mode of the main drawing window.

If the palette register is empty, or the argument is out of range, a
scalar 0 is returned.

The register with index 0 is used internally to save the last {\cb
Layer Palette} user area before it pops down.  Thus, this index should
not be used unless this behavior is expected.

%------------------------------------
% 101312
\index{SetLayerPalette function}
\item{(int) \vt SetLayerPalette({\it list\/}, {\it regnum\/})}\\
The second argument is an integer 0--7 corresponding to a layer
palette register, as used with the {\cb Layer Palette} panel, and
associated with the {\vt PhysLayerPalette} and {\vt ElecLayerPalette}
technology file keyword families.

The first argument provides a list of layers, or null, to be saved
in the indexed palette register corresponding to the display mode
of the main drawing window.  If the argument is a scalar 0, or a
null string, the palette register will be cleared.  Otherwise this
argument can be a string consisting of space-separated layer
names, or a stringlist handle, where the strings are layer names.
The handle is unaffected by this function call.

The function returns 1 on success, 0 if the register index is out
of range.  The call will fail (halt the script) if a bad argument
is passed.

There is no checking of the validity of the string saved as palette
register data.

\end{description}

!!SEEALSO
funcs:main3

!!KEYWORD
funcs:main3:ldb
!!TITLE
Layer Database
!!HTML
    <!-- 032017 -->
    <a name="GetLayerNum"></a>
    <dl>
    <dt><b>(int) <tt>GetLayerNum</tt>(<i>name</i>)</b>
    <dd><br>Return the component layer number given the component
    layer name.  This is the <i>layer</i> part of the general
    <i>layer</i>[<tt>:</tt><i>purpose</i>] layer name used in
    <i>Xic</i>.  Each such name has a corresponding number in the
    database.  If the name is not found, the return value is -1,
    which is reserved and is not a valid component layer number.
    </dl>
    <hr>

    <!-- 032017 -->
    <a name="GetLayerName"></a>
    <dl>
    <dt><b>(string) <tt>GetLayerName</tt>(<i>num</i>)</b>
    <dd><br>Return the component layer name given the component layer
    number.  If there is no name associated with the number, a null
    string is returned.
    </dl>
    <hr>

    <!-- 101312 -->
    <a name="IsPurposeDefined"></a>
    <dl>
    <dt><b>(int) <tt>IsPurposeDefined</tt>(<i>name</i>)</b>
    <dd><br>This returns 1 if the name matches a known purpose, 0
    otherwise.
    </dl>
    <hr>

    <!-- 101312 -->
    <a name="GetPurposeNum"></a>
    <dl>
    <dt><b>(int) <tt>GetPurposeNum</tt>(<i>name</i>)</b>
    <dd><br>This will return a purpose number associated with the
    name.  If the name is not recognized, is null or empty, or matches
    "<tt>drawing</tt>" without case sensitivity, -1 is returned.  This
    is the <tt>drawing</tt> purpose number.
    </dl>
    <hr>

    <!-- 101312 -->
    <a name="GetPurposeName"></a>
    <dl>
    <dt><b>(string) <tt>GetPurposeName</tt>(<i>num</i>)</b>
    <dd><br>Return a string giving the purpose name corresponding to
    the passed purpose number.  If the purpose number is not
    recognized, or is the <tt>drawing</tt> purpose value of -1, a null
    string is returned.
    </dl>
    <hr>
!!LATEX funcs:main3:ldb scrfuncs.tex
\begin{description}
%------------------------------------
% 032017
\index{GetLayerNum function}
\item{(int) \vt GetLayerNum({\it name\/})}\\
Return the component layer number given the component layer name. 
This is the {\it layer} part of the general {\it layer\/}[{\vt :}{\it
purpose\/}] layer name used in {\Xic}.  Each such name has a
corresponding number in the database.  If the name is not found, the
return value is -1, which is reserved and is not a valid component
layer number.

%------------------------------------
% 032017
\index{GetLayerName function}
\item{(string) \vt GetLayerName({\it num\/})}\\
Return the component layer name given the component layer number.  If
there is no name associated with the number, a null string is
returned.

%------------------------------------
% 101312
\index{IsPurposeDefined function}
\item{(int) \vt IsPurposeDefined({\it name\/})}\\
This returns 1 if the name matches a known purpose, 0 otherwise.

%------------------------------------
% 101312
\index{GetPurposeNum function}
\item{(int) \vt GetPurposeNum({\vt name\/})}\\
This will return a purpose number associated with the name.  If the
name is not recognized, is null or empty, or matches ``{\vt drawing}''
without case sensitivity, -1 is returned.  This is the {\vt drawing}
purpose number.

%------------------------------------
% 101312
\index{GetPurposeName function}
\item{(string) \vt GetPurposeName({\it num\/})}\\
Return a string giving the purpose name corresponding to the passed
purpose number.  If the purpose number is not recognized, or is the
{\vt drawing} purpose value of -1, a null string is returned.

\end{description}

!!SEEALSO
funcs:main3

!!KEYWORD
funcs:main3:layer
!!TITLE
Layers
!!HTML
    <!-- 032017 -->
    <a name="GetLayerLayerNum"></a>
    <dl>
    <dt><b>(int) <tt>GetLayerLayerNum</tt>(<i>stdlyr</i>)</b>
    <dd><br>Return the component layer number associated with the
    layer indicated by the <a href="stdlyr">standard layer</a>
    argument.
    </dl>
    <hr>

    <!-- 032017 -->
    <a name="GetLayerPurposeNum"></a>
    <dl>
    <dt><b>(int) <tt>GetLayerPurposeNum</tt>(<i>stdlyr</i>)</b>
    <dd><br>Return the purpose number associated with the layer
    indicated by the <a href="stdlyr">standard layer</a> argument.
    </dl>
    <hr>

    <!-- 101312 -->
    <a name="GetLayerAlias"></a>
    <dl>
    <dt><b>(string) <tt>GetLayerAlias</tt>(<i>stdlyr</i>)</b>
    <dd><br>This function returns a string containing the alias name
    of the layer indicated by the <a href="stdlyr">standard layer</a>
    argument.  The string will be null if no alias is set.
    </dl>
    <hr>

    <!-- 101312 -->
    <a name="SetLayerAlias"></a>
    <dl>
    <dt><b>(int) <tt>SetLayerAlias</tt>(<i>stdlyr</i>, <i>alias</i>)</b>
    <dd><br>This function sets the alias name of the layer indicated
    by the <a href="stdlyr">standard layer</a> first argument to the
    string given as the second argument, as for the <a
    href="LppName"><tt>LppName</tt></a> technology file keyword.  The
    alias name is an optional secondary name for a layer/purpose pair. 
    Most if not all functions that take a layer name argument will
    also accept an alias name.

    <p>
    The alias name will hide other layers if there is a name clash. 
    This can be used for layer remapping, but the user must be careful
    with this.  Layer name comparisons are case-insensitive.

    <p>
    Unlike the normal layer names, the alias name can have arbitrary
    punctuation, embedded white space, etc.  However, leading and
    trailing white space is removed, and if the resulting string is
    empty or null, the existing alias name (if any) will be removed.

    <p>
    The function returns 1 if the alias name is applied to the layer,
    0 if an error occurs.  It is not possible to set the same name on
    more than one layer.
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="GetLayerDescr"></a>
    <dl>
    <dt><b>(string) <tt>GetLayerDescr</tt>(<i>stdlyr</i>)</b>
    <dd><br>
    This function returns a string containing the description of the
    layer indicated by the argument, which is a <a
    href="stdlyr">standard layer</a> argument or a <a
    href="drvlayer">derived layer</a> name string.  If no description
    has been set, a null string is returned.
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="SetLayerDescr"></a>
    <dl>
    <dt><b>(int) <tt>SetLayerDescr</tt>(<i>stdlyr</i>, <i>descr</i>)</b>
    <dd><br>
    This function sets the description of the layer indicated by the
    first argument, which is a <a href="stdlyr">standard layer</a>
    argument or a <a href="drvlayer">derived layer</a> name string, to
    the string given as the second argument.  The description is an
    optional text string associated with the layer.  The function
    always returns 1.
    </dl>
    <hr>

    <!-- 101312 -->
    <a name="IsLayerDefined"></a>
    <dl>
    <dt><b>(int) <tt>IsLayerDefined</tt>(<i>name</i>)</b>
    <dd><br>The string argument contains a layer name.  This can be
    the standard <i>layer</i>[<tt>:</tt><i>purpose</i>] form, or can
    be an alias name.  This function returns 1 if the argument can be
    resolved as the name of a layer in the layer table, in the current
    (electrical/physical) mode.  If the layer can't be resolved, 0 is
    returned.  The function will fail fatally if the argument is null
    or empty.
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="IsLayerVisible"></a>
    <dl>
    <dt><b>(int) <tt>IsLayerVisible</tt>(<i>stdlyr</i>)</b>
    <dd><br>
    The function returns 1 if the layer indicated by the argument,
    which is a <a href="stdlyr">standard layer</a> argument or a <a
    href="drvlayer">derived layer</a> name string, is currently
    visible (i.e., the visibility flag is set), 0 otherwise.  If the
    layer is derived, the return is the flag status, derived layers
    are never actually visible.
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="SetLayerVisible"></a>
    <dl>
    <dt><b>(int) <tt>SetLayerVisible</tt>(<i>stdlyr</i>, <i>visible</i>)</b>
    <dd><br>
    This will set the visibility of the layer indicated in the first
    argument, which is a <a href="stdlyr">standard layer</a> argument
    or a <a href="drvlayer">derived layer</a> name string.  The layer
    will be visible if the boolean second argument is nonzero,
    invisible otherwise.  The previous visibility status is returned. 
    If the layer is derived, the flag status is set, however derived
    layers are never visible.
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="IsLayerSelectable"></a>
    <dl>
    <dt><b>(int) <tt>IsLayerSelectable</tt>(<i>stdlyr</i>)</b>
    <dd><br>
    The function returns 1 if the layer indicated by the argument,
    which is a <a href="stdlyr">standard layer</a> argument or a <a
    href="drvlayer">derived layer</a> name string, is currently
    selectable (i.e., the selectability flag is set), 0 otherwise.
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="SetLayerSelectable"></a>
    <dl>
    <dt><b>(int) <tt>SetLayerSelectable</tt>(<i>stdlyr</i>,
      <i>selectable</i>)</b>
    <dd><br>
    This will set the selectability of the layer indicated in the
    first argument, which is a <a href="stdlyr">standard layer</a>
    argument or a <a href="drvlayer">derived layer</a> name string. 
    The layer will be selectable if the boolean second argument is
    nonzero, not selectable otherwise.  The previous selectability
    status is returned.
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="IsLayerSymbolic"></a>
    <dl>
    <dt><b>(int) <tt>IsLayerSymbolic</tt>(<i>stdlyr</i>)</b>
    <dd><br>
    The function returns 1 if the layer indicated by the argument,
    which is a <a href="stdlyr">standard layer</a> argument or a <a
    href="drvlayer">derived layer</a> name string, is currently
    symbolic (i.e., the <a href="Symbolic"><tt>Symbolic</tt></a>
    attribute is set), 0 otherwise.
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="SetLayerSymbolic"></a>
    <dl>
    <dt><b>(int) <tt>SetLayerSymbolic</tt>(<i>stdlyr</i>, <i>symbolic</i>)</b>
    <dd><br>
    This will set the <a href="Symbolic"><tt>Symbolic</tt></a>
    attribute of the layer indicated in the first argument, which is a
    <a href="stdlyr">standard layer</a> argument or a <a
    href="drvlayer">derived layer</a> name string.  The layer will be
    symbolic if the boolean second argument is nonzero, not symbolic
    otherwise.  The previous symbolic status is returned.
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="IsLayerNoMerge"></a>
    <dl>
    <dt><b>(int) <tt>IsLayerNoMerge</tt>(<i>stdlyr</i>)</b>
    <dd><br>
    The function returns 1 if the <a
    href="NoMerge"><tt>NoMerge</tt></a> attribute is set in the layer
    indicated by the argument, which is a <a href="stdlyr">standard
    layer</a> argument or a <s href="drvlayer">derived layer</a> name
    string, 0 otherwise.
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="SetLayerNoMerge"></a>
    <dl>
    <dt><b>(int) <tt>SetLayerNoMerge</tt>(<i>stdlyr</i>, <i>nomerge</i>)</b>
    <dd><br>
    This will set the <a href="NoMerge"><tt>NoMerge</tt></a> attribute
    of the layer indicated in the first argument, which is a <a
    href="stdlyr">standard layer</a> argument or a <a
    href="drvlayer">derived layer</a> name string.  The layer will be
    given the <tt>NoMerge</tt> attribute if the boolean second
    argument is nonzero, or the attribute will be removed if present
    otherwise.  The previous <tt>NoMerge</tt> status is returned.
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="GetLayerMinDimension"></a>
    <dl>
    <dt><b>(real) <tt>GetLayerMinDimension</tt>(<i>stdlyr</i>)</b>
    <dd><br>
    The return value is the <tt>MinWidth</tt> design rule value in
    microns for the layer indicated by the argument, which is a <a
    href="stdlyr">standard layer</a> argument or a <a
    href="drvlayer">derived layer</a> name string.  If there is no
    <tt>MinWidth</tt> rule, or the DRC package is not available, 0 is
    returned.
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="GetLayerWireWidth"></a>
    <dl>
    <dt><b>(real) <tt>GetLayerWireWidth</tt>(<i>stdlyr</i>)</b>
    <dd><br>
    The function returns the default wire width for the layer
    indicated by the argument, which is a <a href="stdlyr">standard
    layer</a> argument or a <a href="drvlayer">derived layer</a> name
    string.
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="AddLayerGdsOutMap"></a>
    <dl>
    <dt><b>(int) <tt>AddLayerGdsOutMap</tt>(<i>stdlyr</i>, <i>layer_num</i>,
      <i>datatype</i>)</b>
    <dd><br>
    This function will add a mapping from the layer in the first
    argument (a <a href="stdlyr">standard layer</a> argument or a <a
    href="drvlayer">derived layer</a> name string) to the given GDSII
    layer number and data type.  The layer number and data type are
    integers which define the layer in the GDSII world.  When a GDSII
    file is written, the present layer will appear on the given layer
    number and data type in the GDSII file.  It is possible to have
    multiple mappings of the layer, in which case the geometry from
    the named layer will appear on each layer number/data type given.

    <p>
    The function returns 1 on success, or 0 if the layer number or
    data type number is out of range.  The acceptable range for the
    layer number and data type is [0 - 65535].
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="RemoveLayerGdsOutMap"></a>
    <dl>
    <dt><b>(int) <tt>RemoveLayerGdsOutMap</tt>(<i>stdlyr</i>, <i>layer_num</i>,
      <i>datatype</i>)</b>
    <dd><br>
    This function will remove a GDSII output layer mapping for the
    layer indicated in the first argument (a <a href="stdlyr">standard
    layer</a> argument or a <a href=drvlayer">derived layer</a> name
    string).  The mapping may have been applied in the technology
    file, with the <a href="xic:lpedt"><b>Tech Parameter
    Editor</b></a> panel from the <b>Attributes Menu</b>, or by
    calling the <tt>AddLayerGdsOutMap</tt> function.  The mappings
    removed match the given layer number and data type integers
    provided.  These are in the range [-1 - 65535], where the value
    '-1' indicates a wild-card which will match all layer numbers or
    data types.

    <p>
    The return value is -1 if the layer number or data type is out of
    range.  Otherwise, the return value is the number of mappings
    removed.
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="AddLayerGdsInMap"></a>
    <dl>
    <dt><b>(int) <tt>AddLayerGdsInMap</tt>(<i>stdlyr</i>, <i>string</i>)</b>
    <dd><br>
    This function adds a GDSII input mapping record to the layer whose
    name is indicated in the first argument (a <a
    href="stdlyr">standard layer</a> argument or a <a
    href="drvlayer">derived layer</a> name string).  The second
    argument is a string listing the layer numbers and data types
    which will map to the named layer, in the same syntax as used in
    the technology file.  This is "<i>l1 l2-l3</i> ..., <i>d1
    d2-d3</i> ...", where there are two comma separated fields.  The
    left field consists of individual layer numbers and/or ranges of
    layer numbers, similarly the right field consists of individual
    data types and/or ranges of data types.  Each field can have an
    arbitrary number of space-separated terms.  For each layer listed
    or in a range, all of the data types listed or in a range will map
    to the named layer.  There can be multiple input mappings applied
    to the named layer.

    <p>
    The function returns 0 if there was a syntax error.  The function
    returns 1 if the mapping is successfully added.
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="ClearLayerGdsInMap"></a>
    <dl>
    <dt><b>(int) <tt>ClearLayerGdsInMap</tt>(<i>stdlyr</i>)</b>
    <dd><br>
    This function deletes all of the GDSII input mappings applied to
    the layer indicated in the argument, which is a <a
    href="stdlyr">standard layer</a> argument or a <a
    href="drvlayer">derived layer</a> name string.  These mappings may
    have been applied through the technology file, added with the <a
    href="xic:lpedt"><b>Tech Parameter Editor</b></a> from the
    <b>Attributes Menu</b>, or added with the
    <tt>AddLayerGdsInMap</tt> function.  This function returns 0 if
    the layer name does not exist in the symbol table for the current
    display mode (physical or electrical).  Otherwise, the return
    value is the number of mapping records deleted.
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="SetLayerNoDRCdatatype"></a>
    <dl>
    <dt><b>(int) <tt>SetLayerNoDRCdatatype</tt>(<i>stdlyr</i>,
      <i>datatype</i>)</b>
    <dd><br>
    This function assigns a data type to be used for objects with the
    DRC skip flag set.  The first argument is a <a
    href="stdlyr">standard layer</a> argument indicating a physical
    layer, or a <a href="drvlayer">derived layer</a> name string.  The
    second argument is the data type in the range [0 - 65535], or -1. 
    If -1 is given, any previously defined data type is cleared.  The
    function returns 0 if the layer name can't be resolved, or the
    data type is out of range.  The value 1 is returned on success.
    </dl>
!!LATEX funcs:main3:layer scrfuncs.tex
\begin{description}
%------------------------------------
% 032017
\index{GetLayerLayerNum function}
\item{(int) \vt GetLayerLayerNum({\it stdlyr\/})}\\
Return the component layer number associated with the layer indicated
by the standard layer argument.

%------------------------------------
% 032017
\index{GetLayerPurposeNum function}
\item{(int) \vt GetLayerPurposeNum({\it stdlyr\/})}\\
Return the purpose number associated with the layer indicated by the
standard layer argument.

%------------------------------------
% 101312
\index{GetLayerAlias function}
\item{(string) \vt GetLayerAlias({\it stdlyr\/})}\\
This function returns a string containing the alias name of the layer
indicated by the standard layer argument.  The string will be null if
no alias is set.

%------------------------------------
% 101312
\index{SetLayerAlias function}
\item{(int) \vt SetLayerAlias({\it stdlyr\/}, {\it alias\/})}\\
This function sets the alias name of the layer indicated by the
standard layer first argument to the string given as the second
argument, as for the {\vt LppName} technology file keyword.  The alias
name is an optional secondary name for a layer/purpose pair.  Most if
not all functions that take a layer name argument will also accept an
alias name.

The alias name will hide other layers if there is a name clash.  This
can be used for layer remapping, but the user must be careful with
this.  Layer name comparisons are case-insensitive.

Unlike the normal layer names, the alias name can have arbitrary
punctuation, embedded white space, etc.  However, leading and trailing
white space is removed, and if the resulting string is empty or null,
the existing alias name (if any) will be removed.

The function returns 1 if the alias name is applied to the layer, 0 if
an error occurs.  It is not possible to set the same name on more than
one layer.

%------------------------------------
% 120114
\index{GetLayerDescr function}
\item{(string) \vt GetLayerDescr({\it stdlyr\/})}\\
This function returns a string containing the description of the layer
indicated by the argument, which is a standard layer argument or
derived layer name string.  If no description has been set, a null
string is returned.

%------------------------------------
% 120114
\index{SetLayerDescr function}
\item{(int) \vt SetLayerDescr({\it stdlyr\/}, {\it descr\/})}\\
This function sets the description of the layer indicated by the first
argument, which is a standard layer argument or a derived layer name
string, to the string given as the second argument.  The description
is an optional text string associated with the layer.  The function
always returns 1.

%------------------------------------
% 101312
\index{IsLayerDefined function}
\item{(int) \vt IsLayerDefined({\it name\/})}\\
The string argument contains a layer name.  This can be the standard
{\it layer\/}[{\vt :}{\it purpose\/}] form, or can be an alias name. 
This function returns 1 if the argument can be resolved as the name of
a layer in the layer table, in the current (electrical/physical) mode. 
If the layer can't be resolved, 0 is returned.  The function will fail
fatally if the argument is null or empty.

%------------------------------------
% 120114
\index{IsLayerVisible function}
\item{(int) \vt IsLayerVisible({\it stdlyr\/})}\\
The function returns 1 if the layer indicated by the argument, which
is a standard layer argument or a derived layer name string, is
currently visible (i.e., the visibility flag is set), 0 otherwise.  If
the layer is derived, the return is the flag status, derived layers
are never actually visible.

%------------------------------------
% 120114
\index{SetLayerVisible function}
\item{(int) \vt SetLayerVisible({\it stdlyr\/}, {\it visible\/})}\\
This will set the visibility of the layer indicated in the first
argument, which is a standard layer argument or a derived layer name
string.  The layer will be visible if the boolean second argument is
nonzero, invisible otherwise.  The previous visibility status is
returned.  If the layer is derived, the flag status is set, however
derived layers are never visible.

%------------------------------------
% 120114
\index{IsLayerSelectable function}
\item{(int) \vt IsLayerSelectable({\it stdlyr\/})}\\
The function returns 1 if the layer indicated by the argument, which
is a standard layer argument or a derived layer name string.  is
currently selectable (i.e., the selectability flag is set), 0
otherwise.

%------------------------------------
% 120114
\index{SetLayerSelectable function}
\item{(int) \vt SetLayerSelectable({\it stdlyr\/}, {\it selectable\/})}\\
This will set the selectability of the layer indicated in the first
argument, which is a standard layer argument or a derived layer name
string.  The layer will be selectable if the boolean second argument
is nonzero, not selectable otherwise.  The previous selectability
status is returned.

%------------------------------------
% 120114
\index{IsLayerSymbolic function}
\item{(int) \vt IsLayerSymbolic({\it stdlyr\/})}\\
The function returns 1 if the layer indicated by the argument, which
is a standard layer argument or a derived layer name string, is
currently symbolic (i.e., the {\vt Symbolic} attribute is set), 0
otherwise.

%------------------------------------
% 120114
\index{SetLayerSymbolic function}
\item{(int) \vt SetLayerSymbolic({\it stdlyr\/}, {\it symbolic\/})}\\
This will set the {\vt Symbolic} attribute of the layer indicated in
the first argument, which is a standard layer argument or a derived
layer name string.  The layer will be symbolic if the boolean second
argument is nonzero, not symbolic otherwise.  The previous symbolic
status is returned.

%------------------------------------
% 120114
\index{IsLayerNoMerge function}
\item{(int) \vt IsLayerNoMerge({\it stdlyr\/})}\\
The function returns 1 if the {\vt NoMerge} attribute is set in the
layer indicated by the argument, which is a standard layer argument or
a derived layer name string, 0 otherwise.

%------------------------------------
% 120114
\index{SetLayerNoMerge function}
\item{(int) \vt SetLayerNoMerge({\it stdlyr\/}, {\it nomerge\/})}\\
This will set the {\vt NoMerge} attribute of the layer indicated in
the first argument, which is a standard layer argument or a derived
layer name string.  The layer will be given the {\vt NoMerge}
attribute if the boolean second argument is nonzero, or the attribute
will be removed if present otherwise.  The previous {\vt NoMerge}
status is returned.

%------------------------------------
% 120114
\index{GetLayerMinDimension function}
\item{(real) \vt GetLayerMinDimension({\it stdlyr\/})}\\
The return value is the {\vt MinWidth} design rule value in microns
for the layer indicated by the argument, which is a standard layer
argument or a derived layer name string.  If there is no {\vt
MinWidth} rule, or the DRC package is not available, 0 is returned.

%------------------------------------
% 120114
\index{GetLayerWireWidth function}
\item{(real) \vt GetLayerWireWidth({\it stdlyr\/})}\\
The function returns the default wire width for the layer indicated by
the argument, which is a standard layer argument or a derived layer
name string.

%------------------------------------
% 120114
\index{AddLayerGdsOutMap function}
\item{(int) \vt AddLayerGdsOutMap({\it stdlyr\/}, {\it layer\_num\/},
  {\it datatype\/})}\\
This function will add a mapping from the layer in the first argument
(a standard layer argument or a derived layer name string) to the given
GDSII layer number and data type.  The layer number and data type are
integers which define the layer in the GDSII world.  When a GDSII file
is written, the present layer will appear on the given layer number
and data type in the GDSII file.  It is possible to have multiple
mappings of the layer, in which case the geometry from the named layer
will appear on each layer number/data type given.

The function returns 1 on success, or 0 if the layer number or
data type number is out of range.  The acceptable range for the
layer number and data type is [0 -- 65535].

%------------------------------------
% 120114
\index{RemoveLayerGdsOutMap function}
\item{(int) \vt RemoveLayerGdsOutMap({\it stdlyr\/}, {\it layer\_num\/},
  {\it datatype\/})}\\
This function will remove a GDSII output layer mapping for the layer
indicated in the first argument (a standard layer argument or a
derived layer name string).  The mapping may have been applied in the
technology file, with the {\cb Tech Parameter Editor} panel from the
{\cb Attributes Menu}, or by calling the {\vt AddLayerGdsOutMap}
function.  The mappings removed match the given layer number and data
type integers provided.  These are in the range [-1 -- 65535], where
the value '-1' indicates a wild-card which will match all layer
numbers or data types.

The return value is -1 if the layer number or data type is out of
range.  Otherwise, the return value is the number of mappings
removed.

%------------------------------------
% 120114
\index{AddLayerGdsInMap function}
\item{(int) \vt AddLayerGdsInMap({\it stdlyr\/}, {\it string\/})}\\
This function adds a GDSII input mapping record to the layer whose
name is indicated in the first argument (a standard layer argument or
a derived layer name string).  The second argument is a string listing
the layer numbers and data types which will map to the named layer, in
the same syntax as used in the technology file.  This is ``{\it l1
l2-l3} ..., {\it d1 d2-d3} ...", where there are two comma separated
fields.  The left field consists of individual layer numbers and/or
ranges of layer numbers, similarly the right field consists of
individual data types and/or ranges of data types.  Each field can
have an arbitrary number of space-separated terms.  For each layer
listed or in a range, all of the data types listed or in a range will
map to the named layer.  There can be multiple input mappings applied
to the named layer.

The function returns 0 if there was a syntax error.  The function
returns 1 if the mapping is successfully added.

%------------------------------------
% 120114
\index{ClearLayerGdsInMap function}
\item{(int) \vt ClearLayerGdsInMap({\it stdlyr\/})}\\
This function deletes all of the GDSII input mappings applied to the
layer indicated in the argument, which is a standard layer argument or
a derived layer name string.  These mappings may have been applied
through the technology file, added with the {\cb Tech Parameter
Editor} from the {\cb Attributes Menu}, or added with the {\vt
AddLayerGdsInMap} function.  This function returns 0 if the layer name
does not exist in the symbol table for the current display mode
(physical or electrical).  Otherwise, the return value is the number
of mapping records deleted.

%------------------------------------
% 120114
\index{SetLayerNoDRCdatatype function}
\item{(int) \vt SetLayerNoDRCdatatype({\it stdlyr\/}, {\it datatype\/})}\\
This function assigns a data type to be used for objects with the DRC
skip flag set.  The first argument is a standard layer argument
indicating a physical layer or a derived layer name string.  The
second argument is the data type in the range [0 -- 65535], or -1.  If
-1 is given, any previously defined data type is cleared.  The
function returns 0 if the layer name can't be resolved, or the data
type is out of range.  The value 1 is returned on success.

\end{description}

!!SEEALSO
funcs:main3

!!KEYWORD
funcs:main3:layerex
!!TITLE
Layers - Extraction Support
!!HTML
    <!-- 120114 -->
    These functions mainly support the extraction system, but are
    maintained in the main program and are therefor accepted in
    feature sets where the extraction system is disabled.

    <p>
    Many of the layer-related functions take a "standard layer
    argument".  This can be an integer index number into the layer
    table, where the index is 1-based, and values less than 1 return
    the current layer.  The argument can also be a string, giving a
    layer name in <i>layer</i>[<tt>:</tt><i>purpose</i>] form, or an
    alias name.  If the string is null or empty, the current layer is
    returned.

    <!-- 120114 -->
    <a name="SetLayerExKeyword"></a>
    <dl>
    <dt><b>(string) <tt>SetLayerExKeyword</tt>(<i>stdlyr</i>,
      <i>string</i>)</b>
    <dd><br>
    The first argument is a <a href="stdlyr">standard layer</a>
    argument indicating a physical layer, or a <a
    href="drvlayer">derived layer</a> name string.  The <i>string</i>
    argument is an extraction keyword and associated text, as would
    appear in a <a href="ext:setup">layer block</a> in the <a
    href="techfile">technology file</a>.  The specification will be
    applied to the layer, overriding existing settings and possibly
    causing incompatible or redundant existing keywords to be deleted. 
    This is similar to the editing functions of the <a
    href="xic:lpedt"><b>Tech Parameter Editor</b></a> from the <a
    href="xic:attrmenu"><b>Attributes Menu</b></a>, when using the
    <b>Extract</b> or <b>Physical</b> pages.

    <p>
    The return is a status or error string, which may be null.

    <p>
    The following keywords can be specified:
    <blockquote>
    <tt>
    Conductor<br>
    Routing<br>
    GroundPlane<br>
    GroundPlaneDark<br>
    GroundPlaneClear<br>
    TermDefault<br>
    Contact<br>
    Via<br>
    Dielectric<br>
    DarkField<br>
    Thickness<br>
    Rho<br>
    Sigma<br>
    Rsh<br>
    EpsRel<br>
    Capacitance<br>
    Lambda<br>
    Tline<br>
    Antenna
    </tt>
    </blockquote>
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="SetCurLayerExKeyword"></a>
    <dl>
    <dt><b>(string) <tt>SetCurLayerExKeyword</tt>(<i>string</i>)</b>
    <dd><br>
    This is similar to <tt>SetLayerExKeyword</tt>, but applies to the
    current layer.  This function is deprecated and not recommended
    for use in new scripts.
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="RemoveLayerExKeyword"></a>
    <dl>
    <dt><b>(int) <tt>RemoveLayerExKeyword</tt>(<i>stdlyr</i>,
      <i>keyword</i>)</b>
    <dd><br>
    The first argument is a <a href="stdlyr">standard layer</a>
    argument indicating a physical layer, or a <a
    href="drvlayer">derived layer</a> name string.  This will remove
    the specification for the extract keyword given in the argument
    from the layer.  The argument must be one of the extraction
    keywords, i.e., those listed for <tt>SetCurLayerExKeyword</tt>. 
    The return value is 1 if a specification was removed, 0 otherwise.
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="RemoveCurLayerExKeyword"></a>
    <dl>
    <dt><b>(int) <tt>RemoveCurLayerExKeyword</tt>(<i>keyword</i>)</b>
    <dd><br>
    This is similar to <tt>RemoveLayerExKeyword</tt> but applies to
    the current layer.  This function is deprecated and not
    recommended for use in new scripts.
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="IsLayerConductor"></a>
    <dl>
    <dt><b>(int) <tt>IsLayerConductor</tt>(<i>stdlyr</i>)</b>
    <dd><br>
    The function returns 1 if the <a
    href="Conductor"><tt>Conductor</tt></a> keyword is given or
    implied for the layer indicated by the argument, which is a <a
    href="stdlyr">standard layer</a> argument or a <a
    href="drvlayer">derived layer</a> name string, 0 otherwise.
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="IsLayerRouting"></a>
    <dl>
    <dt><b>(int) <tt>IsLayerRouting</tt>(<i>stdlyr</i>)</b>
    <dd><br>
    The function returns 1 if the <a
    href="Routing"><tt>Routing</tt></a> keyword is given for the layer
    indicated by the argument, which is a <a href="stdlyr">standard
    layer</a> argument or a <a href="drvlayer">derived layer</a> name
    string, 0 otherwise. 
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="IsLayerGround"></a>
    <dl>
    <dt><b>(int) <tt>IsLayerGround</tt>(<i>stdlyr</i>)</b>
    <dd><br>
    The function returns 1 if one of the <a
    href="GroundPlane"><tt>GroundPlane</tt></a> keywords was given for
    the layer indicated by the argument, which is a <a
    href="stdlyr">standard layer</a> argument or a <a
    href="drvlayer">derived layer</a> name string, 0 otherwise.
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="IsLayerContact"></a>
    <dl>
    <dt><b>(int) <tt>IsLayerContact</tt>(<i>stdlyr</i>)</b>
    <dd><br>
    The function returns 1 if the <a
    href="Contact"><tt>Contact</tt></a> keyword is given for the layer
    indicated by the argument, which is a <a href="stdlyr">standard
    layer</a> argument or a <a href="drvlayer">derived layer</a> name
    string, 0 otherwise. 
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="IsLayerVia"></a>
    <dl>
    <dt><b>(int) <tt>IsLayerVia</tt>(<i>stdlyr</i>)</b>
    <dd><br>
    The function returns 1 if the <a href="Via"><tt>Via</tt></a>
    keyword is given for the layer indicated by the argument, which is
    a <a href="stdlyr">standard layer</a> argument or a <a
    href="drvlayer">derived layer</a> name string, 0 otherwise.
    </dl>
    <hr>

    <!-- 011621 -->
    <a name="IsLayerViaCut"></a>
    <dl>
    <dt><b>(int) <tt>IsLayerViaCut</tt>(<i>stdlyr</i>)</b>
    <dd><br>
    The function returns 1 if the <a href="ViaCut"><tt>ViaCut</tt></a>
    keyword is given for the layer indicated by the argument, which is
    a <a href="stdlyr">standard layer</a> argument or a <a
    href="drvlayer">derived layer</a> name string, 0 otherwise.
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="IsLayerDielectric"></a>
    <dl>
    <dt><b>(int) <tt>IsLayerDielectric</tt>(<i>stdlyr</i>)</b>
    <dd><br>
    The function returns 1 if the <a
    href="Dielectric"><tt>Dielectric</tt></a> keyword is given for the
    layer indicated by the argument, which is a <a
    href="stdlyr">standard layer</a> argument or a <a
    href="drvlayer">derived layer</a> name string, 0 otherwise.
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="IsLayerDarkField"></a>
    <dl>
    <dt><b>(int) <tt>IsLayerDarkField</tt>(<i>stdlyr</i>)</b>
    <dd><br>
    The function returns 1 if the <a
    href="DarkField"><tt>DarkField</tt></a> keyword is given or
    implied for the layer indicated by the argument, which is a <a
    href="stdlyr">standard layer</a> argument or a <a
    href="drvlayer">derived layer</a> name string, 0 otherwise.
    </dl>
    <hr>

    <!-- 101812 -->
    <a name="GetLayerThickness"></a>
    <dl>
    <dt><b>(real) <tt>GetLayerThickness</tt>(<i>stdlyr</i>)</b>
    <dd><br>
    The function returns the value of the <a
    href="Thickness"><tt>Thickness</tt></a> parameter given for the
    layer indicated by the argument, which is a <a
    href="stdlyr">standard layer</a> argument or a <a
    href="drvlayer">derived layer</a> name string.
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="GetLayerRho"></a>
    <dl>
    <dt><b>(real) <tt>GetLayerRho</tt>(<i>stdlyr</i>)</b>
    <dd><br>
    The function returns the resistivity in ohm-meters of the layer
    indicated by the argument, which is a <a href="stdlyr">standard
    layer</a> argument or a <a href="drvlayer">derived layer</a> name
    string, as given by the <tt>Rho</tt> or <tt>Sigma</tt> parameters,
    if given.  If neither of these is given, and <tt>Rsh</tt> and
    <tt>Thickness</tt> are given, the return value will be
    <tt>Rsh*Thickness</tt>.
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="GetLayerResis"></a>
    <dl>
    <dt><b>(real) <tt>GetLayerResis</tt>(<i>stdlyr</i>)</b>
    <dd><br>
    The function returns the sheet resistance for the layer indicated
    by the argument, which is a <a href="stdlyr">standard layer</a>
    argument or a <a href="drvlayer">derived layer</a> name string. 
    This will be the value of the <tt>Rsh</tt> parameter, if given, or
    the values of <tt>Rho</tt>/<tt>Thickness</tt>, if <tt>Rho</tt> or
    <tt>Sigma</tt> and <tt>Thickness</tt> are given, or 0 if no value
    is available.
    </dl>
    <hr>

    <!-- 011621 -->
    <a name="GetLayerTau"></a>
    <dl>
    <dt><b>(real) <tt>GetLayerTau</tt>(<i>stdlyr</i>)</b>
    <dd><br>
    The function returns the Drude relaxation time for the
    layer indicated by the argument, which is a <a
    href="stdlyr">standard layer</a> argument or a <a
    href="drvlayer">derived layer</a> name string.  This will
    be the value of the <a href="Tau"><tt>Tau</tt></a>
    parameter if given to the layer, 0 otherwise.
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="GetLayerEps"></a>
    <dl>
    <dt><b>(real) <tt>GetLayerEps</tt>(<i>stdlyr</i>)</b>
    <dd><br>
    The function returns the relative dielectric constant for the
    layer indicated by the argument, which is a <a
    href="stdlyr">standard layer</a> argument or a <a
    href="drvlayer">derived layer</a> name string, as given by the
    <tt>EpsRel</tt> parameter if applied.
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="GetLayerCap"></a>
    <dl>
    <dt><b>(real) <tt>GetLayerCap</tt>(<i>stdlyr</i>)</b>
    <dd><br>
    The function returns the per-area capacitance for the layer
    indicated by the argument, which is a <a href="stdlyr">standard
    layer</a> argument or a <a href="drvlayer">derived layer</a> name
    string.
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="GetLayerCapPerim"></a>
    <dl>
    <dt><b>(real) <tt>GetLayerCapPerim</tt>(<i>stdlyr</i>)</b>
    <dd><br>
    The function returns the per-perimeter capacitance for the layer
    indicated by the argument, which is a <a href="stdlyr">standard
    layer</a> argument or a <a href="drvlayer">derived layer</a> name
    string.
    </dl>
    <hr>

    <!-- 120114 -->
    <a name="GetLayerLambda"></a>
    <dl>
    <dt><b>(real) <tt>GetLayerLambda</tt>(<i>stdlyr</i>)</b>
    <dd><br>
    The function returns the value of the <tt>Lambda</tt> parameter
    for the layer indicated by the argument, which is a <a
    href="stdlyr">standard layer</a> argument or a <a
    href="drvlayer">derived layer</a> name string.
    </dl>
!!LATEX funcs:main3:layerex scrfuncs.tex
% 120114
These functions mainly support the extraction system, but are
maintained in the main program and are therefor accepted in feature
sets where the extraction system is disabled.

Many of the layer-related functions take a ``standard layer
argument''.  This can be an integer index number into the layer table,
where the index is 1-based, and values less than 1 return the current
layer.  The argument can also be a string, giving a layer name in {\it
layer\/}[{\vt :}{\it purpose\/}] form, or an alias name.  If the
string is null or empty, the current layer is returned.

\begin{description}
%------------------------------------
% 120114
\index{SetLayerExKeyword function}
\item{(string) \vt SetLayerExKeyword({\it stdlyr\/}, {\it string\/})}\\
The first argument is a standard layer argument indicating a physical
layer, or a derived layer name string.  The {\it string} argument is
an extraction keyword and associated text, as would appear in a layer
block in the technology file.  The specification will be applied to
the layer, overriding existing settings and possibly causing
incompatible or redundant existing keywords to be deleted.  This is
similar to the editing functions of the {\cb Tech Parameter Editor}
from the {\cb Attributes Menu}, when using the {\cb Extract} or {\cb
Physical} pages.

The return is a status or error string, which may be null.
  
The following keywords can be specified:
\begin{quote}\vt
    Conductor\\
    Routing\\
    GroundPlane\\
    GroundPlaneDark\\
    GroundPlaneClear\\
    TermDefault\\
    Contact\\
    Via\\
    Dielectric\\
    DarkField\\
    Thickness\\
    Rho\\
    Sigma\\
    Rsh\\
    EpsRel\\
    Capacitance\\
    Lambda\\
    Tline\\
    Antenna
\end{quote}

%------------------------------------
% 120114
\index{SetCurLayerExKeyword function}
\item{(string) \vt SetCurLayerExKeyword({\it string\/})}\\
This is similar to {\vt SetLayerExKeyword}, but applies to the current
layer.  This function is deprecated and not recommended for use in new
scripts.

%------------------------------------
% 120114
\index{RemoveLayerExKeyword function}
\item{(int) \vt RemoveLayerExKeyword({\it stdlyr\/}, {\it keyword\/})}\\
The first argument is a standard layer argument indicating a physical
layer, or a derived layer name string.  This will remove the
specification for the extract keyword given in the argument from the
layer.  The argument must be one of the extraction keywords, i.e.,
those listed for {\vt SetCurLayerExKeyword}.  The return value is 1 if
a specification was removed, 0 otherwise.

%------------------------------------
% 120114
\index{RemoveCurLayerExKeyword function}
\item{(int) \vt RemoveCurLayerExKeyword({\it keyword\/})}\\
This is similar to {\vt RemoveLayerExKeyword} but applies to the
current layer.  This function is deprecated and not recommended for
use in new scripts.

%------------------------------------
% 120114
\index{IsLayerConductor function}
\item{(int) \vt IsLayerConductor({\it stdlyr\/})}\\
The function returns 1 if the {\et Conductor} keyword is given or
implied for the layer indicated by the argument, which is a standard
layer argument or a derived layer name string, 0 otherwise.

%------------------------------------
% 120114
\index{IsLayerRouting function}
\item{(int) \vt IsLayerRouting({\it stdlyr\/})}\\
The function returns 1 if the {\et Routing} keyword is given for the
layer indicated by the argument, which is astandard layer argument or
a derived layer name string, 0 otherwise.

%------------------------------------
% 120114
\index{IsLayerGround function}
\item{(int) \vt IsLayerGround({\it stdlyr\/})}\\
The function returns 1 if one of the {\et GroundPlane} keywords was
given for the layer indicated by the argument, which is a standard
layer argument or a derived layer name string, 0 otherwise.

%------------------------------------
% 120114
\index{IsLayerContact function}
\item{(int) \vt IsLayerContact({\it stdlyr\/})}\\
The function returns 1 if the {\et Contact} keyword is given for the
layer indicated by the argument, which is a standard layer argument or
a derived layer name string, 0 otherwise.

%------------------------------------
% 120114
\index{IsLayerVia function}
\item{(int) \vt IsLayerVia({\it stdlyr\/})}\\
The function returns 1 if the {\et Via} keyword is given for the layer
indicated by the argument, which is a standard layer argument or a
derived layer name string, 0 otherwise.

%------------------------------------
% 011621
\index{IsLayerViaCut function}
\item{(int) \vt IsLayerViaCut({\it stdlyr\/})}\\
The function returns 1 if the {\et ViaCut} keyword is given
for the layer indicated by the argument, which is a standard
layer argument or a derived layer name string, 0 otherwise.

%------------------------------------
% 120114
\index{IsLayerDielectric function}
\item{(int) \vt IsLayerDielectric({\it stdlyr\/})}\\
The function returns 1 if the {\et Dielectric} keyword is given for
the layer indicated by the argument, which is a standard layer
argument or a derived layer name string, 0 otherwise.

%------------------------------------
% 120114
\index{IsLayerDarkField function}
\item{(int) \vt IsLayerDarkField({\it stdlyr\/})}\\
The function returns 1 if the {\et DarkField} keyword is given or
implied for the layer indicated by the argument, which is a standard
layer argument or a derived layer name string, 0 otherwise.

%------------------------------------
% 120114
\index{GetLayerThickness function}
\item{(real) \vt GetLayerThickness({\it stdlyr\/})}\\
The function returns the value of the {\et Thickness} parameter given
for the layer indicated by the argument, which is a standard layer
argument or a derived layer name string.

%------------------------------------
% 120114
\index{GetLayerRho function}
\item{(real) \vt GetLayerRho({\it stdlyr\/})}\\
The function returns the resistivity in ohm-meters of the layer
indicated by the argument, which is a standard layer argument or a
derived layer name string, as given by the {\vt Rho} or {\vt Sigma}
parameters, if given.  If neither of these is given, and {\vt Rsh} and
{\vt Thickness} are given, the return value will be {\vt Rsh}*{\vt
Thickness}.

%------------------------------------
% 120114
\index{GetLayerResis function}
\item{(real) \vt GetLayerResis({\it stdlyr\/})}\\
The function returns the sheet resistance for the layer indicated
by the argument, which is a standard layer argument or a derived layer
name string.  This will be the value of the {\vt Rsh} parameter, if
given, or the values of {\vt Rho}/{\vt Thickness}, if {\vt Rho} or
{\vt Sigma} and {\vt Thickness} are given, or 0 if no value is
available.

%------------------------------------
% 011621
\index{GetLayerTau function}
\item{(real) \vt GetLayerTau({\it stdlyr\/})}\\
The function returns the Drude relaxation time for the layer
indicated by the argument, which is a standard layer argument
or a derived layer name string.  This will be the value of the
{\et Tau} parameter if given to the layer, 0 otherwise.

%------------------------------------
% 120114
\index{GetLayerEps function}
\item{(real) \vt GetLayerEps({\it stdlyr\/})}\\
The function returns the relative dielectric constant for the layer
indicated by the argument, which is a standard layer argument or
derived layer name string, as given by the {\et EpsRel} parameter if
applied.

%------------------------------------
% 120114
\index{GetLayerCap function}
\item{(real) \vt GetLayerCap({\it stdlyr\/})}\\
The function returns the per-area capacitance for the layer indicated
by the argument, which is a standard layer argument or a derived layer
name string.

%------------------------------------
% 120114
\index{GetLayerCapPerim function}
\item{(real) \vt GetLayerCapPerim({\it stdlyr\/})}\\
The function returns the per-perimeter capacitance for the layer
indicated by the argument, which is a standard layer argument or a
derived layer name string.

%------------------------------------
% 120114
\index{GetLayerLambda function}
\item{(real) \vt GetLayerLambda({\it stdlyr\/})}\\
The function returns the value of the {\et Lambda} parameter for the
layer indicated by the argument, which is a standard layer argument or
a derived layer name string.

\end{description}

!!SEEALSO
funcs:main3

!!KEYWORD
funcs:main3:sel
!!TITLE
Selections
!!HTML

    <!-- 100412 -->
    <a name="SetLayerSpecific"></a>
    <dl>
    <dt><b>(int) <tt>SetLayerSpecific</tt>(<i>state</i>)</b>
    <dd><br>
    If the boolean state value is nonzero, all layers except for the
    current layer will become unselectable.  Otherwise, all layers
    will be set to their default selectability state.  The return
    value is always 1. 
    </dl>
    <hr>

    <!-- 052409 -->
    <a name="SetLayerSearchUp"></a>
    <dl>
    <dt><b>(int) <tt>SetLayerSearchUp</tt>(<i>state</i>)</b>
    <dd><br>
    This function will set <a
    href="xic:selcp#searchup">layer-search-up</a> selection mode if the
    argument is nonzero, or normal mode otherwise.  The return value
    is 1 or 0 representing the previous layer-search-up mode status.
    </dl>
    <hr>

    <!-- 030204 -->
    <a name="SetSelectMode"></a>
    <dl>
    <dt><b>(string) <tt>SetSelectMode</tt>(<i>ptr_mode</i>, <i>area_mode</i>,
     <i>sel_mode</i>)</b>
    <dd><br>This function allows the various selection modes to be set. 
    These are the same modes that can be set with the <b>Selection
    Control Panel</b> provided by the <a
    href="xic:selcp"><b>selcp</b></a> button.  If an input value is
    given as -1, that particular parameter will be unchanged. 
    Otherwise, the possible values are

    <p>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><th><i>ptr_mode</i></th><th><i>area_mode</i></th><th><i>sel_mode</i></th></tr>
    <tr><td>0 Normal</td><td>0 Normal  </td><td>0 Normal</td></tr>
    <tr><td>1 Select</td><td>1 Enclosed</td><td>1 Toggle</td></tr>
    <tr><td>2 Modify</td><td>2 All     </td><td>2 Add   </td></tr>
    <tr><td>&nbsp;  </td><td>&nbsp;    </td><td>3 Remove</td></tr>
    </table>

    <p>
    The return value is a string, where the first three characters are
    the previous values of <i>ptr_mode</i>, <i>area_mode</i>, and
    <i>sel_mode</i> as <i>integers</i>, not ASCII characters.
    </dl>
    <hr>

    <!-- 052409 -->
    <a name="SetSelectTypes"></a>
    <dl>
    <dt><b>(string) <tt>SetSelectTypes</tt>(<i>string</i>)</b>
    <dd><br>
    This function allows setting of the object types that can be
    selected.  This provides the default selection types, but does not
    apply to functions that provide an explicit argument for selection
    types.

    <p>
    The string argument consists of a sequence of characters whose
    presence indicates that the corresponding object type is
    selectable.  These are:
    <blockquote>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><td><tt>c</tt></td> <td>cell instances</td></tr>
    <tr><td><tt>b</tt></td> <td>boxes</td></tr>
    <tr><td><tt>p</tt></td> <td>polygons</td></tr>
    <tr><td><tt>w</tt></td> <td>wires</td></tr>
    <tr><td><tt>l</tt></td> <td>labels</td></tr>
    </table>
    </blockquote>

    <p>
    Other characters are ignored.  If the string is null, empty, or
    contains none of the listed characters, all objects are enabled,
    as if the string "<tt>cbpwl</tt>" was entered.

    <p>
    This function always returns 1.
    </dl>
    <hr>

    <!-- 030204 -->
    <a name="Select"></a>
    <dl>
    <dt><b>(int) <tt>Select</tt>(<i>left</i>, <i>bottom</i>, <i>right</i>,
      <i>top</i>, <i>types</i>)</b>
    <dd><br>This function performs a selection operation in the rectangle
    defined by the first four arguments (given in microns).  The fifth
    argument is a string whose characters serve to enable selection of
    a given type of object:  '<tt>b</tt>' for boxes, '<tt>p</tt>' for
    polygons, '<tt>w</tt>' for wires, '<tt>l</tt>' for labels, and
    '<tt>c</tt>' for instances.  If this string is empty or null, then
    all objects will be selected.  Any matching object that touches or
    overlaps the selection box will have its selection status toggled.
    For example,
    <blockquote><tt>
        Select(-INFINITY, -INFINITY, INFINITY, INFINITY, "c")
    </tt></blockquote>
    will select all subcells.

    <p>
    For more complex selections based on object types, etc., the <a
    href="TextCmd"><tt>TextCmd</tt></a> function can be
    used to call the <a href="!select"><b>!select</b></a> command.
    </dl>
    <hr>

    <!-- 030204 -->
    <a name="Deselect"></a>
    <dl>
    <dt><b>(int) <tt>Deselect</tt>()</b>
    <dd><br>This function unselects all selected objects.
    </dl>
!!LATEX funcs:main3:sel scrfuncs.tex
\begin{description}
%------------------------------------
% 100412
\index{SetLayerSpecific function}
\item{(int) \vt SetLayerSpecific({\it state\/})}\\
If the boolean state value is nonzero, all layers except for the
current layer will become unselectable.  Otherwise, all layers will be
set to their default selectability state.  The return value is always
1.

%------------------------------------
% 052409
\index{SetLayerSearchUp function}
\item{(int) \vt SetLayerSearchUp({\it state\/})}\\
This function will set layer-search-up selection mode (see
\ref{selcontrol}) if the argument is nonzero, or normal mode
otherwise.  The return value is 1 or 0 representing the previous
layer-search-up mode status.

%------------------------------------
% 030204
\index{SetSelectMode function}
\item{(string) \vt SetSelectMode({\it ptr\_mode\/}, {\it area\_mode\/},
  {\it sel\_mode\/})}\\
This function allows the various selection modes to be set.  These are
the same modes that can be set with the {\cb Selection Control Panel}
provided by the {\cb layer} button.  If an input value is given as -1,
that particular parameter will be unchanged.  Otherwise, the possible
values are

\begin{tabular}{|l|l|l|} \hline
\it ptr\_mode & \it area\_mode & \it sel\_mode\\ \hline
0 Normal & 0 Normal   & 0 Normal\\ \hline
1 Select & 1 Enclosed & 1 Toggle\\ \hline
2 Modify & 2 All      & 2 Add\\ \hline
         &            & 3 Remove\\ \hline
\end{tabular}

The return value is a string, where the first three characters are the
previous values of {\it ptr\_mode}, {\it area\_mode}, and {\it
sel\_mode} as {\it integers}, not ASCII characters.

%------------------------------------
% 052409
\index{SetSelectTypes function}
\item{(int) \vt SetSelectTypes({\it string\/})}\\
This function allows setting of the object types that can be selected. 
This provides the default selection types, but does not apply to
functions that provide an explicit argument for selection types.
  
The string argument consists of a sequence of characters whose
presence indicates that the corresponding object type is selectable. 
These are:

\begin{quote}
\begin{tabular}{ll}
\vt c & cell instances\\
\vt b & boxes\\
\vt p & polygons\\
\vt w & wires\\
\vt l & labels\\
\end{tabular}
\end{quote}

Other characters are ignored.  If the string is null, empty, or
contains none of the listed characters, all objects are enabled, as if
the string ``{\vt cbpwl}'' was entered.
  
This function always returns 1.

%------------------------------------
% 030204
\index{Select function}
\item{(int) \vt Select({\it left\/}, {\it bottom\/}, {\it right\/},
 {\it top\/}, {\it types\/})}\\
This function performs a selection operation in the rectangle defined
by the first four arguments (given in microns).  The fifth argument is
a string whose characters serve to enable selection of a given type of
object:  `{\vt b}' for boxes, `{\vt p}' for polygons, `{\vt w}' for
wires, `{\vt l}' for labels, and `{\vt c}' for instances.  If this
string is empty or null, then all objects will be selected.  Any
matching object that touches or overlaps the selection box will have
its selection status toggled.  For example,
\begin{quote}
  {\vt Select(-INFINITY, -INFINITY, INFINITY, INFINITY, "c")}
\end{quote}
will select all subcells.

For more complex selections based on object types, etc., the {\vt
TextCmd} function can be used to call the {\cb !select} command.

% 030204
\index{Deselect function}
\item{(int) \vt Deselect()}\\
This function deselects all selected objects.

\end{description}

!!SEEALSO
funcs:main3

!!KEYWORD
funcs:main3:pfgen
!!TITLE
Pseudo-Flat Generator
!!HTML

    <!-- 030204 -->
    <a name="FlatObjList"></a>
    <dl>
    <dt><b>(object_handle) <tt>FlatObjList</tt>(<i>l</i>, <i>b</i>, <i>r</i>,
      <i>t</i>, <i>depth</i>)</b>
    <dd><br>This function provides access to the "pseudo-flat" object
    access functions that are part of internal DRC routines in
    <i>Xic</i>.  This enables cycling through objects in the database
    without regard to the cell hierarchy.  The first four arguments
    are the coordinates in microns of the bounding box to search in. 
    The <i>depth</i> is the search depth, which can be an integer
    which sets the maximum depth to search (0 means search the current
    cell only, 1 means search the current cell plus the subcells,
    etc., and a negative integer sets the depth to search the entire
    hierarchy).  This argument can also be a string starting with
    '<tt>a</tt>' such as "<tt>a</tt>" or "<tt>all</tt>" which
    indicates to search the entire hierarchy.

    <p>
    The return value is a list of box, polygon, and wire objects found
    in the given region on the current layer.  Label and subcell
    objects are never returned.  If <i>depth</i> is 0, the actual
    object pointers are returned in the list, and all of the object
    manipulation functions are available.  Otherwise, the list
    references copies of the actual objects, transformed to the
    coordinate space of the current cell.

    <p>
    The copies of the objects can use substantial memory if the list
    is very long.  The <tt>FlatObjGen</tt> function provides another
    access interface that can use less memory.
    </dl>
    <hr>

    <!-- 030204 -->
    <a name="FlatObjGen"></a>
    <dl>
    <dt><b>(handle) <tt>FlatObjGen</tt>(<i>l</i>, <i>b</i>, <i>r</i>,
      <i>t</i>, <i>depth</i>)</b>
    <dd><br>This function provides access to the "pseudo-flat" object
    access functions that are part of internal DRC routines in
    <i>Xic</i>.  This enables cycling through objects in the database
    without regard to the cell hierarchy.  The first four arguments
    are the coordinates in microns of the bounding box to search in. 
    The <i>depth</i> is the search depth, which can be an integer
    which sets the maximum depth to search (0 means search the current
    cell only, 1 means search the current cell plus the subcells,
    etc., and a negative integer sets the depth to search the entire
    hierarchy).  This argument can also be a string starting with
    '<tt>a</tt>' such as "<tt>a</tt>" or "<tt>all</tt>" which
    indicates to search the entire hierarchy.

    <p>
    Similar to <tt>FlatObjList</tt>, objects on the current layer are
    returned, but through an intermediate handle rather than through a
    list, which can require significant memory.  This function returns
    a special handle which is passed to the <tt>FlatGenNext</tt>
    function to actually retrieve the objects.  Although this handle
    can be passed to the <a href="funcs:main2:handle"> generic handle
    functions</a>, most of these functions will have no effect. 
    <tt>HandleContent</tt> will return 1, or 0 if the handle is
    exhausted.  <tt>HandleNext</tt> will advance to the next object
    without saving the object.  The other functions will return 0 and
    do nothing.  The <a href="Close"><tt>Close</tt></a> function
    should be called to delete the handle unless the handle is
    iterated to completion with <tt>FlatGenNext</tt> or
    <tt>HandleNext</tt>.

    <p>
    If <i>depth</i> is 0, the object pointers returned from
    <tt>FlatGenNext</tt> represent the actual object, and all object
    manipulation functions are available.  Otherwise, transformed
    copies of the actual objects are returned, and there are <a
    href="funcs:geom1:objbh">restrictions</a> on the operations that
    can be performed.
    </dl>
    <hr>

    <!-- 030204 -->
    <a name="FlatObjGenLayers"></a>
    <dl>
    <dt><b>(handle) <tt>FlatObjGenLayers</tt>(<i>l</i>, <i>b</i>, <i>r</i>,
      <i>t</i>, <i>depth</i>, <i>layers</i>)</b>
    <dd><br>This function is very similar to <tt>FlatObjGen</tt>, however
    it returns objects from layers named in the <i>layers</i> string. 
    If the string is null or empty, objects on all layers will be
    returned.  Otherwise, the string is a space separated list of
    layer names.  The names are expected to match layers in the
    current display mode.  Names that do not match any layer are
    silently ignored, though the function fails if no layer can be
    recognized.
    </dl>
    <hr>

    <!-- 030204 -->
    <a name="FlatGenNext"></a>
    <dl>
    <dt><b>(object_handle) <tt>FlatGenNext</tt>(<i>handle</i>)</b>
    <dd><br>This function takes as an argument the handle returned from
    <tt>FlatObjGen</tt> or <tt>FlatObjGenLayers</tt>, and returns an
    object handle which contains a single object returned from the
    generator.  If the <i>depth</i> argument passed to these functions
    was nonzero, the objects are transformed copies.  The returned
    handles should be closed after use by calling <tt>Close</tt>, or
    by calling an iterating function such as <tt>HandleNext</tt> or
    <tt>ObjectNext</tt>.

    <p>
    A new handle is returned for each call of this function, until no
    further objects are available in which case this function returns
    0, and the handle passed as the argument will be closed.
    </dl>
    <hr>

    <!-- 030204 -->
    <a name="FlatGenCount"></a>
    <dl>
    <dt><b>(int) <tt>FlatGenCount</tt>(<i>handle</i>)</b>
    <dd><br>This function returns the number of objects that can be
    generated with the generator handle passed, which must be returned
    from <tt>FlatObjGen</tt> or <tt>FlatObjGenLayers</tt>.  Generator
    handles do not cache an internal list of objects, so that the
    number of objects is unknown, which is why <tt>HandleContent</tt>
    returns 1 for generator handles.  This function duplicates the
    generator context and iterates through the loop, counting returned
    objects.  This can be an expensive operation.
    </dl>
    <hr>

    <!-- 030204 -->
    <a name="FlatOverlapList"></a>
    <dl>
    <dt><b>(object_handle) <tt>FlatOverlapList</tt>(<i>object_handle</i>,
        <i>touch_ok</i>, <i>depth</i>, <i>layers</i>)</b>
    <dd><br>This function returns a handle to a list of objects that touch
    or overlap the object referenced by the <i>object_handle</i>
    argument.  If <i>touch_ok</i> is nonzero, objects that touch but
    have zero overlap area will be included; if <i>touch_ok</i> is
    zero these objects will be skipped.  The <i>depth</i> is the
    search depth, which can be an integer which sets the maximum depth
    to search (0 means search the current cell only, 1 means search
    the current cell plus the subcells, etc., and a negative integer
    sets the depth to search the entire hierarchy).  This argument can
    also be a string starting with '<tt>a</tt>' such as "<tt>a</tt>"
    or "<tt>all</tt>" which indicates to search the entire hierarchy. 
    If <i>depth</i> is not 0, the objects returned are transformed
    copies, otherwise the actual objects are returned.  The
    <i>layer</i> argument is a string containing space-separated layer
    names of the layers to search for objects.  If this is empty or
    null, all layers will be searched.  The function fails if the
    handle argument is not a handle to an object list.  The return
    value is a handle to a list of objects, or 0 if no overlapping or
    touching objects are found.

    <p>
    Only boxes, polygons, and wires are returned.  The reference
    object can be any object.  If the reference object is a subcell,
    objects from within the cell will be returned if <i>depth</i> is
    nonzero.
    </dl>
!!LATEX funcs:main3:pfgen scrfuncs.tex
\begin{description}
%------------------------------------
% 030204
\index{FlatObjList function}
\item{(object\_handle) \vt FlatObjList({\it l\/}, {\it b\/}, {\it r\/},
   {\it t\/}, {\it depth\/})}\\
This function provides access to the ``pseudo-flat'' object access
functions that are part of internal DRC routines in {\Xic}.  This
enables cycling through objects in the database without regard to the
cell hierarchy.  The first four arguments are the coordinates in
microns of the bounding box to search in.  The {\it depth} is the
search depth, which can be an integer 0 or larger which sets the
maximum depth to search (0 means search the current cell only, 1 means
search the current cell plus the subcells, etc., and a negative
integer sets the depth to search the entire hierarchy).  This argument
can also be a string starting with `{\vt a}' such as ``{\vt a}'' or
``{\vt all}'' which indicates to search the entire hierarchy.

The return value is a list of box, polygon, and wire objects found in
the given region on the current layer.  Label and subcell objects are
never returned.  If {\it depth} is 0, the actual object pointers are
returned in the list, and all of the object manipulation functions are
available.  Otherwise, the list references copies of the actual
objects, transformed to the coordinate space of the current cell.

The copies of the objects can use substantial memory if the list is
very long.  The {\vt FlatObjGen} function provides another access
interface that can use less memory.

%------------------------------------
% 030204
\index{FlatObjGen function}
\item{(handle) \vt FlatObjGen({\it l\/}, {\it b\/}, {\it r\/},
   {\it t\/}, {\it depth\/})}\\
This function provides access to the ``pseudo-flat'' object access
functions that are part of internal DRC routines in {\Xic}.  This
enables cycling through objects in the database without regard to the
cell hierarchy.  The first four arguments are the coordinates in
microns of the bounding box to search in.  The {\it depth} is the
search depth, which can be an integer 0 or larger which sets the
maximum depth to search (0 means search the current cell only, 1 means
search the current cell plus the subcells, etc., and a negative
integer sets the depth to search the entire hierarchy).  This argument
can also be a string starting with `{\vt a}' such as ``{\vt a}'' or
``{\vt all}'' which indicates to search the entire hierarchy.

Similar to {\vt FlatObjList}, objects on the current layer are
returned, but through an intermediate handle rather than through a
list, which can require significant memory.  This function returns a
special handle which is passed to the {\vt FlatGenNext} function to
actually retrieve the objects.  Although this handle can be passed to
the generic handle functions, most of these functions will have no
effect.  {\vt HandleContent} will return 1, or 0 if the handle is
exhausted.  {\vt HandleNext} will advance to the next object without
saving the object.  The other functions will return 0 and do nothing. 
The {\vt Close} function should be called to delete the handle unless
the handle is iterated to completion with {\vt FlatGenNext} or {\vt
HandleNext}.

If {\it depth} is 0, the object pointers returned from {\vt
FlatGenNext} represent the actual object, and all object manipulation
functions are available.  Otherwise, transformed copies of the actual
objects are returned, and there are restrictions on the operations
that can be performed (see \ref{objmanh}).

%------------------------------------
% 030204
\index{FlatObjGenLayers function}
\item{(handle) \vt FlatObjGenLayers({\it l\/}, {\it b\/}, {\it r\/},
   {\it t\/}, {\it depth}, {\it layers\/})}\\
This function is very similar to {\vt FlatObjGen}, however it returns
objects from layers named in the {\it layers} string.  If the string
is null or empty, objects on all layers will be returned.  Otherwise,
the string is a space separated list of layer names.  The names are
expected to match layers in the current display mode.  Names that do
not match any layer are silently ignored, though the function fails if
no layer can be recognized.

%------------------------------------
% 030204
\index{FlatGenNext function}
\item{(object\_handle) \vt FlatGenNext({\it handle\/})}\\
This takes as an argument the handle returned from {\vt FlatObjGen} or
{\vt FlatObjGenLayers}, and returns an object handle which contains a
single object returned from the generator.  If the {\it depth}
argument passed to these functions was nonzero, the objects are
transformed copies.  The returned handles should be closed after use
by calling {\vt Close}, or by calling an iterating function such as
{\vt HandleNext} or {\vt ObjectNext}.

A new handle is returned for each call of this function, until no
further objects are available in which case this function returns 0,
and the handle passed as the argument will be closed.

%------------------------------------
% 030204
\index{FlatGenCount function}
\item{(int) \vt FlatGenCount({\it handle\/})}\\
This function returns the number of objects that can be generated with
the generator handle passed, which must be returned from {\vt
FlatObjGen} or {\vt FlatObjGenLayers}.  Generator handles do not cache
an internal list of objects, so that the number of objects is unknown,
which is why {\vt HandleContent} returns 1 for generator handles. 
This function duplicates the generator context and iterates through
the loop, counting returned objects.  This can be an expensive
operation.

%------------------------------------
% 030204
\index{FlatOverlapList function}
\item{(object\_handle) \vt FlatOverlapList({\it object\_handle},
  {\it touch\_ok}, {\it depth}, {\it layers\/})}\\
This function returns a handle to a list of objects that touch or
overlap the object referenced by the {\it object\_handle} argument. 
If {\it touch\_ok} is nonzero, objects that touch but have zero
overlap area will be included; if {\it touch\_ok} is zero these
objects will be skipped.  The {\it depth} is the search depth, which
can be an integer which sets the maximum depth to search (0 means
search the current cell only, 1 means search the current cell plus the
subcells, etc., and a negative integer sets the depth to search the
entire hierarchy).  This argument can also be a string starting with
`{\vt a}' such as ``{\vt a}'' or ``{\vt all}'' which indicates to
search the entire hierarchy.  If {\it depth} is not 0, the objects
returned are transformed copies, otherwise the actual objects are
returned.  The {\it layer} argument is a string containing
space-separated layer names of the layers to search for objects.  If
this is empty or null, all layers will be searched.  The function
fails if the handle argument is not a handle to an object list.  The
return value is a handle to a list of objects, or 0 if no overlapping
or touching objects are found.

Only boxes, polygons, and wires are returned.  The reference object
can be any object.  If the reference object is a subcell, objects from
within the cell will be returned if {\it depth} is nonzero.

\end{description}

!!SEEALSO
funcs:main3

!!KEYWORD
funcs:main3:meas
!!TITLE
Geometry Measurement
!!HTML

    <!-- 030204 -->
    <a name="Distance"></a>
    <dl>
    <dt><b>(real) <tt>Distance</tt>(<i>x</i>, <i>y</i>, <i>x1</i>,
      <i>y1</i>)</b>
    <dd><br>This function computes the distance between two points, given
    in microns, returning the distance between the points in microns.
    </dl>
    <hr>

    <!-- 030204 -->
    <a name="MinDistPointToSeg"></a>
    <dl>
    <dt><b>(real) <tt>MinDistPointToSeg</tt>(<i>x</i>, <i>y</i>, <i>x1</i>,
     <i>y1</i>, <i>x2</i>, <i>y2</i>, <i>aret</i>)</b>
    <dd><br>This function computes the shortest distance from <i>x,y</i>
    to the line segment defined by the next four arguments.  The
    <i>aret</i> is an array of size at least 4, used for returned
    coordinates.  If no return is needed, this argument can be set to
    0.  Upon return of a value greater than 0, the first two values in
    <i>aret</i> are <i>x</i> and <i>y</i>, the next two values are the
    point on the segment closest to <i>x,y</i>.  All values are in
    microns.
    </dl>
    <hr>

    <!-- 030204 -->
    <a name="MinDistPointToObj"></a>
    <dl>
    <dt><b>(real) <tt>MinDistPointToObj</tt>(<i>x</i>, <i>y</i>,
     <i>object_handle</i>, <i>aret</i>)</b>
    <dd><br>This function computes the minimum distance from the point
    <i>x,y</i> to the boundary of the object given by the handle.  The
    <i>aret</i> is an array of size at least 4 for return coordinates. 
    If the return is not needed, this argument can be given as 0. 
    Upon return of a value greater than 0, the first two values of
    aret will be <i>x</i> and <i>y</i>, the next two values will be
    the point on the boundary of the object closest to <i>x,y</i>. 
    The function returns 0 if <i>x,y</i> touch or are enclosed in the
    object.  The function will fail if the handle is not a reference
    to an object list.  If there is an internal error, -1 is returned. 
    All coordinates are in microns.
    </dl>
    <hr>

    <!-- 030204 -->
    <a name="MinDistSegToObj"></a>
    <dl>
    <dt><b>(real) <tt>MinDistSegToObj</tt>(<i>x1</i>, <i>y1</i>, <i>x2</i>,
     <i>y2</i>, <i>object_handle</i>, <i>aret</i>)</b>
    <dd><br>This function computes the minimum distance from the line
    segment defined by the first four arguments to the boundary of the
    object given by the handle.  The <i>aret</i> is an array of size
    at least 4 for return coordinates.  If the return is not needed,
    this argument can be given as 0.  Upon return of a value greater
    than 0, the first two values of <i>aret</i> will be the point on
    the line segment nearest the object, the next two values will be
    the point on the boundary of the object nearest to the line
    segment.  The function returns 0 if the line segment touches or
    overlaps the object.  The function will fail if the handle is not
    a reference to an object list.  If there is an internal error, -1
    is returned.  All coordinates are in microns.
    </dl>
    <hr>

    <!-- 030204 -->
    <a name="MinDistObjToObj"></a>
    <dl>
    <dt><b>(real) <tt>MinDistObjToObj</tt>(<i>object_handle1</i>,
     <i>object_handle2</i>, <i>aret</i>)</b>
    <dd><br>This function computes the minimum distance between the two
    objects referenced by the handles.  The <i>aret</i> is an array of
    size at least 4 for return coordinates.  If the return is not
    needed, this argument can be given as 0.  Upon return of a value
    greater than 0, the first two values of <i>aret</i> will be the
    point on the boundary of the first object nearest the second
    object, the next two values will be the point on the boundary of
    the second object nearest to the first object.  The function
    returns 0 if the objects touch or overlap.  The function will fail
    if either handle is not a reference to an object list.  If there
    is an internal error, -1 is returned.  All coordinates are in
    microns.
    </dl>
    <hr>

    <!-- 030204 -->
    <a name="MaxDistPointToObj"></a>
    <dl>
    <dt><b>(real) <tt>MaxDistPointToObj</tt>(<i>x</i>, <i>y</i>,
     <i>object_handle</i>, <i>aret</i>)</b>
    <dd><br>This function finds the vertex of the object referenced by
    the handle farthest from the point <i>x,y</i> and returns this
    distance.  The <i>aret</i> is an array of size at least 4 for
    return coordinates.  If the return is not needed, this argument
    can be given as 0.  Upon return of a value greater than 0, the
    first two values of aret will be <i>x</i> and <i>y</i>, the next
    two values will be the vertex of the object farthest from
    <i>x,y</i>.  The function will fail if the handle is not a
    reference to an object list.  If there is an internal error, -1 is
    returned.  All coordinates are in microns.
    </dl>
    <hr>

    <!-- 030204 -->
    <a name="MaxDistObjToObj"></a>
    <dl>
    <dt><b>(real) <tt>MaxDistObjToObj</tt>(<i>object_handle1</i>,
     <i>object_handle2</i>, <i>aret</i>)</b>
    <dd><br>This function finds the pair of vertices, one from each
    object, that are farthest apart.  Both handles can be the same. 
    The <i>aret</i> is an array of size at least 4 for return
    coordinates.  If the return is not needed, this argument can be
    given as 0.  Upon return of a value greater than 0, the first two
    values of <i>aret</i> will be the vertex from the first object,
    the next two values will be the vertex from the second object. 
    The function will fail if either handle is not a reference to an
    object list.  If there is an internal error, -1 is returned.  All
    coordinates are in microns.
    </dl>
    <hr>

    <!-- 030204 -->
    <a name="Intersect"></a>
    <dl>
    <dt><b>(int) <tt>Intersect</tt>(<i>object_handle1</i>,
     <i>object_handle2</i>, <i>touchok</i>)</b>
    <dd><br>This function determines whether the two objects referenced by
    the handles touch or overlap.  The return value is 1 if the
    objects touch or overlap, 0 if the objects do not touch or
    overlap, or -1 if either handle points to an empty list or some
    other error occurred.  The function fails if either handle is not
    a reference to an object list.  If the <i>touchok</i> argument is
    nonzero, 1 will be returned if the objects touch but do not
    overlap.  If touchok is 0, objects must overlap (have nonzero
    intersection area) for 1 to be returned.
    </dl>
!!LATEX funcs:main3:meas scrfuncs.tex
\begin{description}
%------------------------------------
% 030204
\index{Distance function}
\item{(real) \vt Distance({\it x\/}, {\it y\/}, {\it x1\/}, {\it y1\/})}\\
This function computes the distance between two points, given in
microns, returning the distance between the points in microns.

%------------------------------------
% 030204
\index{MinDistPointToSeg function}
\item{(real) \vt MinDistPointToSeg({\it x\/}, {\it y\/}, {\it x1\/},
 {\it y1\/}, {\it x2\/}, {\it y2\/}, {\it aret\/})}\\
This function computes the shortest distance from {\it x,y} to the
line segment defined by the next four arguments.  The {\it aret} is an
array of size at least 4, used for returned coordinates.  If no return
is needed, this argument can be set to 0.  Upon return of a value
greater than 0, the first two values in {\it aret} are {\it x} and
{\it y}, the next two values are the point on the segment closest to
{\it x,y}.  All values are in microns.

%------------------------------------
% 030204
\index{MinDistPointToObj function}
\item{(real) \vt MinDistPointToObj({\it x\/}, {\it y\/},
 {\it object\_handle\/}, {\it aret\/})}\\
This function computes the minimum distance from the point {\it x,y}
to the boundary of the object given by the handle.  The {\it aret} is
an array of size at least 4 for return coordinates.  If the return is
not needed, this argument can be given as 0.  Upon return of a value
greater than 0, the first two values of aret will be {\it x} and {\it
y}, the next two values will be the point on the boundary of the
object closest to {\it x,y}.  The function returns 0 if {\it x,y}
touch or are enclosed in the object.  The function will fail if the
handle is not a reference to an object list.  If there is an internal
error, -1 is returned.  All coordinates are in microns.

%------------------------------------
% 030204
\index{MinDistSegToObj function}
\item{(real) \vt MinDistSegToObj({\it x1\/}, {\it y1\/}, {\it x2\/},
 {\it y2\/}, {\it object\_handle\/}, {\it aret\/})}\\
This function computes the minimum distance from the line segment
defined by the first four arguments to the boundary of the object
given by the handle.  The {\it aret} is an array of size at least 4
for return coordinates.  If the return is not needed, this argument
can be given as 0.  Upon return of a value greater than 0, the first
two values of {\it aret} will be the point on the line segment nearest
the object, the next two values will be the point on the boundary of
the object nearest to the line segment.  The function returns 0 if the
line segment touches or overlaps the object.  The function will fail
if the handle is not a reference to an object list.  If there is an
internal error, -1 is returned.  All coordinates are in microns.

%------------------------------------
% 030204
\index{MinDistObjToObj function}
\item{(real) \vt MinDistObjToObj({\it object\_handle1\/},
 {\it object\_handle2\/}, {\it aret\/})}\\
This function computes the minimum distance between the two objects
referenced by the handles.  The {\it aret} is an array of size at
least 4 for return coordinates.  If the return is not needed, this
argument can be given as 0.  Upon return of a value greater than 0,
the first two values of {\it aret} will be the point on the boundary
of the first object nearest the second object, the next two values
will be the point on the boundary of the second object nearest to the
first object.  The function returns 0 if the objects touch or overlap. 
The function will fail if either handle is not a reference to an
object list.  If there is an internal error, -1 is returned.  All
coordinates are in microns.

%------------------------------------
% 030204
\index{MaxDistPointToObj function}
\item{(real) \vt MaxDistPointToObj({\it x\/}, {\it y\/},
 {\it object\_handle\/}, {\it aret\/})}\\
This function finds the vertex of the object referenced by the handle
farthest from the point {\it x,y} and returns this distance.  The {\it
aret} is an array of size at least 4 for return coordinates.  If the
return is not needed, this argument can be given as 0.  Upon return of
a value greater than 0, the first two values of aret will be {\it x}
and {\it y}, the next two values will be the vertex of the object
farthest from {\it x,y\/}.  The function will fail if the handle is
not a reference to an object list.  If there is an internal error, -1
is returned.  All coordinates are in microns.

%------------------------------------
% 030204
\index{MaxDistObjToObj function}
\item{(real) \vt MaxDistObjToObj({\it object\_handle1\/},
 {\it object\_handle2\/}, {\it aret\/})}\\
This function finds the pair of vertices, one from each object, that
are farthest apart.  Both handles can be the same.  The {\it aret} is
an array of size at least 4 for return coordinates.  If the return is
not needed, this argument can be given as 0.  Upon return of a value
greater than 0, the first two values of {\it aret} will be the vertex
from the first object, the next two values will be the vertex from the
second object.  The function will fail if either handle is not a
reference to an object list.  If there is an internal error, -1 is
returned.  All coordinates are in microns.

%------------------------------------
% 030204
\index{Intersect function}
\item{(int) \vt Intersect({\it object\_handle1\/},
 {\it object\_handle2\/}, {\it touchok\/})}\\
This function determines whether the two objects referenced by the
handles touch or overlap.  The return value is 1 if the objects touch
or overlap, 0 if the objects do not touch or overlap, or -1 if either
handle points to an empty list or some other error occurred.  The
function fails if either handle is not a reference to an object list. 
If the {\it touchok} argument is nonzero, 1 will be returned if the
objects touch but do not overlap.  If touchok is 0, objects must
overlap (have nonzero intersection area) for 1 to be returned.

\end{description}

!!SEEALSO
funcs:main3

