
!!  ---------------------------------------------------------------
!!  Xic/WRspice Help System Database
!!  $Id: xiScript.hlp,v 1.54 2016/06/21 17:26:46 stevew Exp $
!!  Copyright (C) Whiteley Research Inc. 2003.  All Rights Reserved
!!  ---------------------------------------------------------------

!!TAG Xic

!!KEYWORD
xiScript.hlp
!!TITLE
xiScript.hlp
!!HTML

!!SUBTOPICS
macro
xicscript
scr:mathops
scr:control
scr:preproc
scr:mathfuncs
scr:functions
scr:exec
scr:global
scr:constants
scr:forms


!!REDIRECT RELEASE      macro#release
!!REDIRECT GENERATION   macro#generation
!!REDIRECT MAJOR        macro#major
!!REDIRECT MINOR        macro#minor
!!REDIRECT OSNAME       macro#osname
!!REDIRECT OSTYPE       macro#ostype
!!REDIRECT OSBITS       macro#osbits
!!REDIRECT XTROOT       macro#xtroot
!!REDIRECT PROGROOT     macro#progroot

!! 052222
!!KEYWORD
macro
!!TITLE
Macro Preprocessor
!!HTML
    <table border=0>
    <tr><td valign=top><b>jump to</b></td> <td>
    <a href="macro#predef"><b>Predefined Macros</b></a><br>
    <a href="macro#generic"><b>Generic Macro Keywords</b></a>
    </td></tr></table>

    <p>
    As part of the scripting language support, a macro preprocessor
    package is provided, which is used by <i>Xic</i> when reading
    various types of input.  This input includes <a
    href="scr:preproc">scripts</i>, <a href="libraries">library</a>
    and <a href="submenu">menu</a> ("<tt>.scm</tt>") files, and the <a
    href="techfile:macros">technology file</a>.  This section
    describes the common features of this macro processing system.

    <p>
    A macro is a text token that usually references another piece of
    text.  When lines of text are "macro expanded", the tokens that
    are recognized as macro names are removed, and replaced by the
    text associated with the macro name.  This is done recursively, as
    the replacement text may itself contain macro names.

    <p>
    In other cases, macros can be used to identify blocks of text to
    be discarded when a file is being read.  The macro system applies
    conditional testing based on the existence of a defined macro
    name, or whether a macro name is set to a certain value, and marks
    blocks of text for inclusion or exclusion accordingly. 

    <p>
    This section will describe the common functionality of the macro
    preprocessor, and will be referred to in the sections describing
    the format of the various types of input.  Not all features are
    used in all cases, and the exact keyword names (but not the
    functionality) will vary for different input types.  For example,
    the keyword which defines a macro is "<tt>#define</tt>" in
    scripts, but "<tt>Define</tt>" may be used in other types of file.

    <a name="predef"></a>
    <h2>Predefined Macros</h2>

    The macro preprocessor defines several macro names that are common
    to all instances of the preprocessor and apply in all cases where
    the preprocessor is in use.  These names are the same in all
    cases, they do not differ with different file types.  The
    predefined macro names can not be undefined or set to a different
    value, attempts to do so will trigger an error.  These are the
    following:

    <a name=release></a>
    <dl>
    <dt><tt>RELEASE</tt><dd>
    First implemented: release 3.0.5<br>
    The macro name <tt>RELEASE</tt> is predefined to the release
    number code.  The release number code is a five digit integer
    <i>xyzz</i>0, corresponding to release <i>x.y.z</i>.  The <i>x</i>
    (always 3) and <i>y</i> are one digit fields, <i>zz</i> is a
    two-digit field, 0 padded.  The trailing 0 is a historical
    anachronism.  For example, for release 3.2.5, the macro is
    predefined to "<tt>32050</tt>".
    </dl>

    <a name=generation></a>
    <dl>
    <dt><tt>GENERATION</tt><dd>
    First implemented: release 4.1.10<br>
    This is set to the generation part of the release tgriplet, which
    is "4" for the current generation 4.
    </dl>

    <a name=major></a>
    <dl>
    <dt><tt>MAJOR</tt><dd>
    First implemented: release 4.1.10<br>
    This is set to the middle number of the release triplet, for
    example for release 4.1.10, <tt>MAJOR</tt> is set to "1".
    </dl>

    <a name=minor></a>
    <dl>
    <dt><tt>MINOR</tt><dd>
    First implemented: release 4.1.10<br>
    This is set to the rightmost number or the release triplet, for
    example for release 4.1.10, <tt>MINOR</tt> is set to "10".
    </dl>

    <a name=osname></a>
    <dl>
    <dt><tt>OSNAME</tt><dd>
    First implemented: release 4.2.12<br>
    This is set to the distribution name of the program, for example
    "<tt>LinuxCentos7</tt>".
    </dl>

    <a name=ostype></a>
    <dl>
    <dt><tt>OSTYPE</tt><dd>
    First implemented: release 3.2.19<br>
    This macro name is set to one of the following words, depending on
    the operating system target of the running program.  Note that this
    is determined at compile time, so is static in the program binary,
    and may not be the "real" operating system if running under an emulator.
    For example, a Linux binary running under FreeBSD would still indicate
    "<tt>Linux</tt>".
    <table cellpadding=2 border=1 bgcolor="#ffffee">
    <tr><th>Distribution Target</th> <th>Keyword</th></tr>
    <tr><td>Any Linux</td> <td>"<tt>Linux</tt>"</td></tr>
    <tr><td>Windows</td> <td>"<tt>Windows</tt>"</td></tr>
    <tr><td>FreeBSD</td> <td>"<tt>UNIX</tt>"</td></tr>
    <tr><td>Any Apple</td> <td>"<tt>OSX"</tt>"</td></tr>
    </table>
    </dl>

    <a name=osbits></a>
    <dl>
    <dt><tt>OSBITS</tt><dd>
    First implemented: release 3.2.19<br>
    This macro is set to either "<tt>32</tt>" or "<tt>64</tt>", depending
    on whether the program was compiled for 32- or 64-bit memory addresses.
    This is determined at compile time, so that a 32-bit binary running
    on a 64-bit operating system would indicate "<tt>32</tt>".
    </dl>

    <a name=xtroot></a>
    <dl>
    <dt><tt>XTROOT</tt><dd>
    First implemented: release 3.2.19<br>
    This macro is defined to be the system xictools installation
    location path as assumed by the running program.  It reflects the
    status of environment variables or other means of defining this
    path, and will revert to a default.  This directory is
    typically "<tt>/usr/local/xictools</tt>" in non-Windows
    programs.  The Windows path is similar but may include a drive
    specifier and use back instead of forward slash separators.
    </dl>

    <a name=progroot></a>
    <dl>
    <dt><tt>PROGROOT</tt><dd>
    First implemented: release 4.0.0<br>
    This macro is defined to be the system installation location path
    for the running program as assumed by the running program.  It
    reflects the status of environment variables or other means of
    defining this path, and will revert to a default.  This directory
    is typically "<tt>/usr/local/xictools/xic</tt>" for the <i>Xic</i>
    program, for example, in non-Windows programs.  The Windows path
    is similar but may include a drive specifier and use back instead
    of forward slash separators.
    </dl>

    <dl>
    <dt>product name<dd>
    First implemented:  release 3.0.5<br>
    In releases prior to 4.0.9, exactly one of the macro names
    "<tt>Xic</tt>", "<tt>XicII</tt>", or "<tt>Xiv</tt>" would be
    defined, depending upon which of the programs was being run.  The
    name is not defined to any text, but one can test whether or not a
    given name is defined.  In release 4.0.9 and later, the separate
    <i>XicII</i> and <i>Xiv</i> programs were discontinued, but the
    functionality lives on as feature sets of <i>Xic</i>.  The
    <tt>Xic</tt> symbol is always defined when running <i>Xic</i> for
    any feature set, and is therefor rather useless but provides some
    backward compatibility.

    <p>
    This macro has the property that instances of the macro are not
    replaced (with an empty string) when macro-expanding, i.e., macro
    substitution is inhibited (4.2.12 and later).
    </dl>

    <dl>
    <dt>feature set name<dd>
    First implemented:  release 4.0.9<br>
    The macro "<tt>FEATURESET</tt>" will be defined to one of three
    strings, depending upon the feature set running.  If all features
    are enabled, the string is "<tt>FULL</tt>".  If the <i>XicII</i>
    (EDITOR) permission set is running, the string is
    "<tt>EDITOR</tt>".  If the <i>Xiv</i> (VIEWER) feature set is
    running, the string is "<tt>VIEWER</tt>".  The macro can be tested
    with forms similar to
    <blockquote>
    <tt>If FEATURESET == "FULL"<br>
    ...<br>
    Endif</tt>
    </blockquote>

    <dl>
    <dt>technology name<dd>
    First implemented:  release 3.2.18<br>
    If the technology file uses the <a
    href="techfile#techname"><tt>Technology</tt></a> keyword to define
    a name for the technology, that name will be predefined as a macro
    name.  The name is not defined to any text, but one may test
    whether or not a given name is defined.

    <p>
    This macro has the property that instances of the macro are not
    replaced (with an empty string) when macro-expanding, i.e., macro
    substitution is inhibited (4.2.12 and later).
    </dl>

    <p>
    These macros are always available, and additional predefined
    macros may be available in the various contexts, which are
    documented elsewhere.

    <dl>
    <dt>technology definitions<dd>
    First implemented:  release 4.3.10<br>
    In addition to above, if the technology file uses the
    href="techfile#techname"><tt>Technology</tt></a> keyword to define
    a name for the technology, the predefined macro
    "<tt>TECHNOLOGY</tt>" is set to that name.  Furthermore, if the
    <tt>Vendoor</tt> keyword is used to define a name, the
    "<tt>VENDOR</tt>" predefined macro is set to the name.  Similarly,
    <tt>Process</tt> can be used to assign a name to the predefined
    "<tt>PROCESS</tt>" macro.

    <a name="generic"></a>
    <h2>Generic Macro Keywords</h2>

    The following keywords may vary between different contexts where
    the macro processor is used.  The actual keywords are programmable
    within the macro preprocessor system, so as to better match the
    syntax of the file format to which the preprocessor is being
    applied.  Here, we will use italicized generic names for these
    keywords, but the correspondence to actual keyword names (given in
    the documentation for the specific file formats) should be
    obvious.  The square brackets indicate "optional".

    <dl>
    <dt><i>DEFINE</i> [<tt>eval</tt>]  <i>token</i> [<i>text</i>]
    <dt><i>DEFINE</i> [<tt>eval</tt>] <i>token</i>(<i>arg</i>,
      <i>arg</i>1, ..., <i>arg</i>n) [<i>text_containing_args</i>]<dd>
    The macro name <i>token</i> may use alphanumeric characters
    and underscores, and must start with an alpha or underscore
    character.  The name is optionally immediately followed by an
    argument list in parentheses.  The arguments are arbitrary
    alphanumeric plus underscore tokens that start with an alpha or
    underscore and are separated by commas.  This is the same syntax
    used in the C language preprocessor for <tt>#define</tt> lines. 
    The remainder of the line is the substitution string.

    <p>
    If the optional "<tt>eval</tt>" keyword is not included, the
    replacement text, if any, will replace the macro in lines of text
    being macro expanded.

    If "<tt>eval</tt>" is included (this is verbatim but
    case-insensitive), the replacement text is assumed to be
    executable as a single line <a href="xicscript">script</a>.  The
    script will be executed, and the result (or return value) will be
    converted to a text string (if necessary) and taken as the
    replacement text.
    </dl>

    <dl>
    <dt><i>IF</i> <i>expression</i><dd>
    The <i>expression</i> is a constant expression which can contain
    macros previously defined with <i>DEFINE</i>, predefines, and
    functions from the script <a href="scr:library">library</a> files or
    otherwise available in memory.  The <i>expression</i> is evaluated
    numerically, and if the result is nonzero (as an integer), the
    block that follows until the corresponding <i>ELSE</i> or
    <i>ENDIF</i> is read.  If the result is 0 (as an integer),
    the block of lines that follow is skipped.
    </dl>

    <dl>
    <dt><i>IFDEF</i> <i>token</i><dd>
    If <i>token</i> has been defined, either with <i>DEFINE</i> or as
    a predefined macro, reading resumes at the following line. 
    Otherwise, reading resumes at the line following the next
    <i>ELSE</i> or <i>ENDIF</i>.
    </dl>

    <dl>
    <dt><i>IFNDEF</i> <i>token</i><dd>
    If <i>token</i> has not been defined, reading resumes at the
    following line.  Otherwise, reading resumes at the line following
    the next <i>ELSE</i> or <i>ENDIF</i>.
    </dl>

    <dl>
    <dt><i>ELSE</i><dd>
    Used in conjunction with <i>IF</i>, <i>IFDEF</i> and <i>IFNDEF</i>.
    </dl>

    <dl>
    <dt><i>ENDIF</i><dd>
    Used to terminate an <i>IF</i>, <i>IFDEF</i>, <i>IFNDEF</i>, or
    <i>ELSE</i> block.
    </dl>

    <p>
    In various contexts, other special keywords may be recognized. 
    These are described elsewhere.

    <p>
    <b>Examples:</b>

    <p>
    The examples below illustrate some simple constructs that improve
    portability of input files, using the predefined macros and
    generic keywords.  In real input, the actual keywords appropriate
    for the type of file should be used.

    <p>
    The <i>IF</i> keyword, and product name and <tt>RELEASE</tt>
    predefines, were implemented in release 3.0.5, so use is not
    compatible with older releases.  Nevertheless, files can be
    made portably version dependent through use of
    <i>IFDEF</i> and/or <i>IFNDEF</i>.

    <p>
    <blockquote>
    <i>IFNDEF</i> <tt>RELEASE</tt><br>
    # old release<br>
    <i>text</i>...<br>
    <i>ELSE</i><br>
    <i>IF</i> <tt>RELEASE == 30050</tt><br>
    # release xic-3.0.5<br>
    <i>text</i>...<br>
    <i>ELSE</i><br>
    # a later release<br>
    <i>text</i>...<br>
    <i>ENDIF</i><br>
    <i>ENDIF</i><br>
    </blockquote>

    <p>
    Often, it is necessary to know what operating system is being
    used.  Usually, there are really only two categories:  Windows,
    and everything else.

    <p>
    <blockquote>
    <i>IF</i> <tt>OSTYPE == "Windows"</tt><br>
    # running Windows<br>
    <i>text</i>...<br>
    <i>ELSE</i><br>
    # not running Windows<br>
    <i>text</i>...<br>
    <i>ENDIF</i><br>
    </blockquote>

    <p>
    It may be necessary to disable certain setup if not running the
    full <i>Xic</i> feature set, for example, if the same file is used
    for different <i>Xic</i> feature sets.

    <p>
    <blockquote>
    <i>IF</i> <tt>FEATURESET == "FULL"</tt><br>
    # running Xic<br>
    <i>text</i>...<br>
    <i>ELSE</i><br>
    <i>IF</i> <tt>FEATURESET == "EDITOR"</tt><br>
    # running XicII<br>
    <i>text</i>...<br>
    <i>ELSE</i><br>
    <i>IF</i> <tt>FEATURESET == "VIEWER"</tt><br>
    # running Xiv<br>
    <i>text</i>...<br>
    <i>ELSE</i><br>
    # impossible!<br>
    <i>ENDIF</i><br>
    <i>ENDIF</i><br>
    <i>ENDIF</i><br>
    </blockquote>

!! 110815
!!KEYWORD
xicscript
!!TITLE
<i>Xic</i> Scripts
!!HTML
    <table border=0>
    <tr><td valign=top><b>jump to</b></td> <td>
    <a href="xicscript#lang"><b>The Scripting Language</b></a><br>
    <a href="xicscript#errrpt"><b>Error Reporting</b></a><br>
    <a href="xicscript#datatype"><b>Data Types</b></a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <a href="xicscript#scalar"><b>Scalars</b></a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <a href="xicscript#string"><b>Strings</b></a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <a href="xicscript#array"><b>Arrays</b></a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;
    &nbsp;&nbsp;&nbsp;&nbsp;
    <a href="xicscript#decl"><b>Declaring and Defining Arrays</b></a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;
    &nbsp;&nbsp;&nbsp;&nbsp;
    <a href="xicscript#init"><b>Initialization</b></a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;
    &nbsp;&nbsp;&nbsp;&nbsp;
    <a href="xicscript#resize"><b>Dynamic Resizing</b></a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;
    &nbsp;&nbsp;&nbsp;&nbsp;
    <a href="xicscript#pointer"><b>Pointers</b></a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <a href="xicscript#complex"><b>Complex</b></a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <a href="xicscript#handle"><b>Handles</b></a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <a href="xicscript#zoidlist"><b>Zoidlists</b></a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <a href="xicscript#lexpr"><b>Lexprs</b></a><br>
    </td></tr></table>

    <p>
    <i>Xic</i> supports a scripting language and user-definable
    commands (scripts).  These commands can be associated with buttons
    in the <a href="xic:usermenu"><b>User Menu</b></a>.  Scripts may
    also be used in <a href="xic:label">script labels</a>, which are
    labels placed in a drawing which execute the script when clicked
    on.  Scripts are also used in <a href="userrules">user-defined
    design rules</a>, and are the basis for the protocol used in the
    <i>Xic</i> <a href="xic:server">server</a> mode.  Scripts are also
    integral to the native <a href="xic:pcells">parameterized cell</a>
    capability.  A library of several hundred built-in <a
    href="scr:iffuncs">functions</a> callable from scripts provide
    control over virtually all of the program capabilities.

    <p>
    In addition to the native scripting capability, <i>Xic</i>
    provides a <a href="plugins">plug-in</a> interface to the popular
    open-source <a href="pyplugin">Python</a> and <a
    href="tclplugin">Tcl/Tk</a> scripting languages.

    <p>
    The scripting capability can be used to provide commands that
    quickly generate complex geometry for microwave integrated
    circuits, for example.  Another application is to produce simple,
    often-needed geometry such as vias or device structures.  This
    powerful capability provides the user with the tools to automate
    many tasks.

    <p>
    Script files are created using a text editor, perhaps most
    conveniently from within the debugger built into <i>Xic</i>, which
    is accessible from the <a href="xic:debug"><b>Debugger</b></a>
    button in the <b>User Menu</b>.  Scripts can be executed within
    the debugging environment, which offers single stepping,
    breakpoints, and other features.  The language is rather generic
    and somewhat reminiscent of the C programming language.

    <a name="lang"></a>
    <h2>The Scripting Language</h2>

    A script consists of command lines, each containing one or more
    syntactically complete statements.  Lines may be continued by
    adding a backslash character at the end of the line, which "hides"
    the return character.  Parentheses are used as delimiters to
    enforce execution order, and to enclose arguments to functions. 
    Arrays of up to three dimensions are supported, with the array
    indices separated by commas and enclosed in square brackets. 
    Array names are taken as addresses, and may be passed to
    functions, and used in arithmetic expressions.  There are no
    address or pointer operators, however a pointer mechanism does
    exist.

    <p>
    If a line begins with the pound sign `#' the line will be ignored
    by the parser, unless the line contains a <a
    href="scr:preproc">preprocessor</a> directive.  The preprocessor
    directives can be used to comment out blocks of lines.  The
    character sequence '//' at the start of a line also indicates a
    comment.

    <p>
    There is one "special case" comment, which must be the first non-blank
    line of a script file to have relevance:
    <blockquote>
    <tt>#menulabel</tt> <i>label</i>
    </blockquote>
    The <i>label</i> is a word or quoted phrase, which will appear on
    the button in the top level of the <b>User Menu</b> which executes
    the script.  Otherwise, like any comment, the line is ignored.

    <p>
    Each line of a script generally contains one statement or clause,
    the entirety of which should be contained in the same logical
    line.  Physical lines can be continued with a backslash character
    to form a single logical line.  If the last character on a line is
    the backslash (<tt>"\"</tt>) character, the line that follows will
    be logically appended, replacing the backslash.

    <p>
    The parser will parse the opening clause of a line, and if there
    is additional text, the parser will continue reading, until all
    text on the line has been processed.  Thus, a single line can
    actually contain multiple statements.  Each statement can be
    terminated with a semicolon {<tt>";"</tt>) to explicitly terminate
    the statement.  Almost always, this is optional, however there may
    be rare cases where explicit termination is needed to force the
    parser into a correct interpretation.  The end-of-line will also
    act as a statement terminator, which is why a statement must
    appear in a single logical line.

    <p>
    With a couple of exceptions, an entire script can be given on a
    single line.  This is not recommended, as line-numbered error
    messages would not mean much, and the debugger would be useless,
    however this facilitates creating complicated macros with the
    "<tt>#define</tt>" preprocessor directive, which must always
    expand to a single line.

    The two exceptions are:
    <ol>
    <li>Comments and preprocessor directives start with '#' and 
        continue to the end of the current line.  Preprocessor
        directives must be given at the start of a line, though
        comments can appear in a line where a new statement could
        appear.  It is not possible to include (unrelated) command
        text after a comment or preprocessor directive in a line.
    <p>
    <li>The declaration lists that follow the <tt>static</tt> and
        <tt>global</tt> keywords must be terminated with a semicolon
        if a different construct (including a comment) is to appear on
        the same line following the <tt>static</tt> or <tt>global</tt>
        construct.
    </ol>

    <p>
    Scripts can interact with forms in HTML documents so that the form
    can be used as input for <i>Xic</i> scripts.  This is often more
    convenient than issuing a sequence of prompts to the user for
    input.  The <a href="scr:forms">forms interface</a> makes use of
    the HTML viewer used with the <a href="helpsys">help system</a>.

    <p>
    There is an expanding library of internal <a
    href="scr:iffuncs">functions</a> which can be called from scripts,
    described in the subtopics.  The parser also supports <a
    href="scr:functions">user-defined functions</a>.

    <p>
    Identifiers (function and variable names) must start with an
    alphabetic character or underscore, and can contain digits. 
    Characters other than alphanumerics and underscore are generally
    not accepted in identifiers and will cause syntax errors. 
    Identifiers are case-sensitive.

    <a name="errrpt"></a>
    <h2>Error Reporting</h2>

    Compile and run-time error messages go to the standard error
    channel.  That means, in interactive graphical mode, that the
    messages will appear in the terminal window from which <i>Xic</i>
    was launched.  Under Microsoft Windows, if <i>Xic</i> is started
    from an icon or the <b>Start</b> menu, a terminal window will be
    created.  This window is usually hidden behind the main graphics
    window, so one should make this window visible when developing
    scripts.  The same applies to the terminal window under
    Unix/Linux.

    <a name="datatype"></a>
    <h2>Data Types</h2>

    <p>
    Variables may be one of several different types.  The types that
    are currently implemented are listed below.

    <dl>
    <dt>no type<dd>
    Before a variable receives an assignment, it has no type, but
    behaves in all respects as a string with a value of the variable name.
    </dl><dl>
    <dt>string<dd>
    The string type contains text data.
    </dl><dl>
    <dt>scalar<dd>
    Scalars are real numbers that are stored internally in
    double-precision floating point format.  Conversion to integer
    values, such as for array subscription, is performed automatically
    where needed.
    </dl><dl>
    <dt>array<dd>
    The array type contains a 1-3 dimensional array of numerical
    values.
    </dl><dl>
    <dt>complex<dd>
    The complex type contains real and imaginary double precision
    floating-point scalar values.  Most math functions and operators
    accept complex values, and return complex values if passed a
    complex value.
    </dl><dl>
    <dt>handle<dd>
    The handle type contains a reference to a complex data object.
    There are a number of different object types that can be referenced
    by handles.
    </dl><dl>
    <dt>zoidlist<dd>
    Zoidlists contain a list of trapezoids that define spatial regions.
    </dl><dl>
    <dt>layer_expr<dd>
    This variable type contains a parse tree for a <a
    href="layer_exp">layer expression</a>.  A layer expression is a
    logical expression involving layer names.
    </dl>

    <p>
    The type of a variable is determined by its assignment, or in the
    case of arrays, by declaration.  Once a type is assigned, it is
    generally an error to assign a different type.  Exceptions are the
    undefining of array pointers (to be discussed), the promotion of
    scalars to handles when a handle is assigned to a scalar, and use
    of the <tt>delete</tt> operator to unassign a variable and free
    its contents.

    <p>
    Variables that are referenced before assignment, or after being
    operated on by <tt>delete</tt>, behave as strings with a string
    value set to the variable name.  For example, if an unassigned
    variable is passed to one of the print functions the name of that
    variable will be printed.

    <p>
    Type identification of a literal is by context.  A quoted quantity
    is always taken to be a string, e.g., "2.345" is a string.  Quote
    marks can be included in strings by preceding them with a
    backslash.  A number in integer, floating, or exponential format
    is always taken as a scalar.

    <a name="scalar"></a>
    <h4>Scalars</h4>

    Scalar variables do not need to be declared, and are type assigned
    when an assignment is first made.  Any unquoted number
    representation in integer, floating point, or exponential notation
    is taken as a scalar constant.  Character constants enclosed in
    single quotes (as in C) are accepted, with the value being the
    ASCII character code.  There is a <a
    href="ToChar"><tt>ToChar</tt></a> function which converts ASCII
    codes to a string representation for printing.  Also accepted are
    hexadecimal integer constants in the form
    <blockquote>
    <tt>0x</tt><i>hex_number</i>
    </blockquote>
    For example, <tt>0x0</tt>, <tt>0x2a</tt>, and <tt>0xffff003b</tt>
    are all valid constants.

    <p>
    In addition to the standard floating-point formats, numbers can be
    represented using SPICE multiplier suffixes.  These are alphabetic
    characters and sequences shown in the table below, which appear
    immediately following a fixed-point number or integer.  The suffix
    is case-insensitive.  For example, the following tokens all
    represent the same number:  <tt>1000</tt>, <tt>1e3</tt>,
    <tt>1k</tt>.  Likewise:  <tt>0.0001234</tt>, <tt>1.234e-4</tt>,
    <tt>123.4u</tt>.

    <blockquote>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><th>suffix</th> <th>multiplier</th> <th>name</th></tr>
    <tr><td><tt>a</tt></td> <td><tt>1e-18</tt></td> <td><tt>atto</tt></td></tr>
    <tr><td><tt>f</tt></td> <td><tt>1e-15</tt></td> <td><tt>femto</tt></td></tr>
    <tr><td><tt>p</tt></td> <td><tt>1e-12</tt></td> <td><tt>pico</tt></td></tr>
    <tr><td><tt>n</tt></td> <td><tt>1e-9</tt></td> <td><tt>nano</tt></td></tr>
    <tr><td><tt>u</tt></td> <td><tt>1e-6</tt></td> <td><tt>micro</tt></td></tr>
    <tr><td><tt>m</tt></td> <td><tt>1e-3</tt></td> <td><tt>milli</tt></td></tr>
    <tr><td><tt>mil</tt></td> <td><tt>25.4</tt></td> <td><tt>mil</tt></td></tr>
    <tr><td><tt>k</tt></td> <td><tt>1e3</tt></td> <td><tt>kilo</tt></td></tr>
    <tr><td><tt>meg</tt></td> <td><tt>1e6</tt></td> <td><tt>mega</tt></td></tr>
    <tr><td><tt>g</tt></td> <td><tt>1e9</tt></td> <td><tt>giga</tt></td></tr>
    <tr><td><tt>t</tt></td> <td><tt>1e12</tt></td> <td><tt>tera</tt></td></tr>
    </table>
    </blockquote>

    <a name="string"></a>
    <h4>Strings</h4>

    String variables do not need to be declared, and are type assigned
    when an assignment is first made.  Double quote marks are used to
    delimit literal strings, and are strictly necessary if the string
    contains spaces or other non-alphanumeric characters.

    <p>
    Whenever a string is defined as a literal in a script or from the
    <b>Monitor</b> panel in the <a href="xic:debug"><b>Script
    Debugger</b></a>, it is filtered through a function which converts
    the following escape codes into the actual character value.  The
    escape codes recognized, from ANSI C Standard X3J11, are

    <blockquote>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><td><tt>\a</tt></td> <td>bell</td></tr>
    <tr><td><tt>\b</tt></td> <td>backspace</td></tr>
    <tr><td><tt>\f</tt></td> <td>form-feed</td></tr>
    <tr><td><tt>\n</tt></td> <td>new-line</td></tr>
    <tr><td><tt>\r</tt></td> <td>carriage return</td></tr>
    <tr><td><tt>\t</tt></td> <td>tab</td></tr>
    <tr><td><tt>\v</tt></td> <td>vertical tab</td></tr>
    <tr><td><tt>\'</tt></td> <td>single quote</td></tr>
    <tr><td><tt>\"</tt></td> <td>double quote</td></tr>
    <tr><td><tt>\\</tt></td> <td>backslash</td></tr>
    </table>
    </blockquote>

    <p>
    In addition, forms like "<tt>\</tt><i>num</i>" are interpreted as
    an 8-bit character with ASCII value the 1, 2, or 3 digit octal
    number <i>num</i>.

    <p>
    When a subscript is applied to a string, the index applies to the
    string with escapes substituted, e.g., "<tt>\n</tt>" counts as one
    character.  When a string is printed to the <b>Monitor</b> panel,
    the reverse filtering is performed.

    <p>
    A special case is the null string, which is produced by many of
    the interface functions, usually to signal end-of-input or an
    error.  A null string has no storage.  Null strings are not
    accepted by some functions, so return values from these functions
    should be tested.

    <p>
    For example:

    <blockquote>
    <pre>
    retstr = Get(blather)
    if (retstr == NULL)     # NULL is an alias for 0
    #    the string is null
    end
    if (retstr == "")
    #    the string is empty
    end
    </pre>
    </blockquote>

    <p>
    This example above uses <a href="scr:mathops">operator overloading</a>
    for strings.

    <p>
    The notation can be even simpler:

    <blockquote>
    <pre>
    if (retstr)
    #    the string is not null (but may be empty)
    else
    #    the string is null
    end
    </pre>
    </blockquote>

    <p>
    The [] notation can be used to address individual characters in
    strings.  Also, <i>string1</i> = <i>string2</i> + <i>number</i> is
    accepted, yielding a string pointing at the <i>number</i>'th
    character of <i>string2</i>.  However, it is a fatal error if
    <i>number</i> is negative, so it is not possible to point
    backwards into a string.  Also, if the <i>number</i> exceeds the
    text length of the string, a fatal error is generated.  A fatal
    error is an error which will terminate script execution.

    <p>
    Strings are not copied in assignment, so if multiple variables
    point to the same string, they will all see any modifications to
    the string.  For example:
    <blockquote>
    <pre>
    s1 = "a string"
    s2 = s1 + 2
    Print(s2)     # prints "string"
    s1[4] = ' '
    Print(s2)     # prints "st ing"
    Print(s1)     # prints "a st ing"
    </pre>
    </blockquote>

    The <a href="Strdup"><tt>Strdup</tt></a> function can be used to
    make an independent copy of an existing string.

    <a name="array"></a>
    <h4>Arrays</h4>

    <i>Xic</i> provides arrays with up to three dimensions.  The
    indices are specified as comma-separated expressions enclosed in
    square brackets which follow the variable name, as in
    <tt>x[c,d]</tt> for a two dimensional array.  The higher
    dimensions appear to the right, so that <tt>c</tt> in the example
    is the "inner" index.

    <a name="decl"></a>
    <h5>Declaring and Defining Arrays</h5>

    Arrays must be declared either by initial assignment, or by a line
    consisting of the array name followed by square-bracketed indices
    representing the maximum index in each dimension.  In each case,
    the number of comma-separated indices sets the dimensionality of
    the array.  In the initial declaration, the indices must be
    integers and not expressions.  Indices are 0-based.

    <p>
    Examples
    <blockquote><tt>
    x[2, 4]<br>
    # This defines an array x: five blocks of three values<br>
    <br>
    x[2, 4] = <i>some_expression</i><br>
    # This likewise defines the array, and additionally sets<br>
    # the highest index to the result of an expression<br>
    </tt></blockquote>

    <p>
    Note that the numbers in the declaration are <i>not</i> sizes, but
    maximum values.  This is different than C.  Once an array has been
    defined, subsequent use allows expressions as the index values.

    <a name="init"></a>
    <h5>Initialization</h5>

    We have seen that array elements can be initialized individually
    by assignment.  It is also possible to initialize all or part of
    an array as a block, using the syntax below:

    <blockquote>
    <i>array</i><tt>[</tt><i>index</i>[,...]<tt>]</tt> = <tt>[</tt><i>a</i>,
      <i>b</i>, <i>c</i>, ... <tt>]</tt>
    </blockquote>

    <p>
    The left side represents a starting address, in the format of an
    array element reference.  The outer square brackets are explicit,
    the inner square brackets represent optional higher dimension
    indices and are not explicit.  The square brackets on the right
    side are explicit, and entries are separated by commas and
    optional white space.  One can use backslash-continuation to break
    a long initializer into multiple physical (but not logical) lines. 
    The values from the right side are placed in the array starting at
    the indicated address, in the natural order of array scalar
    access.  The array size is expanded when necessary.  The line also
    serves to declare the array.

    <p>
    The <i>a</i>, <i>b</i>, <i>c</i>, ...  can be expressions, or most
    commonly simple numbers.

    <p>
    Example:
    <blockquote>
    <tt>ary[0] = [1, 2, 3, 4]</tt>
    </blockquote>

    This declares and creates a size 4 array named <tt>ary</tt>, with
    components 1, 2, 3, 4.  This is equivalent to the lines
    <blockquote><tt>
    ary[0] = 1<br>
    ary[1] = 2<br>
    ary[2] = 3<br>
    ary[3] = 4</tt>
    </blockquote>

    <a name="resize"></a>
    <h5>Dynamic Resizing</h5>

    In an assignment, if an index is given that is "too large", the
    array will be reconfigured so that the new data point will be
    included.  The existing data in the array will remain.

    <p>
    Example
    <blockquote><tt>
    x[2, 4]<br>
    x[3, 0] = 2<br>
    # The array is now sized as if declared with "x[3,4]"
    </tt></blockquote>

    <p>
    After the assignment, the maximum index for each dimension will be
    the larger of the previous index and the assigning index.

    <p>
    When assigning values to an array, dimensional indices that are
    omitted are taken as zero, though at least one value must be
    supplied.

    <p>
    Example
    <blockquote><tt>
    x[2, 4]<br>
    x[1] = 3<br>
    # This is equivalent to x[1,0] = 3
    </tt></blockquote>

    <p>
    This treatment of missing indices only applies in assignment, and
    <i>not</i> in general references, as will be seen below.

    <p>
    There is one important restriction on dynamic resizing:  arrays
    that have pointer variables pointing at them can not be resized,
    and arrays can not be resized through a pointer.  Pointers are
    described below.

    <p>
    The <a href="GetDims"><tt>GetDims</tt></a> function can be used to
    obtain the current dimensions of an array.

    <a name="pointer"></a>
    <h5>Pointers</h5>

    A pointer to an array is a variable which points to the data of an
    array, and behaves as an array itself but does not contain its own
    data.  Pointers can point to the array itself, or to a sub-array
    of an array with multiple dimensions, or to an offset into the
    data of a single dimensional array.

    <p>
    The simplest case is a direct assignment to an array.
    <blockquote><tt>
    x[2, 4]<br>
    y = x
    </tt></blockquote>

    <p>
    In this case, the data (held in <tt>x</tt>) can be accessed
    through <tt>y</tt> or <tt>x</tt> equivalently.  In this special
    case, <tt>y</tt> is an alias, and the array can be dynamically
    resized through <tt>y</tt> or <tt>x</tt>.

    <p>
    A more interesting case is provided through use of the overloaded
    '+' operator.  For example
    <blockquote><tt>
    x[2, 4]<br>
    y = x + 1
    </tt></blockquote>

    <p>
    In this construct, the offset is into the highest dimension of
    <tt>x</tt>, and the return value is the sub-array found at this
    offset.  In the example, <tt>y</tt> is a "[2]" which is located at
    the address of <tt>x[0,1]</tt>, i.e., <tt>y[0] = x[0, 1]</tt>,
    <tt>y[1] = x[1, 1]</tt>, <tt>y[2] = x[2, 1]</tt>.

    <p>
    If <tt>x</tt> is a single dimensional array, <tt>y</tt> would also
    be a single dimensional array, but accessing the data through the
    offset.  For example
    <blockquote><tt>
    x[32]<br>
    y = x + 10
    </tt></blockquote>

    <p>
    Then <tt>y[0] = x[10]</tt>, <tt>y[1] = x[11]</tt>, etc.

    <p>
    In general references, but <i>not</i> assignments, supplying a smaller
    number of dimensions to an array will return a sub-array.  For
    example,
    <blockquote><tt>
    x[2, 4]<br>
    y = x[1]
    </tt></blockquote>

    <p>
    This is equivalent to "<tt>y = x + 1</tt>", and <tt>y</tt> will
    point to a "[2]" at the location of <tt>x[0,1]</tt>.

    <p>
    <blockquote><tt>
    x[2,4,5]<br>
    y = x[2]<br>
    z = x[3,4]
    </tt></blockquote>

    <p>
    The variable <tt>y</tt> is a "[2,4]" located at <tt>x[0,0,2]</tt>. 
    The variable <tt>z</tt> is a "[2]" located at <tt>x[0,3,4]</tt>.

    <p>
    When a pointer is defined, a reference count is incremented in the
    pointed-to array.  When this reference count is nonzero, the array
    can not be resized through the dynamic resizing mechanism.  The
    pointers to an array must be reassigned or undefined to allow
    resizing of the array.  Pointers can be reassigned simply by
    changing them to point to a different array.  This can be done
    arbitrarily.
    <blockquote><tt>
    x[2, 4]<br>
    y[32]<br>
    z = x + 1<br>
    # can't resize x here<br>
    z = y<br>
    # now ok to resize x
    </tt></blockquote>

    <p>
    One can undefine a pointer by setting it to 0.  Once this is done,
    the pointer variable has no type, and can actually be reused as
    another type of variable.  It is <i>not</i> an integer unless it is
    assigned to an integer.  The same effect may be obtained by applying
    the <tt>delete</tt> operator.
    <blockquote><tt>
    x[2, 4]<br>
    y = x + 1<br>
    # can't resize x here<br>
    y = 0<br>
    # now ok to resize x<br>
    Print(y)<br>
    # will give "y", y has no type and acts like a string<br>
    y = 0<br>
    Print(y)<br>
    # will give "0", y is now an integer<br>
    </tt></blockquote>

    <p>
    In our initial case,
    <blockquote><tt>
    x[2, 4]<br>
    y = x
    </tt></blockquote>

    <p>
    where the pointer is simply a reference to the array, <tt>y</tt>
    is not strictly speaking a pointer, but rather an alias.  In
    particular, this has no limitation on resizing.  The array data
    can be resized through <tt>y</tt> or <tt>x</tt>.  Thus, arrays can
    be resized from within function calls if the reference to the
    array itself is passed to the function, and not a pointer (with an
    offset).

    <a name="complex"></a>
    <h4>Complex</h4>

    Support for complex numbers is provided via the complex data type. 
    The basic math operators and functions accept complex numbers,
    possibly intermixed with scalar values, and will produce a complex
    result when given a complex operand when appropriate.  Generally,
    a complex number can be passed to a function expecting a real
    number, and the real part of the complex number will be used. 
    Similarly, a scalar passed to a function expecting a complex
    number will be accepted as a complex value with zero imaginary
    part.

    <p>
    Presently, functions will not produce a complex result unless
    passed a complex argument.  For example, the <tt>sqrt</tt>
    function, if passed a negative scalar, will return a scalar zero. 
    If passed a complex number with negative real part and zero
    imaginary part, the return will be the complex square root value
    as one would expect.

    <p>
    Complex numbers can be created with the <a
    href="cmplx"><tt>cmplx</tt></a> initializer function, which takes
    as arguments two scalar values that initialize the real and
    imaginary part.  There are special functions that return as
    scalars the real and imaginary values, magnitude, and phase of a
    complex operand.  The <a href="Print"><tt>Print</tt></a> function
    and similar will print a complex value as a comma-separated pair
    of numbers enclosed in parentheses.

    <a name="handle"></a>
    <h4>Handles</h4>

    Several of the interface functions return "handles", which are
    variables which contain a reference to a complex data object.  The
    handles are in turn passed to other functions which operate on the
    referenced data object.  If an active handle is passed to the
    <tt>Print</tt> family of functions, a string giving the type of
    handle will be printed.

    <p>
    When done with a handle, it should be closed (with the <a
    href="Close"><tt>Close</tt></a> function) to free the memory used
    by the data object.  The same effect is obtained by applying the
    <tt>delete</tt> operator to the handle.  When iterating over a
    list-type of handle, the handle will be closed automatically when
    iteration is complete.

    <p>
    There are many different types of data object that can be accessed
    with a handle, some examples being:
    <blockquote>
    string lists<br>
    database objects<br>
    file descriptors<br>
    properties
    </blockquote>
    With a few exceptions, notably the file descriptor, a handle
    generally points to a list of objects, such as the currently
    selected objects, that can be iterated through.  Once the
    iteration is complete, the handle is automatically closed, and
    further references will not reference an object.

    <p>
    See the section on <a href="scr:mathops">math operators</a> for a
    discussion of the operations available on handles.

    <p>
    The <a href="HandleContent"><tt>HandleContent</tt></a> function
    can be called on any handle, and will return the number of objects
    that can be referenced through the handle.  Zero is returned when
    the handle has iterated to completion.  This function is useful in
    loops which contain iterations over handles.

    <p>
    If a handle still contains references but it is no longer needed,
    the <tt>Close</tt> function should be called on the handle, or the
    <tt>delete</tt> operator applied to the handle, to free internal
    resources.

    <a name="zoidlist"><a/>
    <h4>Zoidlists</h4>

    A "zoidlist" is a list of trapezoids, which represents a
    set of spatial regions.  Like handles, zoidlists are created
    by certain functions, for use in other functions.

    <p>
    As in layer expressions, the logical operators can be applied
    to zoidlists, with the result being a new zoidlist representing
    the geometric result of the operation.  Available operations
    include intersection (and), union (or), inversion, and clipping.
    See the section on <a href="scr:mathops">math operators</a> for a
    discussion of the operations available on zoidlists.
    
    <p>
    There is a current "reference" zoidlist which represents the
    "background".  If not explicitly set (with the <a
    href="SetZref"><tt>SetZref</tt></a> function), this is taken as
    the boundary of the current cell.  The reference is used in
    operations such as inversion and exclusive-or where the size of
    the background must be assumed.  Note that this background can be
    an arbitrary shape.

    <p>
    In binary operators with zoidlists, if one of the operands is an
    integer, 0 represents an empty list, and nonzero represents the
    reference list.

    <p>
    If a zoidlist is given to one of the <tt>Print</tt> family of
    functions, the coordinates are printed, one trapezoid per line, in
    order x-lower-left, x-lower-right, y-lower, x-upper-left,
    x-upper-right, y-upper.

    <p>
    Zoidlists can be assigned from other zoidlists, in which case a
    copy is made internally.  If the assigned-to zoidlist already
    contained a list, that list is freed from memory.

    <a name="lexpr"></a>
    <h4>Lexpers</h4>

    The layer_expr variable contains a parsed layer expression.  A <a
    href="layer_exp">layer expression</a> is an expression consisting
    of layer names and logical operators.  A layer expression is
    evaluated within a certain region, representing part of a physical
    layout, and returns the regions where the layer expression is
    "true".

    <p>
    A layer_expr is a piece of compiled code that can execute very
    quickly.  Functions that accept a layer_expr argument will
    generally also accept a string containing the layer expression,
    and will compile the string before use.  If an expression is to be
    used multiple times, if is far more efficient to pass a layer_expr
    variable.

    <p>
    These variables can not be assigned, and no operators can be
    applied.  They can be passed to functions only.

    <p>
    If passed to the <tt>Print</tt> family of functions, the layer
    expression string will be printed.

!!SUBTOPICS
scr:constants
scr:control
scr:crypt
scr:exec
scr:forms
scr:functions
scr:library
scr:mathfuncs
scr:mathops
scr:iffuncs
scr:preproc
scr:global
xic:debug
xic:usermenu

!! 110115
!!KEYWORD
scr:mathops
!!TITLE
Math Operators
!!HTML
    <table border=0>
    <tr><td valign=top><b>jump to</b></td> <td>
    <a href="scr:mathops#overload"><b>Operator Overloading</b></a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <a href="scr:mathops#stringovl"><b>String Overloads</b></a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <a href="scr:mathops#arrayovl"><b>Array Overloads</b></a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <a href="scr:mathops#handleovl"><b>Handle Overloads</b></a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <a href="scr:mathops#zoidlistovl"><b>Zoidlist Overloads</b></a>
    </td></tr></table>

    <p>
    The following mathematical operations are supported.
    <br clear=all>

    <blockquote>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><th>Symbol</th> <th>Arity</th> <th>Description</th></tr>
    <tr><td><tt>+</tt></td> <td>binary</td> <td>addition</td></tr>
    <tr><td><tt>-</tt></td> <td>unary</td> <td>negation</td></tr>
    <tr><td><tt>-</tt></td> <td>binary</td> <td>subtraction</td></tr>
    <tr><td><tt>++</tt></td> <td>unary</td>
     <td>pre- and post-increment</td></tr>
    <tr><td><tt>--</tt></td> <td>unary</td>
     <td>pre- and post-decrement</td></tr>
    <tr><td><tt>*</tt></td> <td>binary</td> <td>multiplication</td></tr>
    <tr><td><tt>/</tt></td> <td>binary</td> <td>division</td></tr>
    <tr><td><tt>%</tt></td> <td>binary</td>
     <td>remainder, e.g., 5 % 3 = 2</td></tr>
    <tr><td><tt>^</tt></td> <td>binary</td>
     <td>power, x ^ y = x to power y</td></tr>
    <tr><td><tt>& , and</tt></td> <td>binary</td> <td>and, value is 1 if both
      operands are nonzero</td></tr>
    <tr><td><tt>| , or</tt></td> <td>binary</td> <td>or, value is 1 if either
      operand is nonzero</td></tr>
    <tr><td><tt>! , ~ , not</tt> <td>unary</td> <td>not, value is 1/0 if
      operand is zero/nonzero</td></tr>
    <tr><td><tt>> , gt</tt></td> <td>binary</td> <td>greater than, value is 1
      if left operand is greater than the right</td></tr>
    <tr><td><tt>>= , ge</tt></td> <td>binary</td> <td>greater or equal, value
      is 1 if left operand is greater or equal to the right</td></tr>
    <tr><td><tt>&#60 , lt</tt></td> <td>binary</td> <td>less than, value is 1
      if the left operand is less than the right</td></tr>
    <tr><td><tt>&#60= , le</tt></td> <td>binary</td> <td> less or equal,
      value is 1 if the left operand is less than or equal to the
      right</td></tr>
    <tr><td><tt>!= , ne , &#60> , >&#60</tt></td> <td>binary</td> <td>not
      equal, value is 1 if the left operand is not equal to the right</td></tr>
    <tr><td><tt>== or eq</tt></td> <td>binary</td> <td> equal, value is 1 if
      the left operand is equal to the right</td></tr>
    <tr><td><tt>=</tt></td> <td>binary</td> <td>the left operand takes the
      value of the right, and the value is that of the right operand</td></tr>
    </table>
    </blockquote>

    The operator-equivalent keywords (<tt>gt</tt>, <tt>lt</tt>, <tt>ge</tt>,
    <tt>le</tt>, <tt>ne</tt>, <tt>eq</tt>, <tt>or</tt>, <tt>and</tt>,
    <tt>not</tt>) are recognized without case sensitivitty.

    <p>
    A variable type is determined by its first assignment, of by
    declaration for arrays.  It is generally an error to attempt to
    redefine a variable to a different type, though if a scalar is
    assigned from a handle, the scalar type is promoted to handle
    type.

    <p>
    Note that all operators, including assignment, return a value. 
    Thus, expressions like <tt>3*(x > y)</tt> make sense (the value is
    0 or 3).  Binary true is indicated by a nonzero value.

    <p>
    The increment/decrement operators (<tt>++/--</tt>) behave as in
    the C language.  That is
    <blockquote>
    <tt>y = x++</tt>  is equivalent to <tt>y = x; x = x + 1</tt><br>
    <tt>y = x--</tt>  is equivalent to <tt>y = x; x = x - 1</tt><br>
    <tt>y = ++x</tt>  is equivalent to <tt>x = x + 1; y = x</tt><br>
    <tt>y = x--</tt>  is equivalent to <tt>x = x - 1; y = x</tt><br>
    </blockquote>

    <p>
    All of these operations apply to scalar or complex values.  If
    complex and scalar values are mixed, scalar operands are promoted
    to complex with zero imaginary value.  If a complex operand is
    given, the result is also complex, except for comparison and
    logical operators, and modulus, which always return scalar values. 
    Comparison operators are applied to both real and imaginary parts,
    and both must separately satisfy the relation.  Increment and
    decrement operations apply only to the real part of a complex
    value.  In logical operations, a complex value is "false" if both
    the real and imaginary parts are 0.

    <a name="overload"></a>
    <h2>Operator Overloading</h2>

    In general, the operators apply only to numerical variables. 
    However, some of these operators can be used with particular
    variable types, in which case a function, relevant to that
    variable, is invoked.  In most cases, this is equivalent to
    invoking an actual function call from the user interface.  If a
    non-numeric variable is supplied to an operator for which no
    overload exists, the script will generally abort with an error.

    <a name="stringovl"></a>
    <h4>String Overloads</h4>

    <p>
    The operators <tt>==, !=, >, >=, &#60, &#60=</tt> have been
    overloaded for strings.  If the two operands are strings, the C
    <tt>strcmp</tt> function is invoked to compare the two strings. 
    If either string is null, it is treated as if it has a lexically
    minimal value.  Either operand can be a scalar 0, which is treated
    as a null string.  Thus, forms like <tt>if (string == 0)</tt> can
    be used to test for a null string.  Null strings, which have no
    storage, are produced be some script functions.  These are
    different from empty strings, produced for example by <tt>string =
    ""</tt>, which contain an invisible string termination character.

    <p>
    The + operator has been overloaded for strings to perform
    concatenation, similar to the <tt>Strcat</tt> library function. 
    The expression <tt>s3 = s1 + s2</tt> is equivalent to <tt>s3 =
    Strcat(s1, s2)</tt>.

    <p>
    The + and - operators can be applied where the first argument is a
    string and the second argument is a scalar, and vice-versa in the
    case of +.  The result of the operation is a pointer into the
    string, which behaves as a string with the first character at the
    offset given by the scalar.  An error is generated if the offset
    is negative, or is beyond the end of the string,

    <p>
    The - operator can be applied where both operands are strings. 
    The result is a scalar variable representing the difference
    between the memory addresses of the two strings.  This is only
    useful if both operands are references to the same string.

    <p>
    The ! operator can be applied to strings.  The construct is
    true only if the string variable contains a null string.

    <a name="arrayovl"></a>
    <h4>Array Overloads</h4>

    Pointer arithmetic is discussed in the section describing
    <a href="xicscript#array">array variables</a>.

    <a name="handleovl"></a>
    <h4>Handle Overloads</h4>

    Handles can be used in conditional and logical expressions using
    the and (&), or (|), and not (!) operators.  If the handle is
    non-empty, it is "true", otherwise it is "false".  This can be
    used as a far more efficient loop termination test than a call to
    <tt>HandleContent</tt>.

    <p>
    The relational operators have been overloaded for handles.  The
    behavior for handles is the same as for scalars, with the handle
    index being used in the comparison.  This is not expected to be
    useful, except perhaps for file descriptor handles.

    <p>
    The + operator is overloaded to perform concatenation, equivalent to
    a call to the <tt>HandleCat</tt> function.  The syntax is
    <blockquote>
    <tt>[h1 =] h2 + h3</tt>
    </blockquote>

    This applies only to handles that contain a list of data items. 
    Both <tt>h2</tt> and <tt>h3</tt> must contain lists of the same
    type of data.  The list in <tt>h3</tt> is copied and pasted on the
    end of <tt>h2</tt>.  If a left hand side is given, it will be
    assigned the <tt>h2</tt> handle value and be equivalent to
    <tt>h2</tt>.  Most of the time, this is not needed.

    <p>
    The increment operator ++ is overloaded to perform iteration,
    equivalent to a call to <tt>HandleNext</tt> or similar
    functions.  The postfix and prefix forms are equivalent.  The
    return value is simply a copy of the handle, so again use in an
    assignment is unlikely to be needed often.

    <p>
    Without overloading, code to iterate over a list handle would
    appear as

    <pre>
    h = func_returning_list_handle()
    while (HandleContent(h) != 0)
    &nbsp;   (do something)
    &nbsp;   HandleNext(h)
    done
    </pre>

    <p>
    Making use of overloading, the same loop could take the following
    form:

    <pre>
    h = func_returning_list_handle()
    while (h)
    &nbsp;   (do something)
    &nbsp;   h++
    done
    </pre>

    <a name="zoidlistovl"></a>
    <h4>Zoidlist Overloads</h4>

    The math and logical operators are overloaded for zoidlists as follows:

    <blockquote>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><td><tt>+, |</tt></td>    <td>union</td></tr>
    <tr><td><tt>-</tt></td>       <td>and-not</td></tr>
    <tr><td><tt>*, &</tt></td>    <td>intersection</td></tr>
    <tr><td><tt>^</tt></td>       <td>exclusive or</td></tr>
    <tr><td><tt>!</tt></td>       <td>inverse</td></tr>
    </table>
    </blockquote>

    The result of the operation is a new zoidlist, with neither of
    the operands affected.

    <p>
    To test for an empty zoidlist, the <tt>==</tt> and <tt>!=</tt>
    comparisons to the value 0 can be applied.  Note that "<tt>if
    (!zlist)</tt>" is an incorrect test for an empty zoidlist; it will
    invert the list and return true if the inverted list is not
    empty.

    <p>
    There is a current "reference" zoidlist which represents the
    "background".  If not explicitly set (with the <tt>SetZref</tt>
    function), this is taken as the boundary of the current cell.  The
    reference is used in operations such as inversion and exclusive-or
    where the size of the background must be assumed.  Note that this
    background can be an arbitrary shape.  In binary operators with
    zoidlists, if one of the operands is a scalar, 0 represents an
    empty list, and nonzero represents the reference list.

!!SEEALSO
xicscript

!! 032612
!!KEYWORD
scr:control
!!TITLE
Control Structures
!!HTML
    <table border=0>
    <tr><td valign=top><b>jump to</b></td> <td>
    <a href="scr:control#delete"><b><tt>delete</tt></b></a><br>
    <a href="scr:control#return"><b><tt>return</tt></b></a><br>
    <a href="scr:control#if"><b><tt>if, elif, else</tt></b></a><br>
    <a href="scr:control#ternary"><b>ternary conditional</b></a><br>
    <a href="scr:control#repeat"><b><tt>repeat</tt></b></a><br>
    <a href="scr:control#while"><b><tt>while</tt></b></a><br>
    <a href="scr:control#dowhile"><b><tt>dowhile</tt></b></a><br>
    <a href="scr:control#break"><b><tt>break</tt></b></a><br>
    <a href="scr:control#continue"><b><tt>continue</tt></b></a><br>
    <a href="scr:control#goto"><b><tt>goto, label</tt></b></a>
    </td></tr></table>

    <p>
    As in C, logical "true" is indicated by a nonzero value.  The
    following control statements are accepted:
    <br clear=all>

    <a name="delete"></a>
    <h2><tt>delete</tt></h2>
    <blockquote>
    <tt>delete</tt> <i>variable</i>
    </blockquote>

    Although not strictly a "control" keyword, the <tt>delete</tt>
    operator is handled at the control-block level.  The operator will
    return the variable to its undefined state, as if before any
    assignment, and free the contents.  After the <tt>delete</tt>
    operator is applied, the variable can be assigned to any data
    type.

    <p>
    Using the <tt>delete</tt> operator on an array will remove the
    array characteristics, so in general the variable can not
    subsequently be used as an array, except by assigning the variable
    to another array.  The <a href="FreeArray"><tt>FreeArray</tt></a>
    function can be used to clear the data while still preserving the
    variable as an array, so that values can still be directly
    assigned at indices.

    <p>
    The delete operator applied to a handle will close the handle, as
    if the <a href="Close"><tt>Close</tt></a> function was called. 
    However, the handle will become an undefined variable after
    <tt>delete</tt>, rather than a scalar 0.

    <p>
    There are two reasons why this operator exists.  The user may wish
    to delete unused variables that contain large data blocks to
    conserve memory.  Also, the <a
    href="ConvertReply"><tt>ConvertReply</tt></a> function can return
    a variable of any type, thus we must have an undefined variable to
    take the return, which is impossible in a loop without use of the
    <tt>delete</tt> operator.

    <p>
    The <tt>delete</tt> operator will generally delete the contents,
    however for arrays and strings, if the variable has an alias,
    the content will be retained in the alias, and all pointers or
    substrings remain valid.  If the array or string variable has no
    alias, any associated pointers or substrings will also be
    reinitialized, and the underlying data will be freed from
    memory.  Deleting a pointer or substring variable causes that
    variable to be undefined, but does not affect the pointed-to
    data.

    <a name="return"></a>
    <h2><tt>return</tt></h2>

    <blockquote>
    <tt>return</tt> [<i>expression</i>]
    </blockquote>

    If the <tt>return</tt> keyword is encountered in the main part of
    a script, execution of the script terminates at that point, and
    the value returned from any following <i>expression</i> is saved. 
    This return value is available as a return from the <a
    href="funcs:main1:script#Exec"><tt>Exec</tt></a> function, if that
    command was used to execute the script.  In general, the return
    value is ignored.

    <p>
    If used in a <a href="scr:functions">function</a>, the function
    returns immediately with the value of the <i>expression</i>, if
    given.

    <a name="if"></a>
    <h2><tt>if, elif, else</tt></h2>

    <p>
    <blockquote>
    <dl>
    <dt><tt>if</tt> <i>expression1</i>
      <dd><i>statements1</i>
    <dt><tt>elif</tt> <i>expression2</i>
      <dd><i>statements2</i>
    <dt>...<br>
    <dt><tt>elif</tt> <i>expressionN</i>
      <dd><i>statementsN</i>
    <dt><tt>else</tt>
      <dd><i>statements</i>
    <dt><tt>end</tt>
    </dl>
    </blockquote>

    <p>
    If <i>expression1</i> evaluates nonzero, <i>statements1</i> will
    be executed, otherwise if <i>expression2</i> evaluates nonzero,
    <i>statements2</i> will be executed, and so on.  If none of the
    expressions evaluate nonzero, <i>statements</i> following
    <tt>else</tt> will be executed.  The only parts that are mandatory
    are <tt>if</tt>, <i>expression1</i>, and <tt>end</tt>, all other
    clauses are optional.

    <p>
    Note that <tt>elif</tt> is <i>not</i> the same as "<tt>else
    if</tt>".  The following two blocks are equivalent:

    <pre>
    &#32;   # example using "elif"
    &#32;   if (a == 1)
    &#32;       Print(1)
    &#32;   elif (a == 2)
    &#32;       Print(2)
    &#32;   else
    &#32;        Print("?");
    &#32;   end

    &#32;   # example using "else if"
    &#32;   if (a == 1)
    &#32;       Print(1)
    &#32;   else
    &#32;       if (a == 2)
    &#32;           Print(2)
    &#32;       else
    &#32;           Print("?")
    &#32;       end
    &#32;   end
    </pre>

    <p>
    In particular, a common error is the following:

    <pre>
    &#32;   if (a == 1)
    &#32;       Print(1)
    &#32;   else if (a == 2)
    &#32;       Print(2)
    &#32;   else
    &#32;       Print("?")
    &#32;   end
    </pre>

    This is missing an "<tt>end</tt>" statement (see the second form
    above).

    <a name="ternary"></a>
    <h2>ternary conditional</h2>

    <blockquote>
    <i>a</i> <tt>?</tt> <i>b</i> <tt>:</tt> <i>c</i>
    </blockquote>
    
    The ternary conditional operation, familiar from the C programming
    language, is supported.  In this construct, the '<tt>?</tt>' and
    '<tt>:</tt>' are literal, the <i>a</i>, <i>b</i>, and <i>c</i> are
    expressions.  If <i>a</i> evaluates as <tt>true</tt>, then <i>b</i>
    is evaluated and the construct returns its result.  Otherwise, <i>c</i>
    is evaluated and the construct returns that result.  Hence, the form

    <blockquote>
    <tt>x = a ? b : c</tt>
    </blockquote>

    is equivalent to

    <blockquote>
    <pre>
    if (a)
    &nbsp;&nbsp;&nbsp;x = b
    else
    &nbsp;&nbsp;&nbsp;x = c
    end
    </pre>
    </blockquote>

    The "<tt>true</tt>" condition depends on the type of variable
    represented by <i>a</i>, as for the <tt>if</tt> operator.  For
    example, the following are <tt>true</tt>:
    <ul>
    <li>A nonzero numeric value.  This includes the result of a
    conditional expression when the condition is satisfied.
    <li>An active handle.
    <li>A non-empty zoidlist (a layer expression is evaluated to obtain
    a zoidlist).
    <li>A non-null string.
    </ul>

    <a name="repeat"></a>
    <h2><tt>repeat</tt></h2>

    <p>
    <blockquote>
    <dl>
    <dt><tt>repeat</tt> <i>expression</i>
      <dd><i>statements</i>
    <dt><tt>end</tt>
    </dl>
    </blockquote>

    <p>
    Execute <i>statements</i> <i>n</i> times, where <i>n</i> is the
    integer result of evaluating <i>expression</i>.  The
    <i>expression</i> is evaluated once only when the block is
    entered, and the integer value computed is used as the loop
    counter.  The value is tested for zero, which will terminate the
    loop, and is decremented after each pass.  A negative value will
    produce an error and the script will terminate.

    <a name="while"></a>
    <h2><tt>while</tt></h2>

    <p>
    <blockquote>
    <dl>
    <dt><tt>while</tt> <i>expression</i>
      <dd><i>statements</i>
    <dt><tt>end</tt>
    </dl>
    </blockquote>

    <p>
    On each pass through the loop, if <i>expression</i> evaluates nonzero,
    execute <i>statements</i>, otherwise exit the loop.

    <a name="dowhile"></a>
    <h2><tt>dowhile</tt></h2>

    <p>
    <blockquote>
    <dl>
    <dt><tt>dowhile</tt> <i>expression</i>
      <dd><i>statements</i>
    <dt><tt>end</tt>
    </dl>
    </blockquote>
      
    <p>
    On each pass through the loop, execute <i>statements</i>, then
    evaluate <i>expression</i>.  If <i>expression</i> evaluates to
    zero, exit the loop.

    <a name="break"></a>
    <h2><tt>break</tt></h2>

    <p>
    <blockquote>
    <tt>break</tt> [<i>n</i>]
    </blockquote>

    <p>
    In a loop, the <tt>break</tt> statement will exit the loop.  If an
    integer <i>n</i> is given, control reaches the bottom of the
    <i>n</i>'th enclosing loop. 

    <p>
    Example:
    <pre>
    &#32;   while x &#60;= 100
    &#32;     while y &#60;= 50
    &#32;       while z &#60;= 20
    &#32;          statements
    &#32;          if (x + y + z == 10)
    &#32;              break 2
    &#32;          end
    &#32;       end
    &#32;     end
    &#32;   # break will jump here
    &#32;   end
    </pre>

    <a name="continue"></a>
    <h2><tt>continue</tt></h2>

    <p>
    <blockquote>
    <tt>continue</tt> [<i>n</i>]
    </blockquote>

    <p>
    In a loop, <tt>continue</tt> causes the loop to be reentered from
    the top.  If an integer <i>n</i> is given, the <i>n</i>'th
    enclosing loop is reentered. 

    <p>
    Example:
    <pre>
    &#32;   while x &#60;= 100
    &#32;     # continue will jump here
    &#32;     while y &#60;= 50
    &#32;       while z &#60;= 20
    &#32;          statements
    &#32;          if (x + y + z == 10)
    &#32;              continue 2
    &#32;          end
    &#32;       end
    &#32;     end
    &#32;   end
    </pre>

    <a name="goto"></a>
    <h2><tt>goto, label</tt></h2>

    <p>
    <blockquote>
    <tt>goto</tt> <i>name</i><br>
    <tt>label</tt> <i>name</i>
    </blockquote>

    <p>
    Execution can jump to an arbitrary location in a routine with
    the <tt>goto</tt> statement.  Execution resumes at the statement
    following the associated <tt>label</tt>.

    <p>
    Example:

    <pre><tt>
    &#32;   statements
    &#32;   if (z != 0)
    &#32;       goto error
    &#32;   end
    &#32;   statements ...
    &#32;   label error
    &#32;   Print("error occurred")
    </tt></pre>

!!SEEALSO
xicscript

!! 020511
!!KEYWORD
scr:preproc
!!TITLE
Preprocessor
!!HTML
    The script parser interprets C-like "preprocessor" keywords. 
    Unlike C, there is only a single pass through the text, so
    "preprocessor" is a misnomer.

    <p>
    The script preprocessor utilizes the generic <a href="macro">macro
    preprocessor</a> used in various places within <i>Xic</i>.  In the
    present context, the keywords start with the comment '#' character.

    <p>
    In addition to the predefined macros of the generic macro
    preprocessor, the following predefined macro is used in scripts.

    <dl>
    <dt><tt>THIS_SCRIPT</tt><dd>
    For any script which is read from a file (not counting the
    technology file) the macro <tt>THIS_SCRIPT</tt> is effectively
    defined to be the name of the script (for scripts launched from
    the <b>User Menu</b>) or a path to the file.  Thus, in the script,
    the token <tt>THIS_SCRIPT</tt> is replaced by the file or script
    name.  For example, to print the script name in the console
    window, one could add a line
    <blockquote>
    <tt>Print("The name of this script is THIS_SCRIPT")</tt>
    </blockquote>
    </dl>

    <p>
    The following "preprocessor" keywords are understood in scripts.
    These pretty much follow the C/C++ standards and behave similarly,
    and correspond to the gereneralized keywords described for the
    macro preprocessor.  These are:

    <blockquote>
    <table cellpadding=2 border=1 bgcolor="#ffffee">
    <tr><th>Keyword</th> <th>Function</th></tr>
    <tr><td><tt>#define</tt></td> <td>Define a macro.</td></tr>
    <tr><td><tt>#if</tt></td> <td>Conditional evaluated test.</td></tr>
    <tr><td><tt>#ifdef</tt></td> <td>Conditional definition test.</td></tr>
    <tr><td><tt>#ifndef</tt></td> <td>Conditional non-definition test.</td></tr>
    <tr><td><tt>#else</tt></td> <td>Conditional else clause.</td></tr>
    <tr><td><tt>#endif</tt></td> <td>Conditional end clause.</td></tr>
    </table>
    </blockquote>

    <p>
    In addition, the following keyword, which has no counterpart in the
    generic macro preprocessor, is recognized in scripts:

    <dl>
    <dt><tt>#macro</tt>
    <dd>The <tt>#macro</tt> directive, which has no counterpart in C,
    is assumed to be followed by macro statements in the format used
    in the <tt>.xicmacros</tt> file, followed by <tt>#end</tt> or
    <tt>#endif</tt>.  If the <tt>#macro</tt> sequence appears in a
    script file, the macro is defined at that point. 
    </dl>

    <p>
    Throughout the script, each line is macro expanded.  The actual
    arguments replace the formal arguments (if any) in the
    substitution text, which replaces the macro reference.  The macro
    reference is recognized as a text token, i.e., it must be
    surrounded by punctuation or white space.

!!SEEALSO
xicscript


!!REDIRECT cmplx        scr:mathfuncs
!!REDIRECT real         scr:mathfuncs
!!REDIRECT imag         scr:mathfuncs
!!REDIRECT mag          scr:mathfuncs
!!REDIRECT ang          scr:mathfuncs

!!REDIRECT abs          scr:mathfuncs
!!REDIRECT acos         scr:mathfuncs
!!REDIRECT acosh        scr:mathfuncs
!!REDIRECT asin         scr:mathfuncs
!!REDIRECT asinh        scr:mathfuncs
!!REDIRECT atan         scr:mathfuncs
!!REDIRECT atan2        scr:mathfuncs
!!REDIRECT atanh        scr:mathfuncs
!!REDIRECT cbrt         scr:mathfuncs
!!REDIRECT ceil         scr:mathfuncs
!!REDIRECT cos          scr:mathfuncs
!!REDIRECT cosh         scr:mathfuncs
!!REDIRECT erf          scr:mathfuncs
!!REDIRECT erfc         scr:mathfuncs
!!REDIRECT exp          scr:mathfuncs
!!REDIRECT floor        scr:mathfuncs
!!REDIRECT gauss        scr:mathfuncs
!!REDIRECT int          scr:mathfuncs
!!REDIRECT j0           scr:mathfuncs
!!REDIRECT j1           scr:mathfuncs
!!REDIRECT jn           scr:mathfuncs
!!REDIRECT ln           scr:mathfuncs
!!REDIRECT log          scr:mathfuncs
!!REDIRECT log10        scr:mathfuncs
!!REDIRECT max          scr:mathfuncs
!!REDIRECT min          scr:mathfuncs
!!REDIRECT pow          scr:mathfuncs
!!REDIRECT random       scr:mathfuncs
!!REDIRECT rint         scr:mathfuncs
!!REDIRECT seed         scr:mathfuncs
!!REDIRECT sgn          scr:mathfuncs
!!REDIRECT sin          scr:mathfuncs
!!REDIRECT sinh         scr:mathfuncs
!!REDIRECT sqrt         scr:mathfuncs
!!REDIRECT tan          scr:mathfuncs
!!REDIRECT tanh         scr:mathfuncs
!!REDIRECT y0           scr:mathfuncs
!!REDIRECT y1           scr:mathfuncs
!!REDIRECT yn           scr:mathfuncs

!! 110115
!!KEYWORD
scr:mathfuncs
!!TITLE
Math Functions
!!HTML
    The following functions apply to complex numbers.
    <blockquote>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><td><tt>cmplx</tt>(<i>r</i>, <i>i</i>)</td>
       <td>Return a complex number</td></tr>
    <tr><td><tt>real</tt>(<i>c</i>)</td>
       <td>Return real part of a complex number</td></tr>
    <tr><td><tt>imag</tt>(<i>c</i>)</td>
       <td>Return imaginary part of a complex number</td></tr>
    <tr><td><tt>mag</tt>(<i>c</i>)</td>
       <td>Return the magnitude of a complex number</td></tr>
    <tr><td><tt>ang</tt>(<i>c</i>)</td>
       <td>Return the phase of a complex number</td></tr>
    </table>
    </blockquote>

    <p>
    The <tt>cmplx</tt> function is used to initialize a complex number
    through assignment, for example
    <blockquote><tt>
    cx = cmplx(1.0, 0.5)
    </tt></blockquote>
    creates a complex number <tt>cx</tt> with value <tt>(1.0 +
    j0.5)</tt>.  The other functions take a complex number as
    an argument, and return a scalar result.

    <p>
    The following math functions are defined internally, and all take
    scalar or complex arguments.

    <blockquote>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><td><tt>abs</tt>(<i>x</i>)</td>
       <td>absolute value or magnitude of &nbsp;<i>x</i></td></tr>
    <tr><td><tt>acos</tt>(<i>x</i>)</td>
       <td>arc-cosine of &nbsp;<i>x</i></td></tr>
    <tr><td><tt>acosh</tt>(<i>x</i>)</td>
       <td>arc-hyperbolic cosine of &nbsp;<i>x</i></dd></tr>
    <tr><td><tt>asin</tt>(<i>x</i>)</td>
       <td>arc-sine of &nbsp;<i>x</i></td></tr>
    <tr><td><tt>asinh</tt>(<i>x</i>)</td>
       <td>arc-hyperbolic sine of &nbsp;<i>x</i></td></tr>
    <tr><td><tt>atan</tt>(<i>x</i>)</td>
       <td>arc-tangent of &nbsp;<i>x</i></td></tr>
    <tr><td><tt>atan2</tt>(<i>x</i>, <i>y</i>)</td>
       <td>arc tangent of &nbsp;<i>x</i>, <i>y</i></td></tr>
    <tr><td><tt>atanh</tt>(<i>x</i>)</td>
       <td>arc-hyperbolic tangent of &nbsp;<i>x</i></td></tr>
    <tr><td><tt>cbrt</tt>(<i>x</i>)</td>
       <td>cube root of &nbsp;<i>x</i></td></tr>
    <tr><td><tt>ceil</tt>(<i>x</i>)</td>
       <td>smallest integer >= <i>x</i></td></tr>
    <tr><td><tt>cos</tt>(<i>x</i>)</td>
       <td>cosine of &nbsp;<i>x</i></td></tr>
    <tr><td><tt>cosh</tt>(<i>x</i>)</td>
       <td>hyperbolic cosine of &nbsp;<i>x</i></td></tr>
    <tr><td><tt>erf</tt>(<i>x</i>)</td>
       <td>error function of &nbsp;<i>x</i></td></tr>
    <tr><td><tt>erfc</tt>(<i>x</i>)</td>
       <td>complementary error function of &nbsp;<i>x</i></td></tr>
    <tr><td><tt>exp</tt>(<i>x</i>)</td>
       <td>e to the &nbsp;<i>x</i> power</td></tr>
    <tr><td><tt>floor</tt>(<i>x</i>)</td>
       <td>largest integer &#60;= <i>x</i></td></tr>
    <tr><td><tt>gauss</tt>()</td>
       <td>gaussian random number</td></tr>
    <tr><td><tt>int</tt>(<i>x</i>)</td>
       <td>truncated integer value of &nbsp;<i>x</i></td></tr>
    <tr><td><tt>j0</tt>(<i>x</i>)</td>
       <td>Bessel function order 0 of &nbsp;<i>x</i></td></tr>
    <tr><td><tt>j1</tt>(<i>x</i>)</td>
       <td>Bessel function order 1 of &nbsp;<i>x</i></td></tr>
    <tr><td><tt>jn</tt>(<i>x</i>, <i>n</i>)</td>
       <td>Bessel function order <i>n</i> of &nbsp;<i>x</i></td></tr>
    <tr><td><tt>ln</tt>(<i>x</i>)</td>
       <td>natural logarithm of &nbsp;<i>x</i></td></tr>
    <tr><td><tt>log</tt>(<i>x</i>)</td>
       <td>natural logarithm of &nbsp;<i>x</i>, see below</td></tr>
    <tr><td><tt>log10</tt>(<i>x</i>)</td>
       <td>base 10 logarithm of &nbsp;<i>x</i></td></tr>
    <tr><td><tt>max</tt>(<i>x</i>, <i>y</i>)</td>
       <td>largest of &nbsp;<i>x</i>, <i>y</i></td>
    <tr><td><tt>min</tt>(<i>x</i>, <i>y</i>)</td>
       <td>smallest of &nbsp;<i>x</i>, <i>y</i></td>
    <tr><td><tt>pow</tt>(<i>x</i>, <i>y</i>)</td>
       <td><i>x</i> to the <i>y</i> power</td>
    <tr><td><tt>random</tt>()</td>
       <td>random value in [0,1)</td></tr>
    <tr><td><tt>rint</tt>(<i>x</i>)</td>
       <td>integer nearest to &nbsp;<i>x</i></td></tr>
    <tr><td><tt>seed</tt>(<i>x</i>)</td>
       <td>random number generator seed</td></tr>
    <tr><td><tt>sgn</tt>(<i>x</i>)</td>
       <td>+1, 0, -1 if &nbsp;<i>x</i> > 0, <i>x</i> = 0, <i>x</i> &#60; 0</td></tr>
    <tr><td><tt>sin</tt>(<i>x</i>)</td>
       <td>sine of &nbsp;<i>x</i></td></tr>
    <tr><td><tt>sinh</tt>(<i>x</i>)</td>
       <td>hyperbolic sine of &nbsp;<i>x</i></td></tr>
    <tr><td><tt>sqrt</tt>(<i>x</i>)</td>
       <td>square root of &nbsp;<i>x</i></td></tr>
    <tr><td><tt>tan</tt>(<i>x</i>)</td>
       <td>tangent of &nbsp;<i>x</i></td></tr>
    <tr><td><tt>tanh</tt>(<i>x</i>)</td>
       <td>hyperbolic tangent of &nbsp;<i>x</i></td></tr>
    <tr><td><tt>y0</tt>(<i>x</i>)</td>
       <td>Neumann function order 0 of &nbsp;<i>x</i></td></tr>
    <tr><td><tt>y1</tt>(<i>x</i>)</td>
       <td>Neumann function order 1 of &nbsp;<i>x</i></td></tr>
    <tr><td><tt>yn</tt>(<i>x</i>, <i>n</i>)</td>
       <td>Neumann function order <i>n</i> of &nbsp;<i>x</i></td></tr>
    </table>
    </blockquote>

    <p>
    Most of these functions, when given complex arguments, will
    compute a complex result.  The <tt>atan2</tt>, <tt>seed</tt>,
    Bessel, Neuman, and error functions ignore any imaginary parts and
    compute a real value only.  The <tt>ceil</tt>, <tt>floor</tt>,
    <tt>int</tt>, <tt>rint</tt>, and <tt>sgn</tt> functions apply the
    operation to real and imaginary parts of complex arguments.  The
    <tt>min</tt> and <tt>max</tt> functions generate a complex result
    containing the operations applied to the real and imaginary parts
    of the arguments, if at least one argument is complex.  The
    functions listed that take no arguments return scalar values.

    <p>
    With scalar arguments, these functions behave as the corresponding
    functions in the C library, though the random number functions are
    specialized to <i>Xic</i>.  The <tt>seed</tt> function applies a
    seed value to the random number generators.  This can be used to
    ensure that successive runs using random numbers choose different
    values.  The seed value given is converted to an integer before
    use.  The <tt>random</tt> function returns a random value in the
    range [0-1).  The numbers generated have a uniform distribution. 
    The <tt>gauss</tt> function returns gaussian random numbers with
    zero mean and unit deviation.

    <p>
    <b>Note regarding the log function</b><br>
    In <i>Xic</i> releases prior to 3.2.23, the <tt>log</tt> function
    returned the base-10 logarithm.  This definition was changed in
    3.2.23, and the <tt>log10</tt> function added, for consistency
    with programming languages, <i>WRspice</i>, and most other
    software.  This will require users to update legacy scripts that
    use the <tt>log</tt> function to call <tt>log10</tt> instead. 
    However, there is a <a href="LogIsLog10"><tt>LogIsLog10</tt></a>
    variable that can be set to revert <tt>log</tt> to base-10.  This
    can be used temporarily, but is not recommended for the long-term.

    <p>
    See the <i>WRspice</i> <a href="mathfuncs">functions</a> for
    appropriate descriptions of the functions that appear in
    <i>WRspice</i> expressions.

!!SEEALSO
xicscript

!! 062908
!!KEYWORD
scr:functions
!!TITLE
User-Defined Functions
!!HTML
    <p>
    In scripts, user-defined functions are supported.  The function must
    be defined before it is called.

    <p>
    A function definition starts with the keyword <tt>function</tt>,
    followed by the function name and argument list.  The keyword
    <tt>endfunc</tt> terminates the definition.  These blocks can
    appear anywhere between statements in a script file, however they
    must appear before any calls to the function.  Once a function has
    been parsed, it is added to an internal database, where a compiled
    representation is retained.  If the same function is parsed again,
    the in-memory representation is updated.  There is a mechanism for
    automatically loading <a href="scr:library">libraries</a> of
    script functions at program startup.  Use of this mechanism avoids
    the overhead of repeatedly parsing function definitions that are
    found in script files.

    <p>
    The function is called just like a built-in function.  Scalar
    variables are passed by value, other types are passed to the
    function by reference.  Variables defined within a function are
    automatic by default.

    <p>
    Functions can return a value.  In a function, the construct
    <blockquote>
    <tt>return [</tt><i>expression</i><tt>]</tt>
    </blockquote>
    can be used to terminate execution, and the value of the
    <i>expression</i> is returned by the function.  The value returned
    can be of any type.
    If the return value is a local string, the string will be copied. 
    If the return value is a pointer to an array, the array must have
    been passed as an argument or have been declared
    <a href="scr:global"><tt>static</tt></a> or <tt>global</tt>.

    <p>
    The example below illustrates how variables are passed, and the
    scope for changes.  Strings and arrays can not be redefined in a
    function, but elements can be changed, and arrays can be resized. 
    Arrays can be used to pass results back to the calling function.

    <p>
    Example:

    <blockquote>
    <pre>
    function myfunc(a, b, c)
    Print(a, b, c)
    endfunc
    </pre>

    <pre>
    function examp(a, b, c)
    # a is a constant, can be redefined within the scope of examp
    a = 2
    # b is a string, it is an error to redefine, but can be altered,
    # in which case the string is altered in the calling function as
    # well
    #b = "b string"   (this produces an error)
    b[2] = 'x'
    # c is an array, it is an error to redefine, but elements can be
    # changed, in which case this is reflected to all users of the
    # array
    # c[3]  (redefinition, this is an error)
    c[1] = 1.234
    myfunc(a, b, c)
    endfunc
    </pre>

    <pre>
    Print("this is a test")
    x = 1
    y = "a string"
    z[2]
    myfunc(x, y, z)
    examp(x, y, z)
    myfunc(x, y, z)
    </pre>
    </blockquote>

    <p>
    It is presently not possible to single-step through a function in
    the <a href="xic:debug"><b>Script Debugger</b></a>.

!!SEEALSO
xicscript
scr:exec

!! 062908
!!KEYWORD
scr:exec
!!TITLE
The exec Keyword - Immediate Execution
!!HTML
    Script execution is a two-step process:  first, the text of the
    script is parsed, and executable data structures are created
    internally, and second, the execution is performed.  Consider the
    following script:
    <blockquote>
    <tt>Set("ScriptPath", "</tt><i>/path/to/library_dir</i><tt>")</tt><br>
    <i>some_library_function</i><tt>()</tt>
    </blockquote>
    Naively, the first line will set the script path to the directory
    containing the <a href="scr:library"><tt>library</tt></a> file,
    and the second line will execute a function from the library. 
    However, this will not run, since the library function must be
    resolved before the parser can process the function call. 
    Somehow, we must ensure that the <tt>Set</tt> line is executed
    before the following line is parsed.

    <p>
    The <tt>exec</tt> keyword will perform this trick.  When an
    <tt>exec</tt> keyword is encountered, the remainder of the line
    (or to the next semicolon) is parsed and executed immediately, and
    is <i>not</i> added to the parse tree for scheduled execution with
    the other lines.  Thus, the example above should be
    <blockquote>
    <tt>exec Set("ScriptPath", "</tt><i>/path/to/library_dir</i><tt>")</tt><br>
    <i>some_library_function</i><tt>()</tt>
    </blockquote>

    <p>
    Multiple <tt>exec</tt> lines are executed in order of appearance. 
    Variables can be used and set, but remember that this will be done
    before any manipulation from the normal script lines.  For
    example, the <b>ScriptPath</b> switch can be hidden:
    <blockquote>
    <tt>exec tmppath = GetPath("ScriptPath")<br>
    exec Set("ScriptPath", "</tt><i>/path/to/library_dir</i><tt>")</tt><br>
    <i>some_library_function</i><tt>()</tt><br>
    <tt>Set("ScriptPath", tmppath)</tt>
    </blockquote>
    The <tt>tmppath</tt> variable will be set first, and is used to
    reset the <b>ScriptPath</b> as a final operation.

!!SEEALSO
xicscript

!! 062908
!!KEYWORD
scr:global
!!TITLE
Static and Global Variables
!!HTML
    Variables defined in script <a href="scr:functions">functions</a>
    are automatic by default.  The term "automatic" means that every
    call of the function provides a fresh set of variables.  A static
    variable, on the other hand, retains its contents between calls,
    and the same variable storage is used in all calls to the
    function.  One can explicitly assign a variable in a function to
    be static using the <tt>static</tt> keyword.  This construct can
    appear only in functions (not the main procedure), and <i>must</i>
    appear ahead of all other executable statements.  The syntax is

    <blockquote>
    <tt>static</tt> <i>var1</i> [= <i>val</i>] <i>var2</i> ...
    </blockquote>

    <p>
    The terms can be separated by white space and/or commas.  The
    <i>var1</i>, etc., are variables used in the function that are to
    have static storage.  They can optionally be initialized by
    including an assignment.  If an assignment is used, the right hand
    side should consist of constants and variables that have already
    been assigned, meaning that they appear to the left in the present
    line or in a previous <tt>static</tt> line (there can be more than
    one).  Array variables should have an initial dimensionality/size
    specification consisting of comma-separated integers enclosed in
    square brackets.  Each such integer represents the maximum index
    for the dimension, with the lowest dimension listed to the left. 
    This is the standard syntax for array declaration.

    <p>
    Example:
    <blockquote><tt>
    function myfunc(a, b, c)<br>
    static callcnt = 0<br>
    ...<br>
    callcnt = callcnt + 1<br>
    Print("myfunc has been called", callcnt, "times")<br>
    endfunc<br>
    </tt></blockquote>

    <p>
    There is also provision for global variables.  Global variables
    are variables whose scope extends to all functions where the
    variables have been declared, including the main procedure.  These
    are useful for data items that are accessed frequently throughout
    a script application.

    <p>
    The <tt>global</tt> keyword is used to declare global variables. 
    The syntax is identical to that for the <tt>static</tt> keyword,
    and similarly the declaration must appear at the top of a function
    and the main procedure.  There can be more than one
    <tt>global</tt> line.

    <blockquote>
    <tt>global</tt> <i>var1</i> [= <i>val</i>] <i>var2</i> ...
    </blockquote>

    In functions, the list following the keyword can not contain
    assignments or array subscripting.  As with <tt>static</tt>
    declarations, <tt>global</tt> declarations must appear at the top
    of the function body.  There can be multiple <tt>global</tt>
    lines, and these can be freely mixed with <tt>static</tt> lines. 
    Global variables are not accessible unless declared.

    <p>
    A global variable must be declared in each function where it is to
    be accessed, and in the main procedure.  Assignments and array
    initialization can be applied in the declarations in the main
    procedure only.  It is an error to declare a global with
    assignment more than once, or to declare with an assignment in a
    function.  Like other variables, if a global variable is not
    initialized in a declaration, the first assignment will define the
    variable type.  Global array variables must be initialized with
    the maximum initial indices in each dimension, comma separated,
    enclosed in square brackets in the main function, but indices
    should <i>not</i> appear in the declarations in functions.

    <p>
    Example:

    <blockquote>
    <pre>
    function myfunc()
    &#32   global gvar
    &#32   Print(gvar)
    &#32   gvar = gvar + 1
    endfunc

    global gvar = 1
    myfunc()
    Print(gvar)
    # output is:
    # 1
    # 2
    </pre>
    </blockquote>

    <p>
    Global variables declared in functions create links to the global
    variable of the same name declared in the main procedure.  If the
    function is defined in a separate file from the main procedure,
    such as a <a href="scr:library"><tt>library</tt></a> file, and a
    global variable is declared and used in the function that is not
    also declared in the main procedure, an error results.

!!SEEALSO
xicscript

!! 032613
!!KEYWORD
scr:constants
!!TITLE
Predefined Constants
!!HTML
    The following constants are recognized by name:

    <blockquote>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><td align="left"><tt>e</tt></td>
        <td>Natural log base</td></tr>
    <tr><td align="left"><tt>pi</tt></td>
        <td>3.14159...</td></tr>
    <tr><td align="left"><tt>PI</tt></td>
        <td>3.14159...</td></tr>
    <tr><td align="left"><tt>NULL</tt></td>
        <td>0</td></tr>
    <tr><td align="left"><tt>INFINITY</tt></td>
        <td>Maximum extent of object field</td></tr>
    <tr><td align="left"><tt>TRUE</tt></td>
        <td>Boolean yes (1)</td></tr>
    <tr><td align="left"><tt>FALSE</tt></td>
        <td>Boolean no (0)</td></tr>
    <tr><td align="left"><tt>EOF</tt></td>
        <td>-1</td></tr>
    <tr><td align="left"><tt>CHARGE</tt></td>
        <td>1.60217646e-19</td></tr>
    <tr><td align="left"><tt>CTOK</tt></td>
        <td>273.15</td></tr>
    <tr><td align="left"><tt>BOLTZ</tt></td>
        <td>1.3806226e-23</td></tr>
    <tr><td align="left"><tt>ROOT2</tt></td>
        <td>square root of 2</td></tr>
    </table>
    </blockquote>

    <p>
    The value of <tt>INFINITY</tt> is the internally assumed absolute
    limit for valid coordinates, in microns.  This is 1e9 divided by
    the database resolution, which is the value of the <a
    href="DatabaseResolution"><b>DatabaseResolution</b></a> variable
    if set, or the default of 1000.


!!SEEALSO
xicscript

!! 062908
!!KEYWORD
scr:forms
!!TITLE
HTML Forms and Scripts
!!HTML
    <table border=0>
    <tr><td valign=top><b>jump to</b></td> <td>
    <a href="scr:forms#intro"><b>Introduction to HTML Forms</b></a><br>
    <a href="scr:forms#iface"><b>Interfacing Forms to <i>Xic</i> Scripts</b></a>
    </td></tr></table>

    <p>
    HTML forms can be used as input devices for scripts.  A form may
    provide a more convenient interface than a sequence of
    <tt>Ask</tt><i>XXX</i> functions, and arbitrary text and links
    into the help system can also be provided in the form text.
    <br clear=all>

    <a name="intro"></a>
    <h2>Introduction to HTML Forms</h2>

    Those interested in learning about forms in HTML should obtain a
    book on the subject.  A decent book on writing HTML documents is
    <blockquote>
    <u>HTML for the World Wide Web</u>, Elizabeth Castro, Peachpit
    Press, Berkeley CA 1989, isbn 0-201-69696-7.
    </blockquote>
    Below is a quick summary of the form-related tags.

    <p>
    An HTML form is a collection of input objects such as toggle
    buttons, text areas, and menus which allow the user to provide
    input.  Within the form is a <b>submit</b> button, which when pressed
    causes a predefined action to occur.  In HTML, the form is usually
    processed by the web page server (through a cgi script).  In
    <i>Xic</i>, the form may instead be processed by an <i>Xic</i>
    script.

    <p>
    A form starts with a tag of the form
    <blockquote>
    <tt>&#60form method="post" action="</tt><i>some text</i>"<tt>></tt>
    </blockquote>

    <p>
    All but "<i>some text</i>" should be copied verbatim.  In
    <i>Xic</i>, the "<i>some text</i>" is of the form
    "<tt>action_local_xic</tt> <i>script_path</i>".  The quotes are
    required, and <tt>action_local_xic</tt> should be copied verbatim. 
    The second word is the name of an <i>Xic</i> script file.  The
    "<tt>.scr</tt>" extension is optional, and if a directory path is
    not given, the script should exist in the script <a
    href="xicpaths">search path</a>.  Often, <i>script_path</i> is
    the predefined macro <tt>THIS_SCRIPT</tt>, which is replaced by
    the name of or path to the present script.

    <p>
    The opening &#60form ...> tag is followed by the contents of the
    form itself, which can consist of formatted text, and references
    to the following objects.

    <p>
    Every object is given a unique name.  This name is used to access
    the data in the script.  Each button object will also have a
    value, which is a string token passed to identify a choice, i.e.,
    which button of a group is selected.  This may be different than
    the label on the button.  In the tags, constructs like
    <tt>name=</tt>"<i>name</i>" indicate the keyword <tt>name</tt>,
    followed by an '=' with no surrounding space, which is followed by
    a quoted text string.

    <p>
    <dl>
    <dt>Text Boxes
    <dd>These are one-line entry areas.  The tag format is
    <blockquote>
    <tt>&#60input type="text" name="</tt><i>name</i><tt>"
     </tt><i>options</i><tt>></tt>
    </blockquote>
    The <i>options</i> (which are not required), can be:
    <dl><dt><tt>size=</tt>"<i>n</i>"
    <dd>The <i>n</i> is an integer that sets the field width in characters.
    </dl>
    <dl><dt><tt>maxlength=</tt>"<i>n</i>"
    <dd>The <i>n</i> is an integer which limits the length of input text.
    </dl>
    <dl><dt><tt>value=</tt>"<i>some text</i>"
    <dd>This indicates the text that will initially appear.
    </dl>
    <p>
    Example:
    <blockquote>
    <tt>Enter username: &#60input type="text" name="usertext"></tt>
    </blockquote>
    </dl>

    In this and other similar elements that take a
    "<tt>value="</tt><i>string</i><tt>"</tt>" clause, note that this
    will fail if <i>string</i> contains quote ('<tt>"</tt>')
    characters.  However, HTML '&' escapes are expanded in the string,
    so quote characters can be replaced with "<tt>&amp;quot;</tt>" to
    include quotation in the string.

    <dl>
    <dt>Password Boxes
    <dd>These are text boxes, except that characters are printed as
    "*" for security.  The format is similar to text boxes:
    <blockquote>
    <tt>&#60input type="password" name="</tt><i>name</i><tt>"
     </tt><i>options</i><tt>></tt>
    </blockquote>
    The <i>options</i> are the same as for text boxes.
    <p>
    Example:
    <blockquote>
    <tt>Enter password: &#60input type="password" name="passwd"></tt>
    </blockquote>
    </dl>

    <dl>
    <dt>Radio Buttons
    <dd>These are groups of buttons, one and only one of which is
    always selected.  The tag format is
    <blockquote>
    <tt>&#60input type="radio" name="</tt><i>name</i><tt>"
      value="</tt><i>value1</i><tt>"
      </tt><i>option</i><tt>></tt><i>text</i><br>
    <tt>&#60input type="radio" name="</tt><i>name</i><tt>"
      value="</tt><i>value2</i><tt>"
      </tt><i>option</i><tt>></tt><i>text</i><br>
    ...
    </blockquote>

    <p>
    Each radio button in the group has a line of the form above.  The
    only <i>option</i> is "<tt>checked</tt>" which can appear in only
    one line, and indicates which button is initially pressed (default
    is the first button listed).  Each button should have the same
    <tt>name</tt>, and a different <tt>value</tt>.  The text that
    follows the tag appears next to the button, and is usually but not
    necessarily the same as the value.

    <p>
    Example:
    <blockquote>
    <tt>&#60input type="radio" name="radioset" value="1">1</tt><br>
    <tt>&#60input type="radio" name="radioset" value="2" checked>2</tt><br>
    <tt>&#60input type="radio" name="radioset" value="3">3</tt>
    </blockquote>
    </dl>

    <dl>
    <dt>Check Boxes
    <dd>These are toggle buttons.  The tag format is
    <blockquote>
    <tt>&#60input type="checkbox" name="</tt><i>name</i><tt>"
     value="</tt><i>value</i><tt>" </tt><i>option</i><tt>></tt><i>text</i>
    </blockquote>

    <p>
    The only option is "<tt>checked</tt>" which indicates that the
    button is initially pressed.  The text following the tag appears
    next to the button, and is usually but not necessarily the same as
    the value.
    <p>
    Example:
    <blockquote>
    <tt>&#60input type="checkbox" name="check1" value="check1">check1</tt><br>
    <tt>&#60input type="checkbox" name="check2" value="check2" checked>check2</tt>
    </blockquote>
    </dl>

    <dl>
    <dt>Text Blocks
    <dd>These are multi-line text input areas.  The tag format is
    <blockquote>
    <tt>&#60textarea name="</tt><i>name</i><tt>"
     </tt><i>options</i><tt>></tt><i>default text</i><tt>&#60/textarea></tt>
    </blockquote>
    The options are

    <dl>
    <dt><tt>rows=</tt>"<i>n</i>"
    <dd>The <i>n</i> is an integer that sets the height to n characters.
    </dl>
    <dl>
    <dt><tt>cols=</tt>"<i>n</i>"
    <dd>The <i>n</i> is an integer that sets the width to n characters.
    </dl>
    The <i>default text</i>, if any, will appear in the text area
    initially.
    <p>
    Example:
    <blockquote>
    <tt>Type in your message:</tt>&#60br><br>
    <tt>&#60textarea name="message" rows="12" cols="40">Dear sirs,<br>
    &#60/textarea></tt>
    </blockquote>
    </dl>

    <dl>
    <dt>Option Menu
    <dd>This is a menu of selections, shown as a button containing the
    current selection.  Pressing the button produces a drop-down menu
    of choices.  the tag format is
    <blockquote>
    <tt>&#60select name="</tt><i>name</i><tt>" size="1"></tt><br>
    <tt>&#60option value="</tt><i>value1</i><tt>"
     </tt><i>option</i><tt>></tt><i>text</i><br>
    <tt>&#60option value="</tt><i>value2</i><tt>"
     </tt><i>option</i><tt>></tt><i>text</i><br>
    ...<br>
    <tt>&#60/select></tt>
    </blockquote>

    <p>
    There is one <tt>&#60option ...></tt> tag per menu entry.  The
    text following the <tt>&#60option ...></tt> tag will appear in the
    menu.  The only option is "<tt>selected</tt>" which can be given on
    only one line and indicates which item is initially selected (the
    default is the first item listed).
    <p>
    Example:
    <blockquote>
    <tt>&#60select name="opmenu" size="1"></tt><br>
    <tt>&#60option value="choose1">choose1</tt><br>
    <tt>&#60option value="choose2">choose2</tt><br>
    <tt>&#60option value="choose3">choose3</tt><br>
    <tt>&#60option value="choose4" selected>choose4</tt><br>
    <tt>&#60/select></tt>
    </blockquote>
    </dl>

    <dl>
    <dt>Selection Menu
    <dd>This type of menu has multiple lines, which can be selected by
    clicking.  The menu may be scrollable.  The tag format is
    <blockquote>
    <tt>&#60select name="</tt><i>name</i><tt>" size="</tt><i>n</i><tt>"
     </tt><i>option</i><tt>></tt><br>
    <tt>&#60option value="</tt><i>value1</i><tt>"
     </tt><i>option</i><tt>></tt><i>text</i><br>
    <tt>&#60option value="</tt><i>value2</i><tt>"
      </tt><i>option</i><tt>></tt><i>text</i><br>
    ...<br>
    <tt>&#60/select></tt>
    </blockquote>

    <p>
    The size in the <tt>&#60select ...></tt> tag is an integer greater
    than 1, which indicates the number of lines visible.  If this is
    less than the number of <tt>&#60option ...></tt> lines that
    follow, the menu will be scrollable.  The option that can appear
    in the <tt>&#60select ...></tt> tag is "<tt>multiple</tt>" which if
    given allows multiple lines to be selected, otherwise only a
    single entry can be selected.
    <p>
    Example:
    <blockquote>
    <tt>&#60select name="menu" size="2"></tt><br>
    <tt>&#60option value="choose1">choose1</tt><br>
    <tt>&#60option value="choose2">choose2</tt><br>
    <tt>&#60option value="choose3">choose3</tt><br>
    <tt>&#60option value="choose4">choose4</tt><br>
    <tt>&#60/select></tt>
    </blockquote>
    </dl>

    <dl>
    <dt>File Selection
    <dd>This is a text area with a <b>browse</b> button.  When the
    <b>browse</b> button is pressed, the <a href="filesel"><b>File
    Selection</b></a> panel appears, and the <b>Ok</b> button of the
    <b>File Selection</b> panel will transfer the selected file name
    to the form text area.  The format of the tag is
    <blockquote>
    <tt>&#60input type="file" name="</tt><i>name</i><tt>"
     </tt><i>option</i><tt>></tt>
    </blockquote>
    The only option is <tt>size=</tt>"<i>n</i>" to set the width in
    characters of the text area.
    <p>
    Example:
    <blockquote>
    <tt>&#60input type="file" name="filesel" size="64"></tt>
    </blockquote>
    </dl>

    <p>
    Each form must have a <b>submit</b> button.  A <b>reset</b>
    button, which resets all objects to their initial state, is
    generally useful.

    <dl>
    <dt>Submit Button
    <dd>This is a button which initiates action on the form.  This
    button is required if any action is to be taken on the form data. 
    The tag format is
    <blockquote>
    <tt>&#60input type="submit" </tt><i>option</i><tt>></tt>
    </blockquote>
    The only option is <tt>value=</tt>"<i>message</i>", where the
    <i>message</i> is the text that actually appears on the button,
    which is "Submit" if no value is specified.
    <p>
    Example:
    <blockquote>
    <tt>&#60input type="submit" value="Done"></tt>
    </blockquote>
    </dl>

    <dl>
    <dt>Reset Button
    <dd>This button resets each component of the form to the initial
    state.  The tag format is
    <blockquote>
    <tt>&#60input type="reset" </tt><i>option</i><tt>></tt>
    </blockquote>
    The only option is <tt>value=</tt>"<i>message</i>", where the
    <i>message</i> is the text that actually appears in the button,
    and is "Reset" if no value is specified.
    <p>
    Example:
    <blockquote>
    <tt>&#60input type="reset"></tt>
    </blockquote>
    </dl>

    <p>
    The form items can be intermixed with text, images, or other HTML
    formatting and objects.  To terminate a form definition, one must
    supply the tag
    <blockquote>
    <tt>&#60/form></tt>
    </blockquote>

    <p>
    Below is the "<tt>spform.html</tt>" file which is used with the
    <b>spiralform</b> demonstration script, as an example.

    <pre>
    &#60h2>Forms Demo -- Generate a Spiral&#60/h2>
    This page demonstrates the use of HTML forms as input devices for
    &#60i>Xic&#60/i> &#60a href="xicscript">scripts&#60/a>.  Press the &#60b>Submit&#60/b>
    button when ready.  The spiral will be attached to the pointer, and
    can be placed by clicking in a drawing window.

    &#60p>
    &#60form method="post" action="action_local_xic THIS_SCRIPT">

    Choose the number of turns in the spiral
    &#60select name="opmenu" size="1">
    &#60option value="1">1  
    &#60option value="2">2
    &#60option value="3">3
    &#60option value="4">4
    &#60option value="5">5
    &#60option value="6">6
    &#60option value="7">7
    &#60option value="8">8
    &#60option value="9">9
    &#60/select>

    &#60p>
    Enter the path width: &#60input type="text" name="pwidth" value="4">&#60br>
    Enter the starting radius: &#60input type="text" name="rad1" value="20">&#60br>
    Enter the pitch: &#60input type="text" name="pitch" value="10">&#60br>

    &#60p>
    Select the number of edges per turn:
    &#60input type="radio" name="radioset" value="10" checked>10
    &#60input type="radio" name="radioset" value="20">20
    &#60input type="radio" name="radioset" value="40">40

    &#60p>
    &#60input type="submit">
    &#60input type="reset">
    &#60/form>
    </pre>

    <a name="iface"></a>
    <h2>Interfacing Forms to <i>Xic</i> Scripts</h2>

    If a form has an action which is in the format
    "<tt>action_local_xic</tt> <i>scriptname</i>" then, when the
    <b>submit</b> button is pressed, the script in <i>scriptname</i>
    will be called, with the following:

    <ul>
    <li>The preprocessor variable SUBMIT is defined.
    </ul><ul>
    <li>A string-type variable is created for each active form
    element.  The variable name is that of the <tt>name</tt> field in
    the form element tag (so these must be unique).  The value of the
    variable is from the <tt>value</tt> tag of the selected button, or
    the text of a text-entry object.  The variable is defined only if
    the text object had text, or if a check button was pressed.
    </ul>

    <p>
    Within the script, one must supply the following logic:

    <ul>
    <li>Determine if the SUBMIT preprocessor variable is defined.  If
    yes, than the script was called by a form, otherwise the script
    was called by a button in the <b>User Menu</b>.  Note that this
    enables the script to initiate showing the form, as will be seen
    in the example below.
    </ul><ul>
    <li>For each variable, the script must identify if the variable
    was set, i.e., a text entry had text, and possibly convert the
    text to a numeric value.  The input should also be sanity checked
    at this point.
    </ul>

    <p>
    Below are the first few lines of an example script which could
    interface with the example form given above.  When the script is
    selected in the <b>User Menu</b>, it will display the help window
    containing its input form.  When the <b>submit</b> button of the
    form is pressed, the script will be called again, and the data
    processed.

    <p>
    <pre>
    #ifndef SUBMIT
    # SUBMIT is not defined, so we are being called from the User Menu
    # pop-up our input form in the HTML viewer and exit
    TextCmd("help spform.html")
    Exit()
    #endif

    # We are being called from the form (SUBMIT is defined)
    # First check the option menu return.  The entries are digits, which must
    # be converted from text strings to real values
    #
    if Defined(opmenu)
    &#32;   num = ToReal(opmenu)
    else
    # This should never fail, since the option menu always has a selection
    &#32;   ShowPrompt("number of turns unknown")
    &#32;   Exit()
    end

    # Next check the return from a text entry object.  Exit if the variable
    # is undefined (text input empty), or the result is a bad numeric value
    #
    if Defined(pwidth)
    &#32;   width = ToReal(pwidth)
    &#32;   if (width &#60 0)
    &#32;       ShowPrompt("Bad input (&#60 0) for width: ", width)
    &#32;       Exit()
    &#32;   end
    else
    &#32;   ShowPrompt("width unknown")
    &#32;   Exit()
    end

    (check other input variables)
    (perform calculations/operations)
    Exit
    </pre>

    <p>
    This is typical boilerplate for a form-entry script.

!!SEEALSO
xicscript

